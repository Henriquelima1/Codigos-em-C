// sudo ./bloq_imagem

#define SOFT_VERSION "SOFT V" CLIENTE "." VERSAO "." REVISAO

#define MAIN_INDIC_LUM_TAM_IDLE 30
#define MAIN_TIME_WAIT_FIRST_FRAME 10000  // 10s
#define MAIN_WAIT_CAMERA_FRAME 2000
#define MAIN_MAX_FRAME_SAVE_FILES 3000
#define MAIN_PICTURE_QUALITY_AVERAGE 100
#define FPS_AVERAGE 40
#define MAIN_LOOP_LIMIT_TIME_US 100000
#define DOCTEST_CONFIG_IMPLEMENT

//#define LOG_LEVEL_DEBUG
#include <opencv2/opencv.hpp>
#include "opencv4_compat.h"
#if CV_MAJOR_VERSION == 3
//#warning "USING OPENCV 3"
#include <opencv2/core/ocl.hpp>
#elif CV_MAJOR_VERSION == 2
//#warning "USING OPENCV 2"
#include <opencv2/ocl/ocl.hpp>
#endif

#include "doctest.h"
#include "AcknowledgeSignalManager.h"
#include "ActionManager.h"
#include "Arinc/arinc.hpp"
#include "BrMania/BrMania.h"
#include "CleaningMode.h"
#include "Configurator/Configurator.h"
#include "Controller/Pictogram.h"
#include "ConverterBytes.h"
#include "CredentialsBuffer.h"
#include "DFlowChangeIP.h"
#include "DebugFileManager/DebugFileManager.h"
#include "DiagnosticInterface/DiagnosticInterface.h"
#include "DoorsManager/DoorsFraudCheck.h"
#include "DoorsManager/DoorsLogManager.h"
#include "DoorsManager/DoorsManager.h"
#include "DoorsManager/MotorBoardSerialCommands.h"
#include "Dpass/Dpass.hpp"
#include "Dprint/DtowerBoard.h"
#include "ErrorIndicator.h"
#include "EventControlSita.hpp"
#include "ExternalReaderEnabler.h"
#include "LcdActivationRules/LcdActivationRules.hpp"
#include "LedStripTotem.hpp"
#include "LicenseVerifier.h"
#include "LightControl/NightMode.h"
#include "Log.h"
#include "MCAPersonCross.h"
#include "MutexModule.h"
#include "NewValidation.h"
#include "OldFilesDeleter.h"
#include "PeripheralDemonstration/PeripheralDemonstration.hpp"
#include "SGMIdentifier.h"
#include "SerialNumber.h"
#include "Sita.h"
#include "Sita/DeviceInformation.h"
#include "Sita/DflowEvent.h"
#include "Sita/DflowSbg.h"
#include "Sita/Sbg/Sbg.h"
#include "Soap/SoapAlarmController.h"
#include "Soap/SoapConfigurations.h"
#include "Soap/SoapNotificationLightController.h"
#include "Soap/SoapPictogramController.h"
#include "Socket/MiscellaneousNetworkOperations.h"
#include "TestHardware/TestHardware.h"
#include "ThreadStack.h"
#include "VisualCortex.h"
#include "arquivosGatesEmbarque.hpp"
#include "bltstream.hpp"
#include "dSoapdFlow/dFlow.nsmap"
#include "dSoapdFlow/soapH.h"
#include "display.hpp"
#include "lcd.h"
#include "event.hpp"
#include "faceMatch.hpp"
#include "gateLineServer.hpp"
#include "identificationRegister.hpp"
#include "ImageCalibration.h"
#include "infoCount.hpp"
#include "infoMonitor.hpp"
#include "logPass.hpp"
#include "obfuscate.h"
#include "remoteConfig.hpp"
#include "serverUpdate.hpp"
#include "snmp/snmpModule.h"
#include "soapDFlow.h"
#include "soapSensor.h"
#include "syncClient.hpp"
#include "videoAnalyzer.hpp"
#include "videoAnalyzer_IP.hpp"
#include "videoOutput.hpp"
#include "PeopleTrackingTest.h"
#include "SystemCommands.h"
#include "Rest/RestServer.h"
#include "Rest/RestClient.h"
#include "DoorsManager/DoorStatusManager.h"
#include "Scafis/Scafis.h"
#include "Sita/DeviceStatus.h"
#ifdef ENABLE_SELF_CHECKOUT
#include "SelfCheckout/SelfCheckout.h"
#endif

#include <execinfo.h>
#include <getopt.h>
#include <sys/statfs.h>
#include <sys/sysinfo.h>
#include <signal.h>

static bool _isValidationCheckRunning = false;
static bool _isTestFireAlarmRunning = true;
static bool _isSaveOpenCVFramesThreadRunning = true;
static bool _mcaAnimation = false;
static bool _mcaAnimationLOG = false;
static bool _validateMCA = false;
static bool _snapShotAutoSave = false;
static bool _flagPause = false;
static bool _flagStep = false;
static bool _saveFrameToBmp = false;
static bool _virtualButton = false;
static bool _virtualButtonUrn = false;
static bool _textMode = false;
static bool _statusInvitationLights = false;
static bool _flagUpdateBackground = true;
static bool _flagBackward = false;
static bool _flagUpdating = false;
static bool _forceSaveFrames = false;
static bool _sendFirstUpdateImages = false;
static bool _flagAnyCardValidation = false;
static bool _flagWaitingInvalidUserGetOut = false;
static bool _acceptAnyTicket = false;
static bool _flagGetStatusButtonUrn = false;
static bool _lastWaitingUserEntrace = false;
static bool _lastWaitingUserExit = false;
static bool _needStartIndiclum = false;
static bool _flagFullClosedDoor;
static bool isRunning = true;
static bool _isLogFilesDisabled = false;

static char _idSP[(MCASP_stringSize * 2u) + 1u];
static uint8_t _virtualUrnLoop = 0u;
static uint8_t _idCountEntrance = 0u;
static uint8_t _idCountExit = 0u;
static uint8_t _errorRed = 255u;

static int _personCounterIn = 0;
static int _imageCount = 0;
static int _currentDay = 370;
static int _currentHour = 25;
static int _validPersonCounterInTEMP = 0;
static int _intrusionPersonCounterInTEMP = 0;
static int _personCounterOut = 0;
static int _validPersonCounterOutTEMP = 0;
static int _intrusionPersonCounterOutTEMP = 0;
static int _flagZeroCounter = false;
static int _flagStartReaderEntrance = true;
static int _flagStartReaderExit = true;
static int _retThreadFireAlarm = -1;
static int _typeConvLeds = USB;
static int _typeConvAnt = USB;
static int _bltstreamFileOpMode = NO_BLTSTREAM_FILE;
static int _typeReader[NUM_READERS] = {PERIF_DG450, PERIF_DG450};
static int _userIdEntrance = -1;
static int _userIdExit = -1;
static int _groupIdEntrance = -1;
static int _groupIdExit = -1;
static int _contFrames = 0;
static int16_t _tempLed = 0;
static int16_t _tempMain = 0;

static unsigned long int _checkTotalSpaceHd = 0u;
static unsigned long int _checkSpaceHd = 0;
static unsigned long int _checkSpaceRam = 0;
static unsigned long int _checkTotalRam = 0;
static unsigned long int _errorTime = 0;
static unsigned long int _errorLimit = 1000000000u * 0.10;

static float _avgPictureQuality = 0.0f;

static double _spR = 0.0;
static double _spG = 0.0;
static double _spB = 0.0;
static double _fpsAverage = 0.0;

static std::string _strSP;
static std::string _validationStringEntrance = "";
static std::string _validationStringExit = "";

static pthread_t _threadCheckValidation = 0;
static pthread_t _threadTestFireAlarm;
static pthread_t _threadSaveOpenCVFrames;

static pthread_mutex_t _validationMutex;
static pthread_mutex_t _saveOpenCVFramesMutex;

static ReadersPerson _person;
static MCASendEvent _personSP;

static OperationalState _toggleStateOp = OP_STATE_CONTROLED;
static OperationalState _lastToggleStateOp = _toggleStateOp;

static ValidationInterface _validationInterfaceIdEntrance = VALIDATION_INTERFACE_NULL;
static ValidationInterface _validationInterfaceIdExit = VALIDATION_INTERFACE_NULL;

static StateAnimation _saveAnimatioState = STATEANIMATION_IDLE;
static snmpModuleArgs snmpArgs;

static SerialNumber *_serialNumber = nullptr;
static SGMIdentifier *_sgmIdentifier = nullptr;
static Sita *_sita = nullptr;
static dflow::Readers *_readers = nullptr;

/* clang-format off */
static const struct option long_options[] = {{"version", no_argument, nullptr, 1},
                                             {"drif", required_argument, nullptr, 2},
                                             {"bf", required_argument, nullptr, 3},
                                             {"test_f", required_argument, nullptr, 4},
                                             {"iff", required_argument, nullptr, 5},
                                             {"eff", required_argument, nullptr, 6},
                                             {"f", required_argument, nullptr, 9},
                                             {"ipf", required_argument, nullptr, 10},
                                             {"rf", required_argument, nullptr, 11},
                                             {"dr", optional_argument, nullptr, 12},
                                             {"dm", optional_argument, nullptr, 13},
                                             {"test_w", optional_argument, nullptr, 14},
                                             {"test_r", optional_argument, nullptr, 15},
                                             {"pr", required_argument, nullptr, 16},
                                             {"st", required_argument, nullptr, 17},
                                             {"sf", required_argument, nullptr, 18},
                                             {"sb", required_argument, nullptr, 19},
                                             {"sla", required_argument, nullptr, 20},
                                             {"slb", required_argument, nullptr, 21},
                                             {"sl2", required_argument, nullptr, 22},
                                             {"mw", optional_argument, nullptr, 23},
                                             {"r", required_argument, nullptr, 25},
                                             {"i", optional_argument, nullptr, 26},
                                             {"l", optional_argument, nullptr, 27},
                                             {"af", optional_argument, nullptr, 29},
                                             {"tm", optional_argument, nullptr, 30},
                                             {"sw", optional_argument, nullptr, 31},
                                             {"sd", optional_argument, nullptr, 32},
                                             {"ncd", optional_argument, nullptr, 35},
                                             {"nd", required_argument, nullptr, 36},
                                             {"T", required_argument, nullptr, 38},
                                             {"d", required_argument, nullptr, 39},
                                             {"framerate", required_argument, nullptr, 40},
                                             {"daz", optional_argument, nullptr, 41},
                                             {"cc", optional_argument, nullptr, 42},
                                             {"h", no_argument, nullptr, 43},
                                             {"dlf", no_argument, nullptr, 44},
                                             {"dbr", required_argument, nullptr, 45},
                                             {nullptr, 0, nullptr, 0}};
/* clang-format on */

static queue<cv::Mat> _frameStructFifo;

using namespace dflow;
using namespace cv;
using namespace std;

static void initMainMutexes() {
  pthread_mutex_init(&_validationMutex, nullptr);
  pthread_mutex_init(&_saveOpenCVFramesMutex, nullptr);
  initMutexes();
}

static void ToggleStateOp() {
  LOG_F(INFO, "Change operational state");
  pthread_mutex_lock(&_validationMutex);
  OperationalState tmpflagToggleStateOp = _toggleStateOp;
  pthread_mutex_unlock(&_validationMutex);
  int tmpEstadoEntrada = actionModule_getStateIn();
  int tmpEstadoSaida = actionModule_getStateOut();
  if ((tmpflagToggleStateOp != OP_STATE_COLLECT_CARD_URN) && (tmpflagToggleStateOp != OP_STATE_ALL_FREE)) {
    if (((tmpEstadoEntrada != OP_STATE_FREE) || (tmpEstadoSaida != OP_STATE_FREE)) &&
        (tmpflagToggleStateOp == OP_STATE_CONTROLED)) {
      actionModule_setState(OP_STATE_FREE, OP_STATE_FREE);
      pthread_mutex_lock(&_validationMutex);
      _toggleStateOp = OP_STATE_FREE;
      pthread_mutex_unlock(&_validationMutex);
    } else if (((tmpEstadoEntrada != OP_STATE_CLOSED) || (tmpEstadoSaida != OP_STATE_CLOSED)) &&
               (tmpflagToggleStateOp == OP_STATE_FREE)) {
      actionModule_setState(OP_STATE_CLOSED, OP_STATE_CLOSED);
      pthread_mutex_lock(&_validationMutex);
      _toggleStateOp = OP_STATE_CLOSED;
      pthread_mutex_unlock(&_validationMutex);
    } else  // if(g_toggleStateOp == OP_STATE_CLOSED)
    {
      actionModule_setState(OP_STATE_CONTROLED, OP_STATE_CLOSED);
      pthread_mutex_lock(&_validationMutex);
      _toggleStateOp = OP_STATE_CONTROLED;
      pthread_mutex_unlock(&_validationMutex);
    }
  }
}

static void StateOpAllFree() {
  LOG_F(INFO, "stateOpAllFree");
  pthread_mutex_lock(&_validationMutex);
  OperationalState tmpflagToggleStateOp = _toggleStateOp;
  pthread_mutex_unlock(&_validationMutex);
  if (tmpflagToggleStateOp != OP_STATE_COLLECT_CARD_URN) {
    if (tmpflagToggleStateOp != OP_STATE_ALL_FREE) {
      pthread_mutex_lock(&_validationMutex);
      _lastToggleStateOp = _toggleStateOp;
      _toggleStateOp = OP_STATE_ALL_FREE;
      pthread_mutex_unlock(&_validationMutex);
      // Save the state to paste in the future
      actionModule_saveState();

      if (ActionManager::GetInstance()->IsFireAlarmEnabled()) {
        actionModule_setState(OP_STATE_ALL_FREE, OP_STATE_ALL_FREE);
      }
      VideoAnalyzer_ClearListPersons();
    } else {
      pthread_mutex_lock(&_validationMutex);
      _toggleStateOp = _lastToggleStateOp;
      pthread_mutex_unlock(&_validationMutex);
      actionModule_pasteState();
      IndicLum_StartIdle(actionModule_getStateIn(), actionModule_getStateOut(), 30, actionModule_getUsingArinc());
    }
  }
}

static void CollectCardsUrn() {
  LOG_F(INFO, "Collection of cards in the urn");
  pthread_mutex_lock(&_validationMutex);
  OperationalState tmpflagToggleStateOp = _toggleStateOp;
  pthread_mutex_unlock(&_validationMutex);
  if (tmpflagToggleStateOp != OP_STATE_ALL_FREE) {
    IndicLum_ClearMemDoor();
    if (tmpflagToggleStateOp != OP_STATE_COLLECT_CARD_URN) {
      LOG_F(INFO, "Start collection");
      ActionManager::GetInstance()->SetCollectCard(true);
      pthread_mutex_lock(&_validationMutex);
      _lastToggleStateOp = _toggleStateOp;
      _toggleStateOp = OP_STATE_COLLECT_CARD_URN;
      pthread_mutex_unlock(&_validationMutex);
      actionModule_saveState();
      actionModule_setState(OP_STATE_CLOSED, OP_STATE_CLOSED);
      VideoAnalyzer_ClearListPersons();
      VideoAnalyzer_KillAllUserValidation(ACTIONS_CANCELLED, ACTIONS_CANCELLED);
      // videoAnalyzer_removeAllValidations(newPersonList);
      IndicLum_AddMemCommandDoor(2, DOOR_CLOSED_CENTRALIZED, 50);
      IndicLum_AddMemCommandDoor(3, DOOR_OPEN_ENTRANCE, 50);
    } else {
      LOG_F(INFO, "End of collection");
      ActionManager::GetInstance()->SetCollectCard(false);
      pthread_mutex_lock(&_validationMutex);
      _toggleStateOp = _lastToggleStateOp;
      pthread_mutex_unlock(&_validationMutex);
      // force to change the state
      actionModule_pasteState();
      if ((actionModule_xmlGetOpModeDoor() != DOOR_MODE_CENTRALIZED_CLOSED) &&
          (actionModule_xmlGetOpModeDoor() != DOOR_MODE_DECENTRALIZED_CLOSED) &&
          (actionModule_getOpModeDoor() != DOOR_MODE_ALW_CLOSED)) {
        IndicLum_AddMemCommandDoor(2, DOOR_OPEN_ENTRANCE, 50);
        IndicLum_AddMemCommandDoor(3, DOOR_OPEN_ENTRANCE, 50);
      }
    }
    IndicLum_SendMessageDoorMem(MESSAGE_DELIVERY_GUARANTEE);
  }
}

static void AddNewService(int groupId) {
  LOG_IF_F(1, STDERR_DEBUG, "Service group Id: %d", groupId);
  switch (groupId) {
    case 0:
      ToggleStateOp();
      break;
    case 1:
      StateOpAllFree();
      break;
    case 2:
      CollectCardsUrn();
      break;
    default:
      break;
  }
}

static void AddNewValidation(bool flagValidationEntrance, int validationIdEntrance, int validationGroupEntrance,
                             ValidationInterface validationInterfaceEntrance, const char *validationStrEntrance,
                             bool flagValidationExit, int validationIdExit, int validationGroupExit,
                             ValidationInterface validationInterfaceExit, const char *validationStrExit) {
  pthread_mutex_lock(&_validationMutex);
  OperationalState tmpflagToggleStateOp = _toggleStateOp;
  int tmpEstadoEntrada = actionModule_getStateIn();
  int tmpEstadoSaida = actionModule_getStateOut();
  if ((tmpflagToggleStateOp != OP_STATE_ALL_FREE) && (tmpflagToggleStateOp != OP_STATE_COLLECT_CARD_URN) &&
      (tmpflagToggleStateOp != OP_STATE_FIRE_ALARM)) {
    if ((flagValidationEntrance) && (_flagStartReaderEntrance) && (_userIdEntrance == -1) &&
        (tmpEstadoEntrada == OP_STATE_CONTROLED)) {
      _userIdEntrance = validationIdEntrance;
      _groupIdEntrance = validationGroupEntrance;
      _validationInterfaceIdEntrance = validationInterfaceEntrance;
      if (validationStrEntrance)
        _validationStringEntrance = validationStrEntrance;
      else
        _validationStringEntrance = " ";
      LOG_IF_F(1, STDERR_DEBUG, "Validation in | User ID: %d | Group: %d", _userIdEntrance, _groupIdEntrance);
      _flagStartReaderEntrance = false;
      // Event_Lcd(VALIDATION_OK);
    }
    if ((flagValidationExit) && (_flagStartReaderExit) && (_userIdExit == -1) &&
        (tmpEstadoSaida == OP_STATE_CONTROLED)) {
      _userIdExit = validationIdExit;
      _groupIdExit = validationGroupExit;
      _validationInterfaceIdExit = validationInterfaceExit;
      if (validationStrExit)
        _validationStringExit = validationStrExit;
      else
        _validationStringExit = " ";
      LOG_IF_F(1, STDERR_DEBUG, "Validation out | User ID: %d | Group: %d", _userIdExit, _groupIdExit);
      _flagStartReaderExit = false;
      // event_lcd(EV_OK);
    }
  }
  pthread_mutex_unlock(&_validationMutex);
}

static bool ValidationEntranceFaceDetection(int *validationIdEntrance, int *groupIdEntrance) {
  double score;
  if (FaceMatch_ValidationEntranceAvailable(validationIdEntrance, groupIdEntrance, &score)) {
    LOG_F(INFO, "New validation, user %d, group %d, score %2.3f", *validationIdEntrance, *groupIdEntrance, score);
    return true;
  }
  return false;
}

static bool ValidationExitFaceDetection(int *validationIdExit, int *groupIdExit) {
  double score;
  if (FaceMatch_ValidationExitAvailable(validationIdExit, groupIdExit, &score)) {
    LOG_F(INFO, "New validation, user %d, group %d, score %2.3f", *validationIdExit, *groupIdExit, score);
    return true;
  }
  return false;
}

static bool ValidationEntranceBarcodeHoneywell(void) {
  BarcodeState retTipoCartao = BARCODE_NONE;

  if (!HoneywellReader_GetValidation(&retTipoCartao)) {
    return false;
  }

  switch (retTipoCartao) {
    case BARCODE_M_VALIDO:                // CARTAO_M_VALIDO
    case BARCODE_1D_VALIDO:               // CARTAO_1D_VALIDO
    case BARCODE_FISICO_VALIDO:           // CARTAO_FISICO_VALIDO
    case BARCODE_SELO_ELETRONICO_VALIDO:  // BARCODE_SELO_ELETRONICO_VALIDO
    {
      if (count_travel_inspection == actionModule_xmlGetAmountInspection()) {
        LOG_F(INFO, "********************** Performs special inspection event **************************");
      }
      Event_Lcd(EVENT_TYPE_VALIDATION_OK);
    } break;

    case BARCODE_INVALIDO:  // CARTAO_INVALIDO
    {
      LOG_F(ERROR, "BARCODE_SELO_ELETRONICO_VALIDO");
      Event_SetPocValidationNotOkType(INVALID_CARD);
      ActionModule_TriggersSoundAndDisplay(false, VALIDATION_WAY_IN_OUT);
    } break;

    case BARCODE_DATA_INVALIDA:  // ERRO_CARTAO_DATA_INVALIDA
    {
      Event_SetPocValidationNotOkType(INVALID_DATE_CARD);
      ActionModule_TriggersSoundAndDisplay(false, VALIDATION_WAY_IN_OUT);
    } break;

    case BARCODE_EXPIRADO:  // ERRO_CARTAO_EXPIRADO
    {
      Event_SetPocValidationNotOkType(CARD_EXPIRED);
      ActionModule_TriggersSoundAndDisplay(false, VALIDATION_WAY_IN_OUT);
    } break;

    case BARCODE_REUTILIZADO:  // BARCODE_REUTILIZADO
    {
      Event_SetPocValidationNotOkType(INVALID_CARD_REUSED);
      ActionModule_TriggersSoundAndDisplay(false, VALIDATION_WAY_IN_OUT);
    } break;

    case BARCODE_AEROPORTO_INVALIDO:  // ERRO_AEROPORTO_INVALIDO
    {
      Event_SetPocValidationNotOkType(INVALID_AIRPORT);
      ActionModule_TriggersSoundAndDisplay(false, VALIDATION_WAY_IN_OUT);
    } break;

    case BARCODE_AGUARDE_PASSAGEM_OCUPADA:  //
    {
      Event_SetPocValidationNotOkType(GATE_BUSY);
      ActionModule_TriggersSoundAndDisplay(false, VALIDATION_WAY_IN_OUT);
    } break;

    default: { LOG_IF_F(1, STDERR_DEBUG, "resposta recebida = %d", retTipoCartao); } break;
  }

  if ((retTipoCartao == BARCODE_1D_VALIDO) || (retTipoCartao == BARCODE_FISICO_VALIDO) ||
      (retTipoCartao == BARCODE_M_VALIDO) || (retTipoCartao == BARCODE_SELO_ELETRONICO_VALIDO)) {
    return true;
  }

  return false;
}

static void *ValidationCheck(void *tmpPtr) {
  (void)tmpPtr;
  std::string nameThread = "ValidationCheck";
  pthread_setname_np(pthread_self(), nameThread.c_str());
  loguru::set_thread_name(nameThread.c_str());
  LOG_F(INFO, "Start thread %s", nameThread.c_str());

  TimeoutCpp keepAliveHoneywell;
  keepAliveHoneywell.Start(5000);
  uint8_t validationIdCounter = 0;

  HoneywellReader_SetStatus(STAT_COMM_TX);
  _isValidationCheckRunning = true;

  while (_isValidationCheckRunning) {
    int typeCategory = CATEGORY_INEXISTENT;
    int numberIdEntrance = 0;
    int numberIdExit = 0;
    int numberGroupEntrance = 0;
    int numberGroupExit = 0;

    if (IndicLum_ValidationEntranceControlBoard(&numberIdEntrance, &numberGroupEntrance)) {
      do {
        numberIdEntrance = ++validationIdCounter == 0 ? ++validationIdCounter : validationIdCounter;
        usleep(1);
      } while (!numberIdEntrance);
      LOG_F(INFO, "Validation entrance control board: ID=%d Group=%d", numberIdEntrance, numberGroupEntrance);
      if (numberIdEntrance > 0) {
        if (_readers->SendValidationIO(0, numberIdEntrance, numberGroupEntrance)) {
          LOG_F(INFO, "Write sendMCAControllerValidation OK");
        } else {
          LOG_F(ERROR, "Write sendMCAControllerValidation ERROR");
        }
      } else
        LOG_F(ERROR, "Does not add validation with id 0");
    }

    static bool statusFireAlarm = false;
    if (ActionManager::GetInstance()->IsFireAlarmEnabled()) {
      if (!statusFireAlarm) {
        statusFireAlarm = true;
        LOG_F(WARNING, "Fire alarm enabled");
        VideoAnalyzer_ClearsInfoWhenIsEnableFireAlarm();

        if (actionModule_getUsingSita() || actionModule_xmlGetScafisDflowPort()) {
          _DeviceStatus_Set(EB_HARDWARE_EMERGENCY_BUTTON_STATUS, EB_DEACTIVATED_FOR_EMERGENCY);
          if (VideoAnalyzer_IsValidPersonInsideInToOut()) {
            LOG_IF_F(1, STDERR_DEBUG, "Send: EBQB");
            EventControlSita_Set(EBQB);
          }
        } else {
          Event_Lcd(EVENT_TYPE_FIRE_ALARM);
        }

        pthread_mutex_lock(&_validationMutex);
        OperationalState tmpflagToggleStateOp = _toggleStateOp;
        if (actionModule_getVersionControlBoard() >= CONTROL_BOARD_VERSION_1_14) {
          _lastToggleStateOp = _toggleStateOp;
          _toggleStateOp = OP_STATE_FIRE_ALARM;
        }
        pthread_mutex_unlock(&_validationMutex);

        if (actionModule_getVersionControlBoard() < CONTROL_BOARD_VERSION_1_14) {
          IndicLum_SetBuzzer(300, 0, 0, MESSAGE_DELIVERY_GUARANTEE);
          if (tmpflagToggleStateOp != OP_STATE_ALL_FREE) {
            StateOpAllFree();
          } else {
            remoteConfig_set_EstadoAnimacao(STATEANIMATION_IDLE);
          }
        }

        _readers->SendEmergencyForAllUsersMCASP();
        _readers->RemoveAllPersons();
      }
    } else {
      if (statusFireAlarm) {
        statusFireAlarm = false;
        LOG_F(WARNING, "Fire alarm disabled");
        if (actionModule_getUsingSita() || actionModule_xmlGetScafisDflowPort()) {
          _DeviceStatus_Set(EB_HARDWARE_EMERGENCY_BUTTON_STATUS, EB_ONLINE);
        } else {
          Event_Lcd(EVENT_TYPE_IDLE);
        }
        pthread_mutex_lock(&_validationMutex);
        OperationalState tmpflagToggleStateOp = _toggleStateOp;
        if (actionModule_getVersionControlBoard() >= CONTROL_BOARD_VERSION_1_14) _toggleStateOp = _lastToggleStateOp;
        pthread_mutex_unlock(&_validationMutex);

        if (actionModule_getVersionControlBoard() < CONTROL_BOARD_VERSION_1_14) {
          IndicLum_SetBuzzer(300, 200, 3, MESSAGE_DELIVERY_GUARANTEE);
          if (tmpflagToggleStateOp == OP_STATE_ALL_FREE) StateOpAllFree();
        }
      }
    }
    if (IndicLum_ValidationExitControlBoard(&numberIdExit, &numberGroupExit)) {
      do {
        numberIdExit = ++validationIdCounter == 0 ? ++validationIdCounter : validationIdCounter;
        usleep(1);
      } while (!numberIdExit);
      LOG_F(INFO, "Validation exit control board: ID=%d Group=%d", numberIdExit, numberGroupExit);
      if (numberIdExit > 0) {
        if (_readers->SendValidationIO(1, numberIdExit, numberGroupExit)) {
          LOG_F(INFO, "Write sendMCAControllerValidation OK");
        } else {
          LOG_F(ERROR, "Write sendMCAControllerValidation ERROR");
        }
      } else
        LOG_F(ERROR, "Does not add validation with id 0");
    }

    if (NewValidation_GetEntranceReader(&typeCategory, &numberIdEntrance, &numberGroupEntrance)) {
      NewValidation_SaveLastCardRead(READER_ENTRANCE);
      if (typeCategory == CATEGORY_SERVICES) {
        AddNewService(numberGroupEntrance);
      } else if ((typeCategory == CATEGORY_USER) || (_flagAnyCardValidation)) {
        LOG_F(INFO, "Validation entrance reader: ID=%d Group=%d", numberIdEntrance, numberGroupEntrance);
        if (numberIdEntrance > 0) {
          actionModule_eventCardEntrace();
          AddNewValidation(true, numberIdEntrance, numberGroupEntrance, VALIDATION_INTERFACE_CARD, "CardReader", false,
                           0, 0, VALIDATION_INTERFACE_NULL, nullptr);
        } else
          LOG_F(ERROR, "Does not add validation with id 0");
      }
    }
    if (NewValidation_GetExitReader(&typeCategory, &numberIdExit, &numberGroupExit)) {
      NewValidation_SaveLastCardRead(READER_EXIT);
      if (typeCategory == CATEGORY_SERVICES) {
        AddNewService(numberGroupExit);
      } else if ((typeCategory == CATEGORY_USER) || (_flagAnyCardValidation)) {
        LOG_F(INFO, "Validation exit reader: ID=%d Group=%d", numberIdExit, numberGroupExit);
        if (numberIdExit > 0) {
          actionModule_eventCardExit();
          AddNewValidation(false, 0, 0, VALIDATION_INTERFACE_NULL, nullptr, true, numberIdExit, numberGroupExit,
                           VALIDATION_INTERFACE_CARD, "CardReader");
        } else
          LOG_F(ERROR, "Does not add validation with id 0");
      }
    }

    if (ValidationEntranceFaceDetection(&numberIdEntrance, &numberGroupEntrance)) {
      LOG_F(INFO, "Validation entrance face detection: ID=%d Group=%d", numberIdEntrance, numberGroupEntrance);
      if (actionModule_getTestMorphoWave()) {
        int tmpGroupIdEntrance = numberIdEntrance % 10;
        switch (tmpGroupIdEntrance) {
          case 1:
          case 2:
          case 3: {
            numberGroupEntrance = 0;
            break;
          }
          case 4:
          case 5:
          case 6:
          case 7: {
            numberGroupEntrance = 1;
            break;
          }
          default: {
            numberGroupEntrance = 2;
            break;
          }
        }
        LOG_F(INFO, "Validation entrance modification: ID=%d Group=%d", numberIdEntrance, numberGroupEntrance);
      }
      if (numberIdEntrance > 0)
        AddNewValidation(true, numberIdEntrance, numberGroupEntrance, VALIDATION_INTERFACE_HTTP, "FaceDetection", false,
                         0, 0, VALIDATION_INTERFACE_NULL, nullptr);
      else
        LOG_F(ERROR, "Does not add validation with id 0");
    }
    if (ValidationExitFaceDetection(&numberIdExit, &numberGroupExit)) {
      LOG_F(INFO, "Validation exit face detection: ID=%d Group=%d", numberIdExit, numberGroupExit);
      if (actionModule_getTestMorphoWave()) {
        int tmpGroupIdExit = numberIdExit % 10;
        switch (tmpGroupIdExit) {
          case 1:
          case 2:
          case 3: {
            numberGroupExit = 0;
            break;
          }
          case 4:
          case 5:
          case 6:
          case 7: {
            numberGroupExit = 1;
            break;
          }
          default: {
            numberGroupExit = 2;
            break;
          }
        }
        LOG_F(INFO, "Validation exit modification: ID=%d Group=%d", numberIdExit, numberGroupExit);
      }
      if (numberIdExit > 0)
        AddNewValidation(false, 0, 0, VALIDATION_INTERFACE_NULL, nullptr, true, numberIdExit, numberGroupExit,
                         VALIDATION_INTERFACE_HTTP, "FaceDetection");
      else
        LOG_F(ERROR, "Does not add validation with id 0");
    }

    if (remoteConfig_getValidEntrance() || Configurator::GetInstance()->IsEntranceValidation()) {
      do {
        numberIdEntrance = ++validationIdCounter == 0 ? ++validationIdCounter : validationIdCounter;
        usleep(1);
      } while (!numberIdEntrance);
      LOG_F(INFO, "Validation entrance remote control: ID=%d Group=%d", numberIdEntrance, numberGroupEntrance);
      if (numberIdEntrance > 0)
        AddNewValidation(true, numberIdEntrance, numberGroupEntrance, VALIDATION_INTERFACE_REMOTE_CONFIG,
                         "RemoteConfig", false, 0, 0, VALIDATION_INTERFACE_NULL, nullptr);
      else
        LOG_F(ERROR, "Does not add validation with id 0");
    }
    if (remoteConfig_getValidExit() || Configurator::GetInstance()->IsExitValidation()) {
      do {
        numberIdExit = ++validationIdCounter == 0 ? ++validationIdCounter : validationIdCounter;
        usleep(1);
      } while (!numberIdExit);
      LOG_F(INFO, "Validation exit remote control: ID=%d Group=%d", numberIdExit, numberGroupExit);
      if (numberIdExit > 0)
        AddNewValidation(false, 0, 0, VALIDATION_INTERFACE_NULL, nullptr, true, numberIdExit, numberGroupExit,
                         VALIDATION_INTERFACE_REMOTE_CONFIG, "RemoteConfig");
      else
        LOG_F(ERROR, "Does not add validation with id 0");
    }

    if (ValidationEntranceBarcodeHoneywell()) {
      LOG_F(INFO, "Validation entrance barcode Honeywell.");
      std::string barcodeRead = HoneywellReader_GetCurrentBarcode();
      actionModule_eventBarcodeEntrance();
      LOG_F(INFO, "********* BarCode: %s ************", barcodeRead.c_str());

      do {
        numberIdEntrance = ++validationIdCounter == 0 ? ++validationIdCounter : validationIdCounter;
        usleep(1);
      } while (!numberIdEntrance);

      if (actionModule_getUsingSita() || actionModule_getUsingArinc()) {
        if (actionModule_getUsingArinc()) actionModule_disableBarcodeReader();
        actionModule_SetBarcodeRead(barcodeRead);
      } else if (_acceptAnyTicket || actionModule_xmlGetFlagPocAeroporto()) {
        int validationGroup = 0;
        if (actionModule_xmlGetFlagPocAeroporto() && count_travel_inspection == actionModule_xmlGetAmountInspection()) {
          validationGroup = actionModule_xmlGetLedsColorSpecialInspection();
        }
        AddNewValidation(true, numberIdEntrance, validationGroup, VALIDATION_INTERFACE_BARCODE, barcodeRead.c_str(),
                         false, 0, 0, VALIDATION_INTERFACE_NULL, nullptr);
      }
    }

    if (!keepAliveHoneywell.IsStarted() || keepAliveHoneywell.Check()) {
      keepAliveHoneywell.Start(5000);
      if (_readers->IsBarcodeConnected()) {
        if (actionModule_xmlGetOpModeDoor() != DOOR_MODE_DVIATOR_Y) {
          Lcd_StatusConcat("*", POS_STATUS_2D);
        }
      } else {
        HoneywellReaderStatus status = HoneywellReader_GetStatus();
        std::string tmpChar = "*";
        if (actionModule_xmlGetOpModeDoor() != DOOR_MODE_DVIATOR_Y) {
          if (status == STAT_COMM_TX) tmpChar = "-";
          Lcd_StatusConcat(tmpChar.c_str(), POS_STATUS_2D);
        }
        HoneywellReader_SetStatus(STAT_COMM_TX);
        HoneywellReader_SendCommand("cbrena^.");  // verify current setting
      }
    }
    usleep(5000);
  }

  LOG_F(INFO, "End of thread %s", __FUNCTION__);
  return (nullptr);
}

static bool GetNewValidationEntrance(int &personId, int &personGroup, ValidationInterface &validationInterface,
                                     std::string &validationString) {
  bool newValid = false;
  pthread_mutex_lock(&_validationMutex);
  if (_userIdEntrance > 0) {
    personId = _userIdEntrance;
    personGroup = _groupIdEntrance;
    validationInterface = _validationInterfaceIdEntrance;
    validationString = _validationStringEntrance;
    _userIdEntrance = -1;
    newValid = true;
  }
  pthread_mutex_unlock(&_validationMutex);

  return newValid;
}

static bool GetNewValidationExit(int &personId, int &personGroup, ValidationInterface &validationInterface,
                                 std::string &validationString) {
  bool newValid = false;
  pthread_mutex_lock(&_validationMutex);
  if (_userIdExit > 0) {
    personId = _userIdExit;
    personGroup = _groupIdExit;
    validationInterface = _validationInterfaceIdExit;
    validationString = _validationStringExit;
    _userIdExit = -1;
    newValid = true;
  }
  pthread_mutex_unlock(&_validationMutex);

  return newValid;
}

static void ReaderStartReadingEntrance(void) {
  pthread_mutex_lock(&_validationMutex);
  int tmpUser = _userIdEntrance;
  pthread_mutex_unlock(&_validationMutex);

  if (tmpUser == -1) {
    pthread_mutex_lock(&_validationMutex);
    _flagStartReaderEntrance = true;
    pthread_mutex_unlock(&_validationMutex);
  }
}

static void ReaderStartReadingExit(void) {
  pthread_mutex_lock(&_validationMutex);
  int tmpUser = _userIdExit;
  pthread_mutex_unlock(&_validationMutex);

  if (tmpUser == -1) {
    pthread_mutex_lock(&_validationMutex);
    _flagStartReaderExit = true;
    pthread_mutex_unlock(&_validationMutex);
  }
}

static bool VerificaMemoriaRamLivre(unsigned long *avaliable, unsigned long *total) {
  if (avaliable && total) {
    struct sysinfo memInfo;
    sysinfo(&memInfo);
    *avaliable = memInfo.freeram * memInfo.mem_unit / 1024;
    *total = memInfo.totalram * memInfo.mem_unit / 1024;
    InfoLog_SetRAMMemory(*total, *avaliable);
    return true;
  }
  return false;
}

static unsigned long int VerificaMemoriaTotal(const char *saveFilesPath) {
  struct statfs stflash;
  unsigned long int tam;

  if (statfs(saveFilesPath, &stflash) < 0) {
    LOG_F(ERROR, "Error reading flash status!");
    tam = 0;
  } else {
    // total
    tam = (stflash.f_blocks * stflash.f_frsize / 1024) / 1024;
    // disponível
    // stflash.f_bavail * stflash.f_frsize / 1024;
  }
  return tam;
}

static unsigned long int VerificaMemoriaLivre(const char *saveFilesPath) {
  struct statfs stflash;
  unsigned long int tam;

  if (statfs(saveFilesPath, &stflash) < 0) {
    LOG_F(ERROR, "Error reading flash status!");
    tam = 0;
  } else {
    InfoLog_SetHDMemory(stflash.f_blocks * stflash.f_frsize / 1024, stflash.f_bavail * stflash.f_frsize / 1024);

    tam = (stflash.f_bavail * stflash.f_frsize / 1024) / 1024;
  }

  return tam;
}

static uint16_t CalculatesMinimumAreaAtTheEnds(uint16_t heightValue, uint16_t sensorHeight, uint16_t minHeightValue,
                                               uint16_t maxHeightValue, int minAreaLowestHeight,
                                               int minAreaHighestHeight) {
  // Calcula o raio da area na altura maxima
  float radiusAreaHighestHeight = sqrt((float)((float)minAreaHighestHeight / M_PI));
  // Calcula o raio da area na altura minima
  float radiusAreaLowestHeight = sqrt((float)((float)minAreaLowestHeight / M_PI));
  // Calcula o coeficiente angular
  float coefficientLine = ((float)((sensorHeight - maxHeightValue) - (sensorHeight - minHeightValue)) /
                           (radiusAreaHighestHeight - radiusAreaLowestHeight));
  // Calcula a resultante
  float resulting_01 = (coefficientLine * (radiusAreaLowestHeight * (-1)));
  // Calcula o raio para a altura correspondente
  float radiusAreaHeight =
      ((resulting_01 + (float)(sensorHeight - minHeightValue)) - heightValue) / (coefficientLine * (-1));
  // Converte o raio em area
  uint16_t minArea = (radiusAreaHeight > 0) ? round(M_PI * pow(radiusAreaHeight, 2)) : 0;
  LOG_IF_F(1, STDERR_DEBUG, "Minimum area %u, for height of %u mm, with sensor at %u mm.", minArea,
           sensorHeight - heightValue, sensorHeight);
  if (radiusAreaHeight <= 0) {
    LOG_F(ERROR, "Minimum area for height of %u mm - OUT OF RANGE", sensorHeight - heightValue);
  }

  return minArea;
}

static void KillThreadTestFireAlarm(void) {
  if (_retThreadFireAlarm == 0) {
    _isTestFireAlarmRunning = false;
    _retThreadFireAlarm = -1;
  }
}

static void *TestFireAlarm(void *tmpPtr) {
  (void)tmpPtr;
  std::string nameThread = "TestFireAlarm";
  pthread_setname_np(pthread_self(), nameThread.c_str());
  loguru::set_thread_name(nameThread.c_str());
  LOG_F(INFO, "Start thread %s", nameThread.c_str());

  int tmpValidation = 0;
  int tmpGroup = 0;

  while (_isTestFireAlarmRunning) {
    if (IndicLum_StatusIoReady()) {
      IndicLum_ChangeMiddleIdle(true, MESSAGE_PRIORITY);
      IndicLum_ValidationEntranceControlBoard(&tmpValidation, &tmpGroup);
    }

    usleep(100000);
  }

  LOG_F(INFO, "End of thread %s", __FUNCTION__);
  return nullptr;
}

static void PrintHelp() {
  LOG_F(INFO,
        "\n Available commands:"
        "\n '0' - If(pause) startIdle"
        "\n '1' - If(pause) demo"
        "\n '2' - setBarcodeRead"
        "\n '3' - validationEntrance - DSOAP"
        "\n '4' - sendPrinterEvent - SOAP"
        "\n 'Space' - pause / step by step"
        "\n 'a' or 'A'- accelerationFrame"
        "\n 'b' or 'B' - saveBPM"
        "\n 'c' or 'C' - one frame calibration or full calibration"
        "\n 'd' or 'D' - "
        "\n 'e' or 'E' - statusDoors"
        "\n 'f' or 'F' - saveJPG"
        "\n 'g' or 'G' - forceFileGeneration"
        "\n 'h' or 'H' - printThisHelp"
        "\n 'i' or 'I' - showInfo"
        "\n 'j' or 'J' - resetControlBoard"
        "\n 'k' or 'K' - "
        "\n 'l' or 'L' - showLayers"
        "\n 'm' or 'M' - switchCPUmode"
        "\n 'n' or 'N' - virtualButton"
        "\n 'o' or 'O' - overwriteFileCalibration"
        "\n 'p' or 'P' - pause / play"
        "\n 'q' or 'Q' - QUIT"
        "\n 'r' or 'R' - clearCalibration"
        "\n 's' or 'S' - saveNewFileCalibration"
        "\n 't' or 'T' - "
        "\n 'u' or 'U' - virtualButtonUrn"
        "\n 'v' or 'V' - addValidation"
        "\n 'x' or 'X' - incrementTailgater"
        "\n 'z' or 'Z' - decrementTailgater"
        "\n ',' or '<' - pause / stepBack"
        "\n '+' - incrementConfidenceThresLow"
        "\n '-' - decrementConfidenceThresLow"
        "\n ''' - Instant capture of a frame to image file");
}

static void InfoSystem() {
  // system temperature using libsensors
  double systemTemperature = 0.0;
  double tempTemperature = actionModule_readCpuTemperature(systemTemperature);
  uint32_t percentAvailable = 0;
  if (_checkTotalSpaceHd > 0) percentAvailable = (_checkSpaceHd * 100) / _checkTotalSpaceHd;

  vector<ReaderMCASP *> MCASPServerList = MCASPServer::getMCASPList();
  uint32_t sizeListSPReceive = 0;
  uint32_t sizeListSPWait = 0;
  uint32_t sizeListSPMatch = 0;
  for (size_t counter = 0; counter < MCASPServerList.size(); counter++) {
    sizeListSPReceive += MCASPServerList[counter]->listSPReceive.size();
    sizeListSPWait += MCASPServerList[counter]->listSPWait.size();
    sizeListSPMatch += MCASPServerList[counter]->listSPMatch.size();
  }

  LOG_F(INFO,
        "FPS: %2.3f |"
        " Count: IN:%06d OUT:%06d |"
        " Picture Qual: %2.2f%% bad |"
        " TempSensor |"
        " Leds: %d C |"
        " Main: %d C |"
        " TempCPU: %.2f C |"
        " HD Free: %02d%% |"
        " Counters |"
        " Time Total: %06u |"
        " Time Partial: %06u |"
        " Cycles Entrance: %06u |"
        " Cycles Exit: %06u |"
        " Valid Entrance Today: %06lu |"
        " Invalid Entrance Today: %06lu |"
        " Valid Exit Today: %06lu |"
        " Invalid Exit Today: %06lu |"
        " Valid Entrance Total: %06lu |"
        " Invalid Entrance Total: %06lu |"
        " Valid Exit Total: %06lu |"
        " Invalid Exit Total: %06lu |"
        " Cycles |"
        " DOOR_06: %06u |"
        " DOOR_07: %06u |"
        " DOOR_08: %06u |"
        " DOOR_09: %06u |"
        " DOOR_10: %06u |"
        " DOOR_11: %06u |"
        " DOOR_12: %06u |"
        " DOOR_13: %06u |"
        " Size_MCASPListReceive: %02u |"
        " Size_MCASPListWait: %02u |"
        " Size_MCASPListMatch: %02u |"
        " Resets control board: %06u",
        _fpsAverage, _personCounterIn, _personCounterOut, _avgPictureQuality, _tempLed, _tempMain, tempTemperature,
        percentAvailable, infoCount_getTimeTotal(), infoCount_getTimePartial(), infoCount_getCyclesEntrance(),
        infoCount_getCyclesExit(), infoCount_getValidEntranceToday(), infoCount_getInvalidEntranceToday(),
        infoCount_getValidExitToday(), infoCount_getInvalidExitToday(), infoCount_getValidEntranceTotal(),
        infoCount_getInvalidEntranceTotal(), infoCount_getValidExitTotal(), infoCount_getInvalidExitTotal(),
        infoCount_getCyclesDoor(DOOR_06), infoCount_getCyclesDoor(DOOR_07), infoCount_getCyclesDoor(DOOR_08),
        infoCount_getCyclesDoor(DOOR_09), infoCount_getCyclesDoor(DOOR_10), infoCount_getCyclesDoor(DOOR_11),
        infoCount_getCyclesDoor(DOOR_12), infoCount_getCyclesDoor(DOOR_13), sizeListSPReceive, sizeListSPWait,
        sizeListSPMatch, IndicLum_ResetControlBoardCounter());

  LOG_F(INFO, "Entrance: %s", actionModule_OperationalStateToString(actionModule_getStateIn()).c_str());
  LOG_F(INFO, "Exit    : %s", actionModule_OperationalStateToString(actionModule_getStateOut()).c_str());

  for (size_t counter = 0; counter < MCASPServerList.size(); counter++) {
    uint32_t sizeListSPReceive = MCASPServerList[counter]->listSPReceive.size();
    uint32_t sizeListSPWait = MCASPServerList[counter]->listSPWait.size();
    uint32_t sizeListSPMatch = MCASPServerList[counter]->listSPMatch.size();

    if (sizeListSPReceive) {
      LOG_F(INFO, "ListSPReceive[ID: %d]", MCASPServerList[counter]->readerID);
      for (uint32_t counterList = 0; counterList < sizeListSPReceive; counterList++) {
        string strSP;
        if (MCAPersonCross_Char23ToStrHexa(MCASPServerList[counter]->listSPReceive.getPersonInPosition(counterList).str,
                                           &strSP)) {
          LOG_F(INFO, "Position %u -> %u: %s", counterList, sizeListSPReceive, strSP.c_str());
        } else {
          LOG_F(INFO, "Position %u -> %u: %s", counterList, sizeListSPReceive,
                MCASPServerList[counter]->listSPReceive.getPersonInPosition(counterList).str);
        }
      }
    }
    if (sizeListSPWait) {
      LOG_F(INFO, "ListSPWait[ID: %d]", MCASPServerList[counter]->readerID);
      for (uint32_t counterList = 0; counterList < sizeListSPWait; counterList++) {
        string strSP;
        if (MCAPersonCross_Char23ToStrHexa(MCASPServerList[counter]->listSPWait.getPersonInPosition(counterList).str,
                                           &strSP)) {
          LOG_F(INFO, "Position %u -> %u: %s", counterList, sizeListSPWait, strSP.c_str());
        } else {
          LOG_F(INFO, "Position %u -> %u: %s", counterList, sizeListSPWait,
                MCASPServerList[counter]->listSPWait.getPersonInPosition(counterList).str);
        }
      }
    }
    if (sizeListSPMatch) {
      LOG_F(INFO, "ListSPMatch[ID: %d]", MCASPServerList[counter]->readerID);
      for (uint32_t counterList = 0; counterList < sizeListSPMatch; counterList++) {
        string strSP;
        if (MCAPersonCross_Char23ToStrHexa(MCASPServerList[counter]->listSPMatch.getPersonInPosition(counterList).str,
                                           &strSP)) {
          LOG_F(INFO, "Position %u -> %u: %s", counterList, sizeListSPMatch, strSP.c_str());
        } else {
          LOG_F(INFO, "Position %u -> %u: %s", counterList, sizeListSPMatch,
                MCASPServerList[counter]->listSPMatch.getPersonInPosition(counterList).str);
        }
      }
    }
  }
}

static void KillApp() {
  isRunning = false;
  Lcd_SetStatusLockMsgDisp(true);  // Trava mensagens no disṕlay
  Event_Lcd(EVENT_TYPE_OUT_OF_OPERATION);
  usleep(250000);

  sem_post(&VisualCortex::GetInstance()->startframeFileSemaphore);
  sem_post(&VisualCortex::GetInstance()->frameFileSemaphore);

  ThreadStack::Destroy();

  VideoAnalyzerIP_CloseSocket();

  if (actionModule_getUsingSita()) {
    Sita::Destroy();
  }

  if (actionModule_xmlGetBrManiaEnable() && actionModule_xmlGetBrManiaBypassMode()) {
    DtowerBoard::Destroy();
  }
#ifdef ENABLE_SELF_CHECKOUT
  SelfCheckout::Destroy();
#endif

  SnmpModule::Destroy();
  VisualCortex::Destroy();
  ErrorIndicator::Destroy();
  BrMania::Destroy();
  MotorBoardSerialCommands::Destroy();
  DoorsManager::Destroy();
  DoorsFraudCheck::Destroy();
  OldFilesDeleter::Destroy();
  CredentialsBuffer::Destroy();
  MiscellaneousNetworkOperations::Destroy();
  TestHardware::Destroy();
  DebugFileManager::Destroy();
  ConverterBytes::Destroy();
  PeripheralDemonstration_Destroy();
  serverUpdate_disconnect();
  NewValidation_Finish();
  DoorStatus_DestroyTimers();
  soapDflow_finish();
  soapSensor_cleanObjects();
  soapSensor_finish();
  MCAPersonCross_MCASPFinish();
  Readers::Destroy();
  Dpass::Destroy();
  Bltstream::Destroy();
  SoapConfigurations::Destroy();
  SoapPictogramController::Destroy();
  SoapNotificationLightController::Destroy();
  SoapAlarmController::Destroy();
  NightMode::Destroy();
  Configurator::Destroy();
  LicenseVerifier::Destroy();
  actionModule_finish();
  DoorsLogManager::Destroy();
  AcknowledgeSignalManager::Destroy();
  ActionManager::Destroy();
  DiagnosticInterface::Destroy();
  ImageCalibration::Destroy();
  DoorStatusManager::Destroy();

  // Finalize Rest
  RestServer::Destroy();
  RestClient::Destroy();
  if (actionModule_xmlGetScafisDflowPort()) Scafis::Destroy();
#ifdef MUTEX_MODULE_ENABLED
  MutexModule::Destroy();
#endif

  if (!_textMode) {
    //    LOG_F(INFO, "Counter Entrance: %d | Counter Exit: %d", _personCounterIn, _personCounterOut);
  }

  LOG_F(WARNING, "Exiting application!!! Number of process: %d", getpid());
}

/////////////////////////////////////////////////////////////////////////////////////////
/**
 \brief Mostra as funcoes empilhadas na stack (frame stack) quando ocorrer um erro critico
 durante a execucao do aplicativo para que possa ser rastreada a rotina que causou a falha

 \param signo: Sinal vindo do Sistema Operacional;

 \author Matheus Barth Souza

 */  ///////////////////////////////////////////////////////////////////////////////////////

static void INThandler(int signo) {
  LOG_F(INFO, "Caught signal: %d \"%s\"", signo, strsignal(signo));

  if (signo == SIGUSR1) {
    InfoSystem();
    DoorStatus_InfoDoors();
    return;
  } else if (signo == SIGUSR2) {
    _forceSaveFrames = !_forceSaveFrames;
    LOG_F(INFO, "Force Save Frames: %s", _forceSaveFrames ? "true" : "false");
    return;
  }

  LOG_F(WARNING, "Caught signal: %d \"%s\"", signo, strsignal(signo));
  signal(signo, nullptr);

  void *stack[20];
  char **functions;
  int count, i;

  LOG_F(INFO, "=== Print Stack ===");
  count = backtrace(stack, 20);  // Numero de enderecos armazenados na stack
  // Nome das funcoes na stack
  functions = backtrace_symbols(stack, count);
  // Exibe chamadas das funcoes na stack para rastrear o problema
  // Ultimo stack frame eh a funcao libc, a qual chama a funcao main()
  for (i = 0; i < count; i++) {
    LOG_F(INFO, "Stack Frame %2d: %s", i, functions[i]);
  }

  free(functions);
  LOG_F(INFO, "=== End Stack ===");

  if (signo == SIGQUIT) {
    isRunning = false;
  } else {
    LOG_F(WARNING, "Caught signal: %d \"%s\" - Doesn't close application", signo, strsignal(signo));
  }
}

bool main_ChecksIfToCloseApp() {
  int c = -1;
  if (Util_Kbhit()) {
    c = Util_Getch();
    // filter the character to not CASE SENSITIVE
    if (c >= 'A' && c <= 'Z') {
      c += 'a' - 'A';
    }
    fflush(nullptr);
  }
  if (c >= 0) {
    LOG_F(INFO, "Pressionada tecla %c (%02X)", c, c);
    if (((char)c == 'q') || ((char)c == 'Q')) {
      return true;
    } else if (((char)c == 'w') || ((char)c == 'W')) {
      CleaningMode::GetInstance()->RunCleaning(false);
    }
  }
  if (remoteConfig_stopApp() || Configurator::GetInstance()->IsStopApp()) {
    return true;
  }

  return false;
}

static bool GetEstado(void) {
  return ((actionModule_getStateIn() == OP_STATE_CLOSED) && (actionModule_getStateOut() == OP_STATE_CLOSED)) ? true
                                                                                                             : false;
}

int main_FquestCanUpdate(int id) {
  if (!GetEstado()) return 0;

  static bool printMessage = false;
  if (ActionManager::GetInstance()->IsFireAlarmEnabled()) {
    LOG_IF_F(WARNING, (!printMessage), "Fire alarm activated, software update is not allowed");
    printMessage = true;
    return 0;
  } else {
    LOG_IF_F(WARNING, (printMessage), "Fire alarm deactivated, software update is allowed");
    printMessage = false;
  }

  LOG_IF_F(1, STDERR_DEBUG, "Solicitando se pode atualizar - %d", id);
  KillThreadTestFireAlarm();

  switch (id) {
    case EN_SCRIPTBEGIN:
      break;

    case EN_CPU:
      break;

    case EN_PL_CTRL: {
      LOG_IF_F(1, STDERR_DEBUG, "Update Firmware da Placa de Controle: fquestCanUpdate");
      if (actionModule_getStatusBootloaderControlBoard()) {
        LOG_IF_F(1, STDERR_DEBUG, "Placa de controle ja esta em modo bootloader: fquestCanUpdate");
        IndicLum_LockMessageSend();
        return 1;
      } else {
        if (IndicLum_SetToBootLoader(MESSAGE_PRIORITY)) {
          LOG_IF_F(1, STDERR_DEBUG,
                   "Adicionou mensagem de reset para placa de controle. "
                   "Vai aguardar que a mensagem seja enviada pela "
                   "thread de indicLum - ate 4 segundos: "
                   "fquestCanUpdate");
          uint8_t count = 0;
          while (!Indiclum_IsLockMessageSend()) {
            if (count > 4u) {
              LOG_IF_F(1, STDERR_DEBUG,
                       "Informando sistema de atualizacao que espirou "
                       "o tempo de envio da mensagem de reset da "
                       "placa de controle - 4 segundos: fquestCanUpdate");
              IndicLum_CancelBootLoader();
              return 0;
            }
            usleep(1000000);
            count++;
          }
          actionModule_setStatusBootloaderControlBoard(true);
          IndicLum_Disconnect();
          LOG_IF_F(1, STDERR_DEBUG, "Atribuindo true a variavel flagUpdating");
          _flagUpdating = true;
          return 1;
        } else {
          LOG_IF_F(1, STDERR_DEBUG,
                   "Informando o sistema de atualizacao que falhou em enviar "
                   "a mensagem de reste para a placa de controle: "
                   "fquestCanUpdate");
          IndicLum_UnlockMessageSend();
          return 0;
        }
      }
      break;
    }
    case EN_DOORS: {
      LOG_IF_F(1, STDERR_DEBUG, "Update Firmware da Placa do Motor: fquestCanUpdate");
      IndicLum_LockSyncLeds();
      IndicLum_LockMessageAdd();
      IndicLum_LockMessageSendDoors();
      return 1;
    }
    case EN_SCRIPTEND:
      break;
  }

  return 1;
}

int main_FsetStateUpdate(int idFile, int status) {
  LOG_IF_F(1, STDERR_DEBUG, "Solicitando se pode atualizar - %d", idFile);

  if (GetEstado() == false) {
    LOG_IF_F(1, STDERR_DEBUG, "Estado operacional do bloqueio nao permite fazer atualizacao");
    return 0;
  }

  LOG_IF_F(1, STDERR_DEBUG, "Outside value %s id %u", (status == BEGIN_UP) ? "inicio" : "fim", idFile);

  switch (idFile) {
    case EN_CPU: {
      if (status == KILL_UP) {
        INThandler(SIGQUIT);
      }
      break;
    }
    case EN_PL_CTRL: {
      LOG_IF_F(1, STDERR_DEBUG, "Update Firmware da Placa de Controle: fsetStateUpdate");
      if (status == BEGIN_UP) {
        LOG_IF_F(1, STDERR_DEBUG,
                 "Travando as mensagens no display, para somente escrever mensagens "
                 "do sistema de atualizacao");
        Lcd_SetStatusLockMsgDisp(true);
      } else if (status == END_UP) {
        LOG_IF_F(1, STDERR_DEBUG,
                 "Destravando as mensagens no display, para somente escrever mensagens "
                 "da aplicacao");
        Lcd_SetStatusLockMsgDisp(false);
        _needStartIndiclum = true;
        _flagUpdating = false;
        actionModule_setDoorsPerformed(false);
        actionModule_setStatusBootloaderControlBoard(false);
      }
      break;
    }
    case EN_DOORS: {
      LOG_IF_F(1, STDERR_DEBUG, "Update Firmware da Placa do Motor: fsetStateUpdate");
      if (status == BEGIN_UP) {
        LOG_IF_F(1, STDERR_DEBUG,
                 "Travando as mensagens no display, para somente escrever mensagens "
                 "do sistema de atualizacao");
        Lcd_SetStatusLockMsgDisp(true);

        IndicLum_SendStatusEntranceDoorOutOfOperation(DOOR_MODE_NONE);
        IndicLum_SendStatusExitDoorOutOfOperation(DOOR_MODE_NONE);
        IndicLum_LockSyncLeds();
        actionModule_sendMsgCancelDoors();
        IndicLum_SetCanChangePositionDoors(false);
        IndicLum_SendTimeOutRespDoor(200);
        IndicLum_SetCheckStatusDoors(LEVEL_STATUS_DOOR_OFF, MESSAGE_DELIVERY_GUARANTEE);
        IndicLum_SetUpdatingDoors(true, MESSAGE_DELIVERY_GUARANTEE);
        IndicLum_NotAlive(MESSAGE_DELIVERY_GUARANTEE);
        usleep(400000);
      } else if (status == END_UP) {
        LOG_IF_F(1, STDERR_DEBUG,
                 "Destravando as mensagens no display, para somente escrever mensagens "
                 "da aplicacao");
        Lcd_SetStatusLockMsgDisp(false);

        IndicLum_UnlockMessageAdd();
        IndicLum_SetCanChangePositionDoors(true);
        IndicLum_SendTimeOutRespDoor(5);
        IndicLum_UnlockMessageSendDoors();
        IndicLum_SendStatusEntranceDoorOutOfOperation(actionModule_xmlGetStatusEntranceDoorsOutOperation());
        IndicLum_SendStatusExitDoorOutOfOperation(actionModule_xmlGetStatusExitDoorsOutOperation());
        IndicLum_UnlockSyncLeds();
        IndicLum_SetCheckStatusDoors(LEVEL_STATUS_DOOR_WITHOUT_VERSION, MESSAGE_DELIVERY_GUARANTEE);
        IndicLum_SetUpdatingDoors(false, MESSAGE_DELIVERY_GUARANTEE);
        IndicLum_SendSyncMsg(true);
        actionModule_startIdle(4, 9, MAIN_INDIC_LUM_TAM_IDLE, true);
      }
      break;
    }
  }
  return 1;
}

static void CheckReaderListToLedsStripTotemOff(const vector<Reader *> &readerList, vector<StateArgStruct> &argsList) {
  for (size_t counterReader = 0; counterReader < readerList.size(); counterReader++) {
    uint8_t validationType = readerList[counterReader]->getValidationType();
    LOG_IF_F(1, STDERR_DEBUG, "validationType: %s", _validationTypeStr[validationType]);
    if (validationType == VALIDATION_TYPE_POSITION) {
      StateArgStruct args;
      args.id = static_cast<StripId>(readerList[counterReader]->getId());
      args.state = LED_TOTEM_IDLE;
      args.color = Scalar(0, 255, 0);
      args.speed = 0;
      args.timerOn = 0;
      args.timerOff = 0;
      argsList.push_back(args);
    }
  }
}

static void CheckReaderServerListToLedsStripTotemOff(const vector<ReaderServer *> &readerServerList,
                                                     vector<StateArgStruct> &argsList) {
  for (uint8_t counterReader = 0; counterReader < readerServerList.size(); counterReader++) {
    uint8_t validationType = readerServerList[counterReader]->getValidationType();
    LOG_IF_F(1, STDERR_DEBUG, "validationType: %s", _validationTypeStr[validationType]);
    if (validationType == VALIDATION_TYPE_POSITION) {
      StateArgStruct args;
      args.id = static_cast<StripId>(readerServerList[counterReader]->getId());
      args.state = LED_TOTEM_IDLE;
      args.color = Scalar(0, 255, 0);
      args.speed = 0;
      args.timerOn = 0;
      args.timerOff = 0;
      argsList.push_back(args);
    }
  }
}

static void CheckReaderServerPersonListToLedsStripTotemOff(const vector<ReaderServerPersons *> &readerServerPersonsList,
                                                           vector<StateArgStruct> &argsList) {
  for (uint8_t counterReader = 0; counterReader < readerServerPersonsList.size(); counterReader++) {
    uint8_t validationType = readerServerPersonsList[counterReader]->getValidationType();
    LOG_IF_F(1, STDERR_DEBUG, "validationType: %s", _validationTypeStr[validationType]);
    if (validationType == VALIDATION_TYPE_POSITION) {
      StateArgStruct args;
      args.id = static_cast<StripId>(readerServerPersonsList[counterReader]->getId());
      args.state = LED_TOTEM_IDLE;
      args.color = Scalar(0, 255, 0);
      args.speed = 0;
      args.timerOn = 0;
      args.timerOff = 0;
      argsList.push_back(args);
    }
  }
}

static void CheckReaderMCASPListToLedsStripTotemOff(const vector<ReaderMCASP *> &MCASPServerList,
                                                    vector<StateArgStruct> &argsList) {
  for (uint8_t counterReader = 0; counterReader < MCASPServerList.size(); counterReader++) {
    uint8_t validationType = MCASPServerList[counterReader]->getValidationType();
    LOG_IF_F(1, STDERR_DEBUG, "validationType: %s", _validationTypeStr[validationType]);
    if (validationType == VALIDATION_TYPE_POSITION) {
      StateArgStruct args;
      args.id = static_cast<StripId>(MCASPServerList[counterReader]->getId());
      args.state = LED_TOTEM_IDLE;
      args.color = Scalar(0, 255, 0);
      args.speed = 0;
      args.timerOn = 0;
      args.timerOff = 0;
      argsList.push_back(args);
    }
  }
}

static void ClearLedsStripTotem(vector<StateArgStruct> &argsList) {
  for (uint8_t index = 0; index < STRIP_ID_MAX; index++) {
    StateArgStruct args;
    args.id = static_cast<StripId>(index);
    args.state = LED_TOTEM_OFF;
    args.color = Scalar(0, 0, 0);
    args.timerOn = 0;
    args.timerOff = 0;
    argsList.push_back(args);
  }
}

static void *SaveOpenCVFrames(void *tmpPtr) {
  (void)tmpPtr;
  std::string nameThread = "SaveOpenCVFrame";
  pthread_setname_np(pthread_self(), nameThread.c_str());
  loguru::set_thread_name(nameThread.c_str());
  LOG_F(INFO, "Start thread %s", nameThread.c_str());

  while (_isSaveOpenCVFramesThreadRunning) {
    if (!_frameStructFifo.empty()) {
      VideoAnalyzer_SavedFlowTmpImage(_frameStructFifo.front());
      pthread_mutex_lock(&_saveOpenCVFramesMutex);
      _frameStructFifo.pop();
      pthread_mutex_unlock(&_saveOpenCVFramesMutex);
    }
    usleep(50000);
  }

  LOG_F(INFO, "End of thread %s", nameThread.c_str());
  return nullptr;
}

bool MustForceDoorMove(DoorActivation forceDoor, DoorOperationalState *statusDoor, uint16_t *angleDoor,
                       int currentPercentageDoor_ENT, int currentPercentageDoor_EXT) {
  if (forceDoor == DOOR_ENT && DoorStatus_EntranceDoorsWithCorrectStatus(statusDoor)) {
    uint16_t currentVirtualAngle = (currentPercentageDoor_ENT * 90) / 100;
    uint16_t currentRealAngle = ((angleDoor[DOOR_06] + angleDoor[DOOR_10]) / 2);
    LOG_IF_F(INFO, STDERR_DEBUG, "Entrance | currentVirtualAngle: %u | currentRealAngle: %u", currentVirtualAngle,
             currentRealAngle);
    if ((currentVirtualAngle > currentRealAngle + DIFF_ANGLE_COLLECT_CARD) ||
        (currentVirtualAngle < currentRealAngle - DIFF_ANGLE_COLLECT_CARD)) {
      LOG_IF_F(WARNING, STDERR_DEBUG, "MustForceDoorMove - %s", forceDoor == DOOR_ENT ? "entrance" : "exit");
      return true;
    }
  } else if (forceDoor == DOOR_EXT && DoorStatus_ExitDoorsWithCorrectStatus(statusDoor)) {
    uint16_t currentVirtualAngle = (currentPercentageDoor_EXT * 90) / 100;
    uint16_t currentRealAngle = ((angleDoor[DOOR_07] + angleDoor[DOOR_11]) / 2);
    LOG_IF_F(INFO, STDERR_DEBUG, "Exit | currentVirtualAngle: %u | currentRealAngle: %u", currentVirtualAngle,
             currentRealAngle);
    if ((currentVirtualAngle > currentRealAngle + DIFF_ANGLE_COLLECT_CARD) ||
        (currentVirtualAngle < currentRealAngle - DIFF_ANGLE_COLLECT_CARD)) {
      LOG_IF_F(WARNING, STDERR_DEBUG, "MustForceDoorMove - %s", forceDoor == DOOR_ENT ? "entrance" : "exit");
      return true;
    }
  }

  return false;
}

static bool SetMovimentDoorsAndTimeoutFlags(bool &flagSetTimeoutOpenDoor, bool &flagMovimentDoorsClose,
                                            bool &flagMovimentDoorsOpen) {
  bool ret = false;
  if (!flagSetTimeoutOpenDoor) {
    ret = true;
    LOG_IF_F(1, STDERR_DEBUG, "Inicia movimento lento de abertura das portas");
    flagMovimentDoorsOpen = true;
    flagMovimentDoorsClose = false;
    flagSetTimeoutOpenDoor = true;
  }
  return ret;
}

static void ChecksIdlingOfDoors_ClosedDoorMode(bool &flagSetTimeoutOpenDoor, bool &flagMovimentDoorsClose,
                                               bool &flagMovimentDoorsOpen, bool &doorsOpened, bool &doorsClosed) {
  static bool doorsClosing = false;
  static uint8_t stateLoop = 0;
  static uint8_t tmpStateLoop = 10;

  if (!VideoAnalyzer_NobodyUnauthorisedInsideGate()) {
    if (doorsClosed || doorsClosing) {
      stateLoop = 1;
      flagMovimentDoorsClose = true;
      flagMovimentDoorsOpen = false;
      flagSetTimeoutOpenDoor = false;
    } else {
      stateLoop = 2;
      flagMovimentDoorsClose = false;
      flagMovimentDoorsOpen = false;
      flagSetTimeoutOpenDoor = false;
    }
  } else if (VideoAnalyzer_IsValidationInToOutAvailable() || VideoAnalyzer_IsValidationOutToInAvailable()) {
    doorsClosing = false;
    if (doorsClosed) {
      stateLoop = 3;
      SetMovimentDoorsAndTimeoutFlags(flagSetTimeoutOpenDoor, flagMovimentDoorsClose, flagMovimentDoorsOpen);
    } else if (doorsOpened) {
      stateLoop = 4;
      flagMovimentDoorsClose = false;
      flagMovimentDoorsOpen = true;
      if (flagSetTimeoutOpenDoor) {
        stateLoop = 5;
        flagSetTimeoutOpenDoor = false;
      }
    }
  } else {
    doorsClosing = true;
    stateLoop = 6;
    flagMovimentDoorsClose = true;
    flagMovimentDoorsOpen = false;
    flagSetTimeoutOpenDoor = false;
  }

  if (tmpStateLoop != stateLoop) {
    tmpStateLoop = stateLoop;
    if (STDERR_DEBUG) {
      switch (stateLoop) {
        case 1:
          LOG_F(WARNING, "Portas fechadas - Mantem fechadas");
          break;
        case 2:
          LOG_F(WARNING, "Portas abertas - Controle Auto");
          break;
        case 3:
          LOG_F(WARNING, "Portas fechadas - Abre portas devagar");
          break;
        case 4:
          LOG_F(WARNING, "Portas abertas - Mantem abertas");
          break;
        case 5:
          LOG_F(WARNING, "Portas abertas - Mantem abertas - Potencia maxima");
          break;
        default:
          LOG_F(WARNING, "Fecha as portas");
          break;
      }
    }
  }
}

#define SLOW_OPENING_TIME 2000

static void ChecksIdlingOfDoors_OpenedDoorMode(bool &flagSetTimeoutOpenDoor, bool &flagMovimentDoorsClose,
                                               bool &flagMovimentDoorsOpen, bool &flagWaitingTimeCloseDoors,
                                               bool &flagForceOpenDoor, TimeoutCpp &timeoutOpenDoors,
                                               TimeoutCpp &timeoutClosedDoors,
                                               TimeoutCpp &timeoutPersonFrontGateEntrance,
                                               TimeoutCpp &timeoutPersonFrontGateExit,
                                               uint16_t timePersonStandingFrontGate, uint32_t time32ClosedDoors) {
  bool flag_personInFrontGateEntrance = false;
  bool flag_personInFrontGateExit = false;
  bool flagPersonShow = false;

  if (VideoAnalyzer_GetPersonListSize()) {
    // Reinicia timeout para fechar as portas
    timeoutClosedDoors.Start(time32ClosedDoors);

    VideoAnalyzer_LoadInfoPersonsToSetDoorsByIdleness(flag_personInFrontGateEntrance, flag_personInFrontGateExit,
                                                      flagForceOpenDoor, flagPersonShow);

    // Se portas estao fechadas e tem alguem dentro do bloqueio, nao abre as portas
    if ((flagMovimentDoorsClose) && (flagPersonShow)) {
      LOG_IF_F(1, STDERR_DEBUG, "Segurança para não abrir as portas");
      flag_personInFrontGateEntrance = false;
      flag_personInFrontGateExit = false;
      flagForceOpenDoor = false;
    }

    // Somente reinicia timeout de pessoa em frente ao bloqueio, caso ainda nao tenha iniciado movimento
    // para abrir
    if (!flagMovimentDoorsOpen) {
      // Se não tem ninguem em frente ao bloqueio, reinicia timeout
      if (!flag_personInFrontGateEntrance) {
        timeoutPersonFrontGateEntrance.Start(timePersonStandingFrontGate);
        LOG_IF_F(1, STDERR_DEBUG, "Reinicia o timeout da entrada");
      }
      // Se não tem ninguem em frente ao bloqueio, reinicia timeout
      if (!flag_personInFrontGateExit) {
        timeoutPersonFrontGateExit.Start(timePersonStandingFrontGate);
        LOG_IF_F(1, STDERR_DEBUG, "Reinicia o timeout da saida");
      }
    }

    if (flagWaitingTimeCloseDoors) {
      // Verifica tempo de pessoa parada em frente ao bloqueio ou abertura forçada das portas
      if (timeoutPersonFrontGateEntrance.Check() || timeoutPersonFrontGateExit.Check() || flagForceOpenDoor) {
        LOG_IF_F(1, STDERR_DEBUG, "Timeout de pessoa parada em frente ao bloqueio ou força abertura de portas");
        flagForceOpenDoor = false;

        // Verifica se ja iniciou timeout de abertura lenta das portas
        if (SetMovimentDoorsAndTimeoutFlags(flagSetTimeoutOpenDoor, flagMovimentDoorsClose, flagMovimentDoorsOpen)) {
          timeoutOpenDoors.Start(SLOW_OPENING_TIME);
        }

        if (flagSetTimeoutOpenDoor && timeoutOpenDoors.Check()) {
          LOG_IF_F(1, STDERR_DEBUG, "Acabou timeout de abertura lenta de portas");
          flagWaitingTimeCloseDoors = false;
          flagSetTimeoutOpenDoor = false;
          if (flagMovimentDoorsOpen) {
            flagMovimentDoorsOpen = false;
          }
        }
      }
    }
  } else {
    // Reinicia timers de pessoa em frente ao bloqueio, quando não tem ninguem na imagem
    timeoutPersonFrontGateEntrance.Start(timePersonStandingFrontGate);
    timeoutPersonFrontGateExit.Start(timePersonStandingFrontGate);

    if (VideoAnalyzer_IsValidInviteEntrance() || VideoAnalyzer_IsValidInviteExit()) {
      // Reinicia timeout para fechar as portas
      timeoutClosedDoors.Start(time32ClosedDoors);

      // Verifica se ja iniciou timeout de abertura lenta das portas
      if (SetMovimentDoorsAndTimeoutFlags(flagSetTimeoutOpenDoor, flagMovimentDoorsClose, flagMovimentDoorsOpen)) {
        timeoutOpenDoors.Start(SLOW_OPENING_TIME);
      }

      if (flagSetTimeoutOpenDoor && timeoutOpenDoors.Check()) {
        LOG_IF_F(1, STDERR_DEBUG, "Acabou timeout de abertura lenta de portas");
        flagWaitingTimeCloseDoors = false;
        if (flagMovimentDoorsOpen) {
          flagMovimentDoorsOpen = false;
        }
      }
    }  // Verifica timeout de abertura lenta das portas, quando não tem ninguem na imagem
    else if (flagSetTimeoutOpenDoor && timeoutOpenDoors.Check()) {
      flagWaitingTimeCloseDoors = false;
      flagForceOpenDoor = false;
      if (flagMovimentDoorsOpen) {
        flagMovimentDoorsOpen = false;
      }
      LOG_IF_F(1, STDERR_DEBUG, "Ninguem na imagem e acabou timeout de abertura de portas lentas");
    }

    // Verifica timeout para fechar portas, quando não tem ninguem na imagem
    if ((!flagWaitingTimeCloseDoors) && (timeoutClosedDoors.Check())) {
      flagWaitingTimeCloseDoors = true;
      flagSetTimeoutOpenDoor = false;
      flagMovimentDoorsClose = true;
      flagMovimentDoorsOpen = false;
      flagForceOpenDoor = false;
      LOG_IF_F(1, STDERR_DEBUG, "Ninguem na imagem e acabou timeout de fechamento de portas");
    }
  }
}

static void ChecksIdlingOfDoors(bool &flagSetTimeoutOpenDoor, bool &flagMovimentDoorsClose, bool &flagMovimentDoorsOpen,
                                uint16_t *angleDoor) {
  static bool closedDoorsMode = false;
  static bool flagWaitingTimeCloseDoors = false;
  static bool flagForceOpenDoor = false;
  static TimeoutCpp timeoutOpenDoors;
  static TimeoutCpp timeoutClosedDoors;
  static TimeoutCpp timeoutPersonFrontGateEntrance;
  static TimeoutCpp timeoutPersonFrontGateExit;
  static uint16_t timePersonStandingFrontGate = UINT16_MAX;
  static uint16_t timeClosedDoors = UINT16_MAX;
  static uint32_t time32ClosedDoors = timeClosedDoors * 1000;

  // Verifica se teve alteração no valor do tempo de fechamento por ociosidade
  if (timeClosedDoors != actionModule_xmlGetWaitingTimeCloseDoors()) {
    timeClosedDoors = actionModule_xmlGetWaitingTimeCloseDoors();
    time32ClosedDoors = timeClosedDoors * 1000;
    timeoutClosedDoors.Start(time32ClosedDoors);
  }

  if (!timeClosedDoors) {
    return;
  }

  // Verifica se teve alteração no valor do tempo de abertura por tempo da pessoa parada
  if (timePersonStandingFrontGate != actionModule_xmlGetTimePersonStandingFrontGate()) {
    timePersonStandingFrontGate = actionModule_xmlGetTimePersonStandingFrontGate();
    timeoutPersonFrontGateEntrance.Start(timePersonStandingFrontGate);
    timeoutPersonFrontGateExit.Start(timePersonStandingFrontGate);

    if (!timePersonStandingFrontGate) {
      closedDoorsMode = true;
    } else {
      closedDoorsMode = false;
    }
  }

  bool doorsOpened = (angleDoor[DOOR_06] < DIFF_ANGLE && angleDoor[DOOR_07] < DIFF_ANGLE);
  bool doorsClosed = (angleDoor[DOOR_06] > (100 - DIFF_ANGLE) && angleDoor[DOOR_06] < (100 + DIFF_ANGLE) &&
                      angleDoor[DOOR_07] > (100 - DIFF_ANGLE) && angleDoor[DOOR_07] < (100 + DIFF_ANGLE));

  if (closedDoorsMode) {
    ChecksIdlingOfDoors_ClosedDoorMode(flagSetTimeoutOpenDoor, flagMovimentDoorsClose, flagMovimentDoorsOpen,
                                       doorsOpened, doorsClosed);
  } else {
    ChecksIdlingOfDoors_OpenedDoorMode(flagSetTimeoutOpenDoor, flagMovimentDoorsClose, flagMovimentDoorsOpen,
                                       flagWaitingTimeCloseDoors, flagForceOpenDoor, timeoutOpenDoors,
                                       timeoutClosedDoors, timeoutPersonFrontGateEntrance, timeoutPersonFrontGateExit,
                                       timePersonStandingFrontGate, time32ClosedDoors);
  }
}

void SendsDriveToDoors(bool forceClosingDoorsOn, bool &flagInitTimerForceClosingDoors, bool flagSetTimeoutOpenDoor,
                       bool flagMovimentDoorsClose, bool flagMovimentDoorsOpen, OperationalState &tmpflagToggleStateOp,
                       uint16_t *angleDoor, int &previousPercentageDoor_ENT, int &previousPercentageDoor_EXT,
                       int &previousAngleDoor_08, int &previousAngleDoor_09, int &previousAngleDoor_12,
                       int &previousAngleDoor_13, DoorActivation &forceDoor, bool _forceOpenDoorLft,
                       bool _forceClosedDoorLft, bool _forceOpenDoorRgt, bool _forceClosedDoorRgt) {
  static bool toggleLedForceClosingDoors = false;
  static TimeoutCpp timeoutSentCloseDoor_06;
  static TimeoutCpp timeoutSentCloseDoor_07;
  static TimeoutCpp timeoutSentCloseDoor_10;
  static TimeoutCpp timeoutSentCloseDoor_11;
  static TimeoutCpp timeoutSentOpenDoor_06;
  static TimeoutCpp timeoutSentOpenDoor_07;
  static TimeoutCpp timeoutSentOpenDoor_10;
  static TimeoutCpp timeoutSentOpenDoor_11;

  if ((actionModule_xmlGetWaitingTimeCloseDoors() > 0) && (actionModule_getCheckStatusDoors()) &&
      ((actionModule_xmlGetOpModeDoor() == DOOR_MODE_BIDIRECTIONAL_OPEN) ||
       (actionModule_xmlGetOpModeDoor() == DOOR_MODE_DECENTRALIZED_OPEN)) &&
      (tmpflagToggleStateOp != OP_STATE_FIRE_ALARM) && (tmpflagToggleStateOp != OP_STATE_ALL_FREE) &&
      (tmpflagToggleStateOp != OP_STATE_COLLECT_CARD_URN)) {
#define TIMEOUT_SEND_COMMAND_DOORS 200
    // Verifica se portas devem ser movimentadas
    if (flagMovimentDoorsClose || flagMovimentDoorsOpen) {
      IndicLum_ClearMemDoor();
      static bool flagFirstMoviment_01 = true;
      static bool flagFirstMoviment_02 = true;
      static bool flagFirstMoviment_03 = true;
      bool flagForceClosedEntrance = false;
      bool flagForceClosedExit = false;

#define WITHOUT_KNOCKER
#ifdef WITHOUT_KNOCKER
      if (flagFirstMoviment_01) {
        asm("nop");
      }
#endif

      // Verifica se portas devem fechar lentamente
      if (flagMovimentDoorsClose) {
        if ((actionModule_xmlGetOpModeDoor() == DOOR_MODE_BIDIRECTIONAL_OPEN) &&
            ((actionModule_getStateIn() != OP_STATE_CLOSED) && (actionModule_getStateOut() != OP_STATE_CLOSED))) {
#ifdef WITHOUT_KNOCKER
          static bool sendOther = false;
          if (!sendOther) {
            IndicLum_AddMemAngleDoor(DoorStatus_GetAddressDoor(DOOR_06), 100, actionModule_xmlGetMaxDoorsMovSpeed());
            sendOther = true;
          } else {
            IndicLum_AddMemAngleDoor(DoorStatus_GetAddressDoor(DOOR_07), 100, actionModule_xmlGetMaxDoorsMovSpeed());
            sendOther = false;
          }
          IndicLum_SendMessageDoorMem(MESSAGE_PRIORITY);
#else
          if (angleDoor[DOOR_06] <= 90) {
            if (!timeoutSentCloseDoor_06.IsStarted() || timeoutSentCloseDoor_06.Check()) {
              LOG_IF_F(1, STDERR_DEBUG, "Fecha porta 06 devagar");
              uint8_t tmpSpeed = 100;

              if (flagFirstMoviment_01) {
                tmpSpeed = 30;
              }

              IndicLum_OpenDoor(06, tmpSpeed, false, MESSAGE_DELIVERY_GUARANTEE);
              // indicLum_addMemCommandDoor(6, DOOR_OPEN_EXIT, tmpSpeed);
              timeoutSentCloseDoor_06.Start(TIMEOUT_SEND_COMMAND_DOORS);
            }
          }

          if (angleDoor[DOOR_07] <= 90) {
            if (!timeoutSentCloseDoor_07.IsStarted() || timeoutSentCloseDoor_07.Check()) {
              LOG_IF_F(1, STDERR_DEBUG, "Fecha porta 07 devagar");
              uint8_t tmpSpeed = 100;

              if (flagFirstMoviment_01) {
                tmpSpeed = 30;
              }

              IndicLum_OpenDoor(07, tmpSpeed, false, MESSAGE_DELIVERY_GUARANTEE);
              // indicLum_addMemCommandDoor(7, DOOR_OPEN_EXIT, tmpSpeed);
              timeoutSentCloseDoor_07.Start(TIMEOUT_SEND_COMMAND_DOORS);
            }
          }
#endif

          flagFirstMoviment_01 = false;
          flagFirstMoviment_02 = true;
          flagFirstMoviment_03 = true;
        } else if (((actionModule_xmlGetOpModeDoor() == DOOR_MODE_BIDIRECTIONAL_OPEN) &&
                    ((actionModule_getStateIn() != OP_STATE_CLOSED) &&
                     (actionModule_getStateOut() == OP_STATE_CLOSED))) ||
                   (actionModule_xmlGetOpModeDoor() == DOOR_MODE_DECENTRALIZED_OPEN)) {
          if ((angleDoor[DOOR_06] <= 85) || (angleDoor[DOOR_06] >= 95)) {
            if (!timeoutSentCloseDoor_06.IsStarted() || timeoutSentCloseDoor_06.Check()) {
              LOG_IF_F(1, STDERR_DEBUG, "Fecha porta 06 devagar");
              uint8_t tmpSpeed = 100;

              if (flagFirstMoviment_02) {
                tmpSpeed = 30;
              }

              IndicLum_CloseDoor(06, tmpSpeed, MESSAGE_DELIVERY_GUARANTEE);
              timeoutSentCloseDoor_06.Start(TIMEOUT_SEND_COMMAND_DOORS);
            }
          }

          if ((angleDoor[DOOR_10] <= 85) || (angleDoor[DOOR_10] >= 95)) {
            if (!timeoutSentCloseDoor_10.IsStarted() || timeoutSentCloseDoor_10.Check()) {
              LOG_IF_F(1, STDERR_DEBUG, "Fecha porta 10 devagar");
              uint8_t tmpSpeed = 100;

              if (flagFirstMoviment_02) {
                tmpSpeed = 30;
              }

              IndicLum_CloseDoor(10, tmpSpeed, MESSAGE_DELIVERY_GUARANTEE);
              timeoutSentCloseDoor_10.Start(TIMEOUT_SEND_COMMAND_DOORS);
            }
          }

          flagFirstMoviment_01 = true;
          flagFirstMoviment_02 = false;
          flagFirstMoviment_03 = true;
        } else if ((actionModule_xmlGetOpModeDoor() == DOOR_MODE_BIDIRECTIONAL_OPEN) &&
                   ((actionModule_getStateIn() == OP_STATE_CLOSED) &&
                    (actionModule_getStateOut() != OP_STATE_CLOSED))) {
          if ((angleDoor[DOOR_07] <= 85) || (angleDoor[DOOR_07] >= 95)) {
            if (!timeoutSentCloseDoor_07.IsStarted() || timeoutSentCloseDoor_07.Check()) {
              LOG_IF_F(1, STDERR_DEBUG, "Fecha porta 07 devagar");
              uint8_t tmpSpeed = 100;

              if (flagFirstMoviment_03) {
                tmpSpeed = 30;
              }

              IndicLum_CloseDoor(07, tmpSpeed, MESSAGE_DELIVERY_GUARANTEE);
              timeoutSentCloseDoor_07.Start(TIMEOUT_SEND_COMMAND_DOORS);
            }
          }
          if ((angleDoor[DOOR_11] <= 85) || (angleDoor[DOOR_11] >= 95)) {
            if (!timeoutSentCloseDoor_11.IsStarted() || timeoutSentCloseDoor_11.Check()) {
              LOG_IF_F(1, STDERR_DEBUG, "Fecha porta 11 devagar");
              uint8_t tmpSpeed = 100;

              if (flagFirstMoviment_03) {
                tmpSpeed = 30;
              }

              IndicLum_CloseDoor(11, tmpSpeed, MESSAGE_DELIVERY_GUARANTEE);
              timeoutSentCloseDoor_11.Start(TIMEOUT_SEND_COMMAND_DOORS);
            }
          }

          flagFirstMoviment_01 = true;
          flagFirstMoviment_02 = true;
          flagFirstMoviment_03 = false;
        }
      }  // Verifica se portas devem abrir lentamente
      else if (flagMovimentDoorsOpen) {
        flagFirstMoviment_01 = true;
        flagFirstMoviment_02 = true;
        flagFirstMoviment_03 = true;

        // Verifica existencia de pessoa invalida no bloqueio
        flagForceClosedEntrance = VideoAnalyzer_InvalidPersonInsideInToOut();
        flagForceClosedExit = VideoAnalyzer_InvalidPersonInsideOutToIn();

        if ((actionModule_xmlGetOpModeDoor() == DOOR_MODE_BIDIRECTIONAL_OPEN) &&
            ((actionModule_getStateIn() != OP_STATE_CLOSED) && (actionModule_getStateOut() != OP_STATE_CLOSED))) {
          if (!flagForceClosedEntrance) {
            if (angleDoor[DOOR_06] > 5) {
              if (!timeoutSentOpenDoor_06.IsStarted() || timeoutSentOpenDoor_06.Check()) {
                LOG_IF_F(1, STDERR_DEBUG, "Abre porta 06 devagar");
                uint8_t tmpSpeed = 100;

                if (flagSetTimeoutOpenDoor) {
                  tmpSpeed = 30;
                }

                IndicLum_OpenDoor(06, tmpSpeed, true, MESSAGE_DELIVERY_GUARANTEE);
                timeoutSentOpenDoor_06.Start(TIMEOUT_SEND_COMMAND_DOORS);
              }
            }
          }

          if (!flagForceClosedExit) {
            if (angleDoor[DOOR_07] > 5) {
              if (!timeoutSentOpenDoor_07.IsStarted() || timeoutSentOpenDoor_07.Check()) {
                LOG_IF_F(1, STDERR_DEBUG, "Abre porta 07 devagar");
                uint8_t tmpSpeed = 100;

                if (flagSetTimeoutOpenDoor) {
                  tmpSpeed = 30;
                }

                IndicLum_OpenDoor(07, tmpSpeed, true, MESSAGE_DELIVERY_GUARANTEE);
                timeoutSentOpenDoor_07.Start(TIMEOUT_SEND_COMMAND_DOORS);
              }
            }
          }
        } else if (((actionModule_xmlGetOpModeDoor() == DOOR_MODE_BIDIRECTIONAL_OPEN) &&
                    ((actionModule_getStateIn() != OP_STATE_CLOSED) &&
                     (actionModule_getStateOut() == OP_STATE_CLOSED))) ||
                   (actionModule_xmlGetOpModeDoor() == DOOR_MODE_DECENTRALIZED_OPEN)) {
          if (!flagForceClosedEntrance) {
            if (angleDoor[DOOR_06] > 5) {
              if (!timeoutSentOpenDoor_06.IsStarted() || timeoutSentOpenDoor_06.Check()) {
                LOG_IF_F(1, STDERR_DEBUG, "Abre porta 06 devagar");
                uint8_t tmpSpeed = 100;

                if (flagSetTimeoutOpenDoor) {
                  tmpSpeed = 30;
                }

                IndicLum_OpenDoor(06, tmpSpeed, true, MESSAGE_DELIVERY_GUARANTEE);
                timeoutSentOpenDoor_06.Start(TIMEOUT_SEND_COMMAND_DOORS);
              }
            }
            if (angleDoor[DOOR_10] > 5) {
              if (!timeoutSentOpenDoor_10.IsStarted() || timeoutSentOpenDoor_10.Check()) {
                LOG_IF_F(1, STDERR_DEBUG, "Abre porta 10 devagar");
                uint8_t tmpSpeed = 100;

                if (flagSetTimeoutOpenDoor) {
                  tmpSpeed = 30;
                }

                IndicLum_OpenDoor(10, tmpSpeed, true, MESSAGE_DELIVERY_GUARANTEE);
                timeoutSentOpenDoor_10.Start(TIMEOUT_SEND_COMMAND_DOORS);
              }
            }
          }
        } else if ((actionModule_xmlGetOpModeDoor() == DOOR_MODE_BIDIRECTIONAL_OPEN) &&
                   ((actionModule_getStateIn() == OP_STATE_CLOSED) &&
                    (actionModule_getStateOut() != OP_STATE_CLOSED))) {
          if (!flagForceClosedExit) {
            if (angleDoor[DOOR_07] > 5) {
              if (!timeoutSentOpenDoor_07.IsStarted() || timeoutSentOpenDoor_07.Check()) {
                LOG_IF_F(1, STDERR_DEBUG, "Abre porta 07 devagar");
                uint8_t tmpSpeed = 100;

                if (flagSetTimeoutOpenDoor) {
                  tmpSpeed = 30;
                }

                IndicLum_OpenDoor(07, tmpSpeed, true, MESSAGE_DELIVERY_GUARANTEE);
                timeoutSentOpenDoor_07.Start(TIMEOUT_SEND_COMMAND_DOORS);
              }
            }
            if (angleDoor[DOOR_11] > 5) {
              if (!timeoutSentOpenDoor_11.IsStarted() || timeoutSentOpenDoor_11.Check()) {
                LOG_IF_F(1, STDERR_DEBUG, "Abre porta 11 devagar");
                uint8_t tmpSpeed = 100;

                if (flagSetTimeoutOpenDoor) {
                  tmpSpeed = 30;
                }

                IndicLum_OpenDoor(11, tmpSpeed, true, MESSAGE_DELIVERY_GUARANTEE);
                timeoutSentOpenDoor_11.Start(TIMEOUT_SEND_COMMAND_DOORS);
              }
            }
          }
        }
      }

      if ((actionModule_xmlGetOpModeDoor() == DOOR_MODE_BIDIRECTIONAL_OPEN) &&
          ((actionModule_getStateIn() != OP_STATE_CLOSED) && (actionModule_getStateOut() != OP_STATE_CLOSED))) {
        if ((!flagForceClosedEntrance) && (angleDoor[DOOR_10] > 5)) {
          if (!timeoutSentOpenDoor_10.IsStarted() || timeoutSentOpenDoor_10.Check()) {
            LOG_IF_F(1, STDERR_DEBUG, "Abre porta 10");
            IndicLum_OpenDoor(10, 100, true, MESSAGE_DELIVERY_GUARANTEE);
            timeoutSentOpenDoor_10.Start(TIMEOUT_SEND_COMMAND_DOORS);
          }
        }

        if ((!flagForceClosedExit) && (angleDoor[DOOR_11] > 5)) {
          if (!timeoutSentOpenDoor_11.IsStarted() || timeoutSentOpenDoor_11.Check()) {
            LOG_IF_F(1, STDERR_DEBUG, "Abre porta 11");
            IndicLum_OpenDoor(11, 100, true, MESSAGE_DELIVERY_GUARANTEE);
            timeoutSentOpenDoor_11.Start(TIMEOUT_SEND_COMMAND_DOORS);
          }
        }
      } else if (((actionModule_xmlGetOpModeDoor() == DOOR_MODE_BIDIRECTIONAL_OPEN) &&
                  ((actionModule_getStateIn() != OP_STATE_CLOSED) &&
                   (actionModule_getStateOut() == OP_STATE_CLOSED))) ||
                 (actionModule_xmlGetOpModeDoor() == DOOR_MODE_DECENTRALIZED_OPEN)) {
        if (!flagForceClosedEntrance) {
          if (angleDoor[DOOR_07] > 5) {
            if (!timeoutSentOpenDoor_07.IsStarted() || timeoutSentOpenDoor_07.Check()) {
              LOG_IF_F(1, STDERR_DEBUG, "Abre porta 07");
              IndicLum_OpenDoor(07, 100, true, MESSAGE_DELIVERY_GUARANTEE);
              timeoutSentOpenDoor_07.Start(TIMEOUT_SEND_COMMAND_DOORS);
            }
          }

          if (angleDoor[DOOR_11] > 5) {
            if (!timeoutSentOpenDoor_11.IsStarted() || timeoutSentOpenDoor_11.Check()) {
              LOG_IF_F(1, STDERR_DEBUG, "Abre porta 11");
              IndicLum_OpenDoor(11, 100, true, MESSAGE_DELIVERY_GUARANTEE);
              timeoutSentOpenDoor_11.Start(TIMEOUT_SEND_COMMAND_DOORS);
            }
          }
        }
      } else if ((actionModule_xmlGetOpModeDoor() == DOOR_MODE_BIDIRECTIONAL_OPEN) &&
                 ((actionModule_getStateIn() == OP_STATE_CLOSED) && (actionModule_getStateOut() != OP_STATE_CLOSED))) {
        if (!flagForceClosedExit) {
          if (angleDoor[DOOR_06] > 5) {
            if (!timeoutSentOpenDoor_06.IsStarted() || timeoutSentOpenDoor_06.Check()) {
              LOG_IF_F(1, STDERR_DEBUG, "Abre porta 06");
              IndicLum_OpenDoor(06, 100, true, MESSAGE_DELIVERY_GUARANTEE);
              timeoutSentOpenDoor_06.Start(TIMEOUT_SEND_COMMAND_DOORS);
            }
          }

          if (angleDoor[DOOR_10] > 5) {
            if (!timeoutSentOpenDoor_10.IsStarted() || timeoutSentOpenDoor_10.Check()) {
              LOG_IF_F(1, STDERR_DEBUG, "Abre porta 10");
              IndicLum_OpenDoor(10, 100, true, MESSAGE_DELIVERY_GUARANTEE);
              timeoutSentOpenDoor_10.Start(TIMEOUT_SEND_COMMAND_DOORS);
            }
          }
        }
      }

      if (!IndicLum_ShowWindowsMemDoors(actionModule_getStateIn(), actionModule_getStateOut(),
                                        DoorCtrl_GetDoorSpeedIn(), DoorCtrl_GetDoorAngleIn(),
                                        DoorCtrl_GetDoorSpeedOut(), DoorCtrl_GetDoorAngleOut(), flagForceClosedEntrance,
                                        flagForceClosedExit)) {
        // LOG_IF_F(1, STDERR_DEBUG,  "Aciona apenas as portas");
        if (flagForceClosedEntrance && flagForceClosedExit) {
          IndicLum_ChangePositionAndSpeedDoors(DoorCtrl_GetDoorAngleIn(), DoorCtrl_GetDoorSpeedIn(),
                                               DoorCtrl_GetDoorAngleOut(), DoorCtrl_GetDoorSpeedOut());
          LOG_IF_F(1, STDERR_DEBUG, "Aciona as 4 portas");
        } else if (flagForceClosedEntrance) {
          IndicLum_ChangePositionAndSpeedDoor(DoorCtrl_GetDoorAngleIn(), DoorCtrl_GetDoorSpeedIn(), DOOR_ENTRANCE,
                                              MESSAGE_PRIORITY);
          LOG_IF_F(1, STDERR_DEBUG, "Aciona as portas da entrada");
        } else if (flagForceClosedExit) {
          IndicLum_ChangePositionAndSpeedDoor(DoorCtrl_GetDoorAngleOut(), DoorCtrl_GetDoorSpeedOut(), DOOR_EXIT,
                                              MESSAGE_PRIORITY);
          LOG_IF_F(1, STDERR_DEBUG, "Aciona as portas da saída");
        } else if (!flagMovimentDoorsClose) {
          IndicLum_Alive(MESSAGE_PRIORITY);
          LOG_IF_F(1, STDERR_DEBUG, "Envia alive");
        }
      }
    } else {
      if (!IndicLum_ShowWindowsAndDoorsMem(actionModule_getStateIn(), actionModule_getStateOut())) {
        IndicLum_SendMessageDoorMem(MESSAGE_PRIORITY);
      }
    }
  } else if (forceClosingDoorsOn) {
    TimeoutCpp timeoutToggleLed;

    if (!flagInitTimerForceClosingDoors) {
      toggleLedForceClosingDoors = false;
      timeoutToggleLed.Start(0);
      LOG_IF_F(1, STDERR_DEBUG, "Aciona aviso sonoro e forca fechamento de portas");
      IndicLum_SetBuzzer(250, 250, 20, MESSAGE_DELIVERY_GUARANTEE);

      LOG_IF_F(1, STDERR_DEBUG, "Fecha porta devagar");
      if ((actionModule_xmlGetOpModeDoor() == DOOR_MODE_DECENTRALIZED_OPEN) ||
          (actionModule_xmlGetOpModeDoor() == DOOR_MODE_DECENTRALIZED_CLOSED) ||
          (actionModule_xmlGetOpModeDoor() == DOOR_MODE_CENTRALIZED_CLOSED)) {
        IndicLum_CloseDoor(DOOR_ENTRANCE, 20, MESSAGE_DELIVERY_GUARANTEE);
        DoorCtrl_CloseInDoorPercentage(DOOR_CLOSED_CENTRALIZED);
        previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
        VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
        LOG_F(INFO, "Closes entrance doors");
      } else if (actionModule_xmlGetOpModeDoor() == DOOR_MODE_BIDIRECTIONAL_OPEN) {
        if (forceDoor == DOOR_ENT) {
          IndicLum_CloseDoor(DOOR_ENTRANCE, 20, MESSAGE_DELIVERY_GUARANTEE);
          DoorCtrl_CloseInDoorPercentage(DOOR_CLOSED_CENTRALIZED);
          previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
          VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
          LOG_F(INFO, "Closes entrance doors");
        } else {
          IndicLum_CloseDoor(DOOR_EXIT, 20, MESSAGE_DELIVERY_GUARANTEE);
          DoorCtrl_CloseOutDoorPercentage(DOOR_CLOSED_CENTRALIZED);
          previousPercentageDoor_EXT = ((DoorCtrl_GetDoorAngleOut() * 100) / 90);
          VideoAnalyzer_SetDoorIntense(DOOR_EXT, (previousPercentageDoor_EXT * 255) / 100);
          LOG_F(INFO, "Closes exit doors");
        }
      }

      flagInitTimerForceClosingDoors = true;
    }

    // Limpa memoria de acionamento dos leds e das portas
    IndicLum_ClearMemWindow();
    IndicLum_ClearMemDoor();

    if (timeoutToggleLed.Check()) {
      if (toggleLedForceClosingDoors) {
        IndicLum_AddWindowMemTop(0, 100, 0, 0, 0);
        IndicLum_AddWindowMemFront(0, 100, 0, 0, 0);
        IndicLum_AddWindowMemBack(0, 100, 0, 0, 0);
        toggleLedForceClosingDoors = false;
      } else {
        IndicLum_AddWindowMemTop(0, 100, 255, 0, 0);
        IndicLum_AddWindowMemFront(0, 100, 255, 0, 0);
        IndicLum_AddWindowMemBack(0, 100, 255, 0, 0);
        toggleLedForceClosingDoors = true;
      }
      timeoutToggleLed.Start(250);
    }

    if (actionModule_xmlGetOpModeDoor() == DOOR_MODE_DVIATOR_Y) {
      if (_forceOpenDoorRgt) {
        previousAngleDoor_08 = DoorCtrl_CalcAngleForPercentage(0, DOOR_08);
        previousAngleDoor_12 = DoorCtrl_CalcAngleForPercentage(0, DOOR_12);
      } else if (_forceClosedDoorRgt) {
        previousAngleDoor_08 = DoorCtrl_CalcAngleForPercentage(100, DOOR_08);
        previousAngleDoor_12 = DoorCtrl_CalcAngleForPercentage(100, DOOR_12);
      }
      if (_forceOpenDoorLft) {
        previousAngleDoor_09 = DoorCtrl_CalcAngleForPercentage(0, DOOR_09);
        previousAngleDoor_13 = DoorCtrl_CalcAngleForPercentage(0, DOOR_13);
      } else if (_forceClosedDoorLft) {
        previousAngleDoor_09 = DoorCtrl_CalcAngleForPercentage(100, DOOR_09);
        previousAngleDoor_13 = DoorCtrl_CalcAngleForPercentage(100, DOOR_13);
      }
      IndicLum_AddMemAngleDoor(8, previousAngleDoor_08, 20);
      IndicLum_AddMemAngleDoor(12, previousAngleDoor_12, 40);
      IndicLum_AddMemAngleDoor(9, previousAngleDoor_09, 20);
      IndicLum_AddMemAngleDoor(13, previousAngleDoor_13, 40);

      // Aciona leds e portas no modo dViator_Y
      IndicLum_ShowWindowsAndDoorsMem(actionModule_getStateIn(), actionModule_getStateOut());
    } else {
      // Aciona leds, se contiver dados na memoria a serem enviados
      IndicLum_ShowWindowsMemLeds();
    }
  } else {
    if (!IndicLum_ShowWindowsAndDoorsMem(actionModule_getStateIn(), actionModule_getStateOut())) {
      IndicLum_SendMessageDoorMem(MESSAGE_PRIORITY);
    }
  }
}

string getOptargString(char *opt) {
  char *chars = strdup(static_cast<const char *>(opt));
  string str = chars;
  free(chars);
  return str;
}

int getOptargInt(char *opt) {
  char *chars = strdup(static_cast<const char *>(opt));
  int num = atoi(chars);
  free(chars);
  return num;
}

bool getOptargBool(char *opt) {
  if (optarg) {
    return !strncmp(opt, "true", strlen(opt));
  }
  return true;
}

int waitingCommandToCloseApp() {
  while (true) {
    if (main_ChecksIfToCloseApp()) {
      KillApp();
      return EXIT_SUCCESS;
    }
    usleep(100000);
  }
}

void InitializesSystemSignals() {
  // Sinais capturados pelo loguru
  /*
  SIGABRT (can be turned off with LOGURU_CATCH_SIGABRT=0)
  SIGBUS
  SIGFPE
  SIGILL
  SIGINT
  SIGSEGV
  SIGTERM
  */

  signal(SIGHUP, INThandler);  //	1	/* Hangup (POSIX).  */
  // signal(SIGINT, INThandler);     //	2	/* Interrupt (ANSI).  */
  signal(SIGQUIT, INThandler);  //	3	/* Quit (POSIX).  */
  // signal(SIGILL, INThandler);     //	4	/* Illegal instruction (ANSI).  */
  signal(SIGTRAP, INThandler);  //	5	/* Trace trap (POSIX).  */
  // signal(SIGABRT, INThandler);    //	6	/* Abort (ANSI).  */
  // signal(SIGIOT, INThandler);  //	6	/* IOT trap (4.2 BSD).  */
  // signal(SIGBUS, INThandler);     //	7	/* BUS error (4.2 BSD).  */
  // signal(SIGFPE, INThandler);     //	8	/* Floating-point exception (ANSI).  */
  // signal(SIGKILL, INThandler);  //	9	/* Kill, unblockable (POSIX).  */
  signal(SIGUSR1, INThandler);  //	10	/* User-defined signal 1 (POSIX).  */
  // signal(SIGSEGV, INThandler);    //	11	/* Segmentation violation (ANSI).  */
  signal(SIGUSR2, INThandler);  //	12	/* User-defined signal 2 (POSIX).  */
  signal(SIGPIPE, INThandler);  //	13	/* Broken pipe (POSIX).  */
  signal(SIGALRM, INThandler);  //	14	/* Alarm clock (POSIX).  */
  // signal(SIGTERM, INThandler);    //	15	/* Termination (ANSI).  */
  signal(SIGSTKFLT, INThandler);  //	16	/* Stack fault.  */
  // signal(SIGCLD, INThandler);		//	SIGCHLD	/* Same as SIGCHLD (System V).  */
  // signal(SIGCHLD, INThandler);	//	17	/* Child status has changed (POSIX).  */
  signal(SIGCONT, INThandler);  //	18	/* Continue (POSIX).  */
  // signal(SIGSTOP, INThandler);	//	19	/* Stop, unblockable (POSIX).  */
  signal(SIGTSTP, INThandler);  //	20	/* Keyboard stop (POSIX).  */
  signal(SIGTTIN, INThandler);  //	21	/* Background read from tty (POSIX).  */
  // signal(SIGTTOU, INThandler);	//	22	/* Background write to tty (POSIX).  */
  signal(SIGURG, INThandler);     //	23	/* Urgent condition on socket (4.2 BSD).  */
  signal(SIGXCPU, INThandler);    //	24	/* CPU limit exceeded (4.2 BSD).  */
  signal(SIGXFSZ, INThandler);    //	25	/* File size limit exceeded (4.2 BSD).  */
  signal(SIGVTALRM, INThandler);  //	26	/* Virtual alarm clock (4.2 BSD).  */
  signal(SIGPROF, INThandler);    //	27	/* Profiling alarm clock (4.2 BSD).  */
  // signal(SIGWINCH, INThandler);	//	28	/* Window size change (4.3 BSD, Sun).  */
  signal(SIGPOLL, INThandler);  //	SIGIO	/* Pollable event occurred (System V).  */
  signal(SIGIO, INThandler);    //	29	/* I/O now possible (4.2 BSD).  */
  signal(SIGPWR, INThandler);   //	30	/* Power failure restart (System V).  */
  signal(SIGSYS, INThandler);   //	31	/* Bad system call.  */
}

int main(int argc, char *argv[]) {
  bool test = false;
  bool showVersion = false;

  for (int i = 0; i < argc; i++) {
    std::string cmd = argv[i];
    if (!cmd.compare("-test")) test = true;
    if (!cmd.compare("-version")) showVersion = true;
  }

  if (test) {
#ifndef ENABLE_UNIT_TESTS
    return EXIT_FAILURE;
#else
    doctest::Context context;
    context.setOption("abort-after", 5);
    context.setOption("no-run", false);
    context.setOption("exit", true);
    context.applyCommandLine(argc, argv);
    context.setOption("no-breaks", true);
    int res = context.run();
    if (context.shouldExit()) return res;
    context.clearFilters();
#endif
  }

  loguru::init(argc, argv);

  LOG_F(INFO, "OpenCV version %u.%u.%u", CV_MAJOR_VERSION, CV_MINOR_VERSION, CV_SUBMINOR_VERSION);
  LOG_F(INFO, "Software version %s", VERSION);
  LOG_F(INFO, "Compile date and time: %s %s", __DATE__, __TIME__);

  if (showVersion) return EXIT_SUCCESS;
  snmpArgs.mainAppVersion = VERSION;

#ifdef USE_CL
#if CV_MAJOR_VERSION == 3
  ocl::setUseOpenCL(true);
  if (cv::ocl::haveOpenCL()) {
    //
    printf("USING OPENCL \n");
    fflush(stdout);

    // OpenCL: Platform Info
    std::vector<cv::ocl::PlatformInfo> platforms;
    cv::ocl::getPlatfomsInfo(platforms);

    // OpenCL Platforms
    cout << "platforms size " << platforms.size() << endl;
    for (size_t i = 0; i < platforms.size(); i++) {
      // Access to Platform
      const cv::ocl::PlatformInfo *platform = &platforms[i];
      // Platform Name
      std::cout << "Platform Name: " << platform->name().c_str() << "\n";

      // Access Device within Platform
      cv::ocl::Device current_device;

      cout << "platform deviceNumber " << platform->deviceNumber() << endl;
      for (int j = 0; j < platform->deviceNumber(); j++) {
        // Access Device
        platform->getDevice(current_device, j);

        // Device Type
        int deviceType = current_device.type();

        cout << "Device " << j << " type " << deviceType << endl;

        cout << "name                 : " << current_device.name() << endl;
        cout << "available            : " << current_device.available() << endl;
        cout << "imageSupport         : " << current_device.imageSupport() << endl;
        cout << "OpenCL_C_Version     : " << current_device.OpenCL_C_Version() << endl;
        cout << endl;
      }
    }
    printf("\n");
  } else {
    //
    printf("NOT USING OPENCL \n");
    fflush(stdout);
  }
#elif CV_MAJOR_VERSION == 2
  cv::ocl::DevicesInfo devInfo;
  int res = cv::ocl::getOpenCLDevices(devInfo);
  if (res == 0) {
    printf("\nNOT USING OPENCL");
  } else {
    for (uint32_t i = 0; i < devInfo.size(); ++i) {
      std::cout << "Device : " << devInfo[i]->deviceName << " is present" << std::endl;
    }
  }
#endif
#elif CV_MAJOR_VERSION == 3
  ocl::setUseOpenCL(false);
#endif

  Mat frameToTrackingImage;
  Mat frameAfterFilters;
  Mat frame;
  Mat imgFrame;
  uint8_t tmpBltstreamFrame[SIZE_STRUCT_FRAME];
  memset(tmpBltstreamFrame, 0, SIZE_STRUCT_FRAME);
  bool haveFrame = false;
  bool restartCamera = false;
  bool flagEnoughForAverage = false;
  bool forceClosingDoorsOn = false;
  bool forceClosingDoorsOff = true;
  bool flagInitTimerForceClosingDoors = false;
  int maxAmountFrameSaveFiles = 0;
  int fpsAvgCount = 0;
  int qtyFps = 40;
  int tGetImage[FPS_AVERAGE];
  double tAntImage = (double)cvGetTickCount();
  double tTmpImage = (double)cvGetTickCount();
  TimeoutCpp tempoRodando;
  TimeoutCpp tempoAtualizacao;
  TimeoutCpp tempoAtualizacaoInfo;
  TimeoutCpp timeUpdateInviteOff;
  timeUpdateInviteOff.Start(1);
  TimeoutCpp timeUpdateInviteOn;
  timeUpdateInviteOn.Start(1);
  TimeoutCpp timeForceCloseDoor;
  TimeoutCpp timeForceCloseDoorOff;
  TimeoutCpp timeoutNewFrame;
  timeoutNewFrame.Start(MAIN_WAIT_CAMERA_FRAME);

  std::vector<dflow::PositionAndRadius> readersPosition;
  std::vector<dflow::PositionAndRadius> readersServersPosition;
  std::vector<dflow::PositionAndRadius> readersServerPersonsPosition;
  std::vector<dflow::PositionAndRadius> readersMCASPPosition;
  _serialNumber = SerialNumber::GetInstance();
  _sgmIdentifier = SGMIdentifier::GetInstance();
  _readers = Readers::GetInstance();

  memset(tGetImage, 0, sizeof(tGetImage));
  actionModule_xmlRead("");

  _textMode = false;
  bool showInfo = false;
  bool showLayers = true;
  bool accelerationFrame = false;
  bool drawReaders = true;
  bool demoMode = false;
  bool showWindows = false;
  bool showDepth = false;
  bool testeMorphoWave = false;
  bool noCheckDoors = false;
  bool dflowAsValidationZone = false;
  bool clearCounters = false;
  bool _testModeWrite = false;
  bool _testModeRead = false;
  //  bool show_filesize = false;
  uint8_t numberDoors = 4;
  uint8_t frameRate = 40;
  int rotateAngle = 270;
  int timeSchedule = 0;
  int stripTopSize = 81;
  int stripFrontSize = 44;
  int stripBackSize = 44;
  int stripLedAnt = 4;
  int stripLedBlink = 3;
  int stripLed2D = 20;
  int percentChosenRamdomly = 0;
  uint32_t initialFrameFile = 0;
  uint32_t endFrameFile = 999999;
  string bltstream_file = "";
  string doorInfo = "/home/digicon/videos/doorsInfo/";
  string config_file = "config.xml";
  std::string _testFilePath = "/home/digicon/videos/";
#if __GNUC__ >= 7
  string ip_file(AY_OBFUSCATE("/home/digicon/exec_aplicativo/scripts/bin/init-vars/network-settings.env"));
#else
  string ip_file(AY_OBFUSCATE("/home/digicon/exec_aplicativo/scripts/bin/changeIP.sh"));
#endif
  string reader_file = "readers.xml";
  string output_directory = "/home/digicon/videos";
  string dbrFolder;
  int opt = 0;
  int option_index = 0;

  while ((opt = getopt_long_only(argc, argv, "", long_options, &option_index)) != -1) {
    switch (opt) {
      case 1:
        return 0;
      case 2:
        doorInfo = getOptargString(optarg);
        break;
      case 3:
        bltstream_file = getOptargString(optarg);
        break;
      case 4:
        _testFilePath = getOptargString(optarg);
        break;
      case 5:
        initialFrameFile = getOptargInt(optarg);
        break;
      case 6:
        endFrameFile = getOptargInt(optarg);
        break;
      case 8:
        break;
      case 9:
        config_file = getOptargString(optarg);
        break;
      case 10:
        ip_file = getOptargString(optarg);
        break;
      case 11:
        reader_file = getOptargString(optarg);
        break;
      case 12:
        drawReaders = getOptargBool(optarg);
        break;
      case 13:
        demoMode = getOptargBool(optarg);
        break;
      case 14:
        _testModeWrite = getOptargBool(optarg);
        break;
      case 15:
        _testModeRead = getOptargBool(optarg);
        break;
      case 16:
        percentChosenRamdomly = getOptargInt(optarg);
        break;
      case 17:
        stripTopSize = getOptargInt(optarg);
        break;
      case 18:
        stripFrontSize = getOptargInt(optarg);
        break;
      case 19:
        stripBackSize = getOptargInt(optarg);
        break;
      case 20:
        stripLedAnt = getOptargInt(optarg);
        break;
      case 21:
        stripLedBlink = getOptargInt(optarg);
        break;
      case 22:
        stripLed2D = getOptargInt(optarg);
        break;
      case 23:
        testeMorphoWave = getOptargBool(optarg);
        break;
      case 24:
        break;
      case 25:
        rotateAngle = getOptargInt(optarg);
        break;
      case 26:
        showInfo = getOptargBool(optarg);
        break;
      case 27:
        showLayers = getOptargBool(optarg);
        break;
      case 28:
        break;
      case 29:
        accelerationFrame = getOptargBool(optarg);
        break;
      case 30:
        _textMode = getOptargBool(optarg);
        break;
      case 31:
        showWindows = getOptargBool(optarg);
        break;
      case 32:
        showDepth = getOptargBool(optarg);
        break;
      case 33:
        break;
      case 34:
        break;
      case 35:
        noCheckDoors = getOptargBool(optarg);
        break;
      case 36:
        numberDoors = getOptargBool(optarg);
        break;
      case 37:
        break;
      case 38:
        timeSchedule = getOptargInt(optarg);
        break;
      case 39:
        output_directory = getOptargString(optarg);
        break;
      case 40:
        frameRate = getOptargInt(optarg);
        break;
      case 41:
        dflowAsValidationZone = getOptargBool(optarg);
        break;
      case 42:
        clearCounters = getOptargBool(optarg);
        break;
      case 44:
        _isLogFilesDisabled = getOptargBool(optarg);
        break;
      case 45:
        dbrFolder = getOptargString(optarg);
        break;
      default:
        std::cout << "Usage : ./bloq_imagem [options]" << std::endl;
        std::cout << "Available options:" << std::endl;
        /* clang-format off */
        std::cout
            << "{ version   | version software          | version software }\n"
               "{ drif      | doors info folder         | doors info folder }\n"
               "{ bf        | bltstream file input      | bltstream file input }\n"
               "{ test_f    | test file path            | test file path }\n"
               "{ iff       | initial frame file        | initial frame file }\n"
               "{ eff       | end frame file            | end frame file }\n"
               "{ f         | config file               | configuration file }\n"
               "{ ipf       | ip file                   | IP file }\n"
               "{ rf        | reader file               | readers file }\n"
               "{ dr        | draw readers              | draw readers }\n"
               "{ dm        | demo mode                 | demo mode }\n"
               "{ test_w    | test mode write           | test mode write }\n"
               "{ test_r    | test mode read            | test mode read }\n"
               "{ pr        | percent ramdomness        | percent ramdomness }\n"
               "{ st        | strip top size            | strip top size }\n"
               "{ sf        | strip front size          | strip front size }\n"
               "{ sb        | strip back size           | strip back size }\n"
               "{ sla       | strip led ant             | strip led ant }\n"
               "{ slb       | strip led blink           | strip led blink }\n"
               "{ sl2       | strip led 2d              | strip led 2d }\n"
               "{ mw        | morpho wave               | teste morpho wave }\n"
               "{ r         | rotate                    | rotate_angle 90 or 270}\n"
               "{ i         | show info                 | show info messages }\n"
               "{ l         | show layers               | show layers regions }\n"
               "{ ub        | use body                  | use body to set regions }\n"
               "{ af        | acceleration frame        | acceleration frame }\n"
               "{ tm        | text mode                 | text mode }\n"
               "{ sw        | show windows              | show windows }\n"
               "{ sd        | show depth                | show depth }\n"
               "{ pe        | print events              | print events }\n"
               "{ ncd       | no check doors            | no check doors in initialization }\n"
               "{ nd        | number doors              | number of doors }\n"
               "{ T         | time schedule             | run the application for a certain time }\n"
               "{ d         | ouput directory           | directory for output video files }\n"
               "{ framerate | framerate                 | frame rate sensor }\n"
               "{ daz       | dflow as validation zone  | dflow as validation zone }\n"
               "{ cc        | clear counters            | clear counters }\n"
               "{ dlf       | disable log files         | disable log files }\n"
               "{ dbr       | dbrstream folder          | dbrstream folder input }\n"
               "{ h         | help                      | print help message }\n"
            << std::endl;
        /* clang-format on */
        return EXIT_SUCCESS;
    }
  }

  InitializesSystemSignals();
  LOG_F(INFO, "*****  Signal capture initialized  *****");

  initMainMutexes();

  bool flag_sendIdle = true;
  bool flag_sendIdleLcd = true;
  bool flagDemoSent = false;
  bool flagIdleSent = true;
  bool flag_acionaPorta = false;
  bool flag_personEntrance = true;
  bool flag_personExit = true;
  bool flagSetTimeoutOpenDoor = false;
  bool flagMovimentDoorsClose = false;
  bool flagMovimentDoorsOpen = false;

  int colorR_entrance = 0;
  int colorG_entrance = 0;
  int colorB_entrance = 0;
  int colorR_exit = 0;
  int colorG_exit = 0;
  int colorB_exit = 0;
  int velIdle1 = 4;
  int velIdle2 = 9;

  srand(time(nullptr));

  if (output_directory.empty()) output_directory = Util_GetApplicationDirectory();

  if (dflowAsValidationZone) {
    noCheckDoors = true;
    drawReaders = true;
  }

  ErrorIndicator *errorIndicator = ErrorIndicator::GetInstance();
  errorIndicator->SetNoCheckDoors(noCheckDoors);

  // Identification Register must be initialized before loading config.xml.
  IdentificationRegister_Initialize("userGroup_", "serviceGroup_");

  /*****************************************************************************************************************/
  //											CONFIGURATION FILE VARIABLES
  /*****************************************************************************************************************/
  LOG_IF_F(1, STDERR_DEBUG, "Reading %s", config_file.c_str());
  bool readConfigFile = actionModule_xmlRead(config_file.c_str());

  _serialNumber->Set(actionModule_xmlGetSerialNumber());

  // Flags
  _flagAnyCardValidation = actionModule_xmlGetFlagAnyCardsValidation();
  _acceptAnyTicket = actionModule_xmlGetFlagAcceptAnyTicket();
  bool flagWriteVideoOutput = actionModule_xmlGetFlagWriteVideoOutput();
  bool flagWriteBltstream = actionModule_xmlGetFlagWriteBltstream();
  bool flagCheckStatusDoors = actionModule_xmlGetFlagCheckStatusDoors();
  bool flagOpenDoorsOnlyPersonValidInside = actionModule_xmlGetFlagOpenDoorsOnlyPersonValidInside();

  SensorConfigManager::OpMode camFireMode = actionModule_xmlGetCamFireMode();

  int bloqID = actionModule_xmlGetBloqID();
  string descriptionBloq = actionModule_xmlGetDescriptionBloq();
  string IP_controlInterface = actionModule_xmlGetIP_controlInterface();

  ModeExecution modelCam = actionModule_xmlGetModelCam();
  // Carrega valor de frequencia para ativar modo de economia de energia
  uint16_t frameRateEnergySaving = actionModule_xmlGetFreqCamEnergySaving();
  // On demoMode the dFlow will never enter on frameRateEnergySaving
  if (demoMode) frameRateEnergySaving = 0u;

  // Config Bloq
  uint8_t typeInvitationLights = actionModule_xmlGetTypeInvitationLights();
  _typeConvLeds = actionModule_xmlGetTypeConvLeds();
  string typeConvLeds = "";
  switch (_typeConvLeds) {
    case TCP:
      typeConvLeds = "TCP";
      break;
    case UDP:
      typeConvLeds = "UDP";
      break;
    case USB:
      typeConvLeds = "USB";
      break;
  }

  string descriptor_stripLeds = actionModule_xmlGetValue_descriptor_stripLeds();
  _typeReader[READER_ENTRANCE] = actionModule_xmlGetReaderTypeEntrance();
  _typeReader[READER_EXIT] = actionModule_xmlGetReaderTypeExit();
  _typeConvAnt = actionModule_xmlGetTypeConvAnt();

  string typeConvAnt = "";
  switch (_typeConvAnt) {
    case TCP:
      typeConvAnt = "TCP";
      break;
    case UDP:
      typeConvAnt = "UDP";
      break;
    case USB:
      typeConvAnt = "USB";
      break;
  }

  string descriptor_antenaIn = "";
  actionModule_xmlGetValue_descriptor_antenaIn(descriptor_antenaIn);
  string descriptor_antenaOut = "";
  actionModule_xmlGetValue_descriptor_antenaOut(descriptor_antenaOut);
  string gateID = "";
  actionModule_xmlGetValue_gateID(gateID);
  string terminal = "";
  actionModule_xmlGetValue_terminal(terminal);
  string dependencia = "";
  actionModule_xmlGetValue_dependencia(dependencia);
  string destinationFiles = "";
  string descriptor_honeywell_reader = "";
  actionModule_xmlGetValue_descriptor_honeywell_reader(descriptor_honeywell_reader);

  int minAmountFrameSaveFiles = actionModule_xmlGetMinAmountFrameSaveFiles();
  // tempo de intervalo em segundos para mostrar a informação de pessoas por minuto
  int intervalTimePersonPerMinute = actionModule_xmlGetIntervalTimePersonPerMinute();
  VideoAnalyzer_setMaxSpeedScatterbrain(actionModule_xmlGetSpeedDistractedPersonTriggerWarning());

  // Control board IO
  bool flagStatusIO = actionModule_xmlGetEnableInputValidation();
  // Flag para habilitar ou não o envio de violação por relé
  bool flagSendViolation = actionModule_xmlGetEnableSendViolation();
  // Percentual para indicar violação
  uint8_t percentageToIndicateViolation = actionModule_xmlGetPercentageToIndicateViolation();
  uint8_t turningSimulationPercentage = actionModule_xmlGetTurningSimulationPercentage();
  turningSimulationPercentage = (turningSimulationPercentage < 10) ? 10 : turningSimulationPercentage;

  // Monitor Service Connection
  string monitorHost = actionModule_xmlGetMonitorHost();
  int monitorPort = actionModule_xmlGetMonitorPortNumber();
  string monitorVersion = actionModule_xmlGetMonitorVersion();
  _sgmIdentifier->Set(actionModule_xmlGetSGMIdentifier());

  // BrMania configuration
  string brManiaConnection = actionModule_xmlGetSerialConnectionBrMania();

  // Sita configuration
  bool flagSitaEnable = actionModule_xmlGetSitaEnable();
  string sitaConection = "";
  actionModule_xmlGetSerialConectionSita(sitaConection);
  string printerConection = "";
  actionModule_xmlGetSerialConectionPrinter(printerConection);

  // Arinc
  int arincPortNumber = actionModule_xmlGetArincPortNumber();
  int arincTimeOutComm = actionModule_xmlGetArincTimeOutComm();

  // Config OpenCv
  // Carrega altura do sensor
  uint16_t camHeight = actionModule_xmlGetCamHeight();
  // Carrega valor de área mínima na altura máxima
  int minAreaHighestHeight = actionModule_xmlGetMinAreaHighestHeight();
  int minAreaLowestHeight = actionModule_xmlGetMinAreaLowestHeight();
  uint16_t maxHeightValue = actionModule_xmlGetHeightMax();
  uint16_t minHeightValue = actionModule_xmlGetHeightMin();
  uint16_t minAreaSensorHeight = actionModule_xmlGetMinAreaSensorHeight();
  uint16_t minAreaFloor = actionModule_xmlGetMinAreaFloor();

  if (!minAreaSensorHeight) {
    minAreaSensorHeight = CalculatesMinimumAreaAtTheEnds((camHeight - camHeight), camHeight, minHeightValue,
                                                         maxHeightValue, minAreaLowestHeight, minAreaHighestHeight);
    minAreaFloor = CalculatesMinimumAreaAtTheEnds((camHeight - 0), camHeight, minHeightValue, maxHeightValue,
                                                  minAreaLowestHeight, minAreaHighestHeight);
    actionModule_xmlSetMinAreaSensorHeight(minAreaSensorHeight);
    actionModule_xmlSetMinAreaFloor(minAreaFloor);
  } else {
    minAreaHighestHeight =
        VideoAnalyzer_CalculateMinimumArea(maxHeightValue, camHeight, minAreaSensorHeight, minAreaFloor);
    minAreaLowestHeight =
        VideoAnalyzer_CalculateMinimumArea(minHeightValue, camHeight, minAreaSensorHeight, minAreaFloor);
    actionModule_xmlSetMinAreaHighestHeight(minAreaHighestHeight);
    actionModule_xmlSetMinAreaLowestHeight(minAreaLowestHeight);
  }

  /*****************************************************************************************************************/
  //										CONFIGURATION FILE VARIABLES
  /*****************************************************************************************************************/

  ArquivosGatesEmbarque_SetGateId(gateID.c_str());
  ArquivosGatesEmbarque_SetDestinationFolder(destinationFiles.c_str());
  ArquivosGatesEmbarque_SetAirportDependence(dependencia.c_str());
  ArquivosGatesEmbarque_SetTerminalCode(terminal.c_str());

  int timeIntervalInfo = (actionModule_xmlGetTimeBetweenInfoMessage() * 1000);

  // update the memory in the infoLog
  VerificaMemoriaLivre(output_directory.c_str());
  //	verifica_memoria_ram_livre(output_directory.c_str(), &checkSpaceRam, &checkTotalRam);
  VerificaMemoriaRamLivre(&_checkSpaceRam, &_checkTotalRam);

  // start the log
  InfoLog_Initialize(output_directory.c_str());
  if (!_isLogFilesDisabled) InfoLog_CreateNewLog();

  int anotherInstance = SystemCommands::GetInstance()->GetProcIdByName("bloq_imagem");
  int currentInstance = getpid();
  if (anotherInstance != currentInstance && anotherInstance > 0) {
    LOG_F(ERROR,
          "Another instance of the software is running with PID %d. This instance with PID %d will be terminated.",
          anotherInstance, currentInstance);
    usleep(100000);
    return EXIT_SUCCESS;
  }

  if (_testModeRead || _testModeWrite) PeopleTrackingTest::GetInstance()->SetFilePath(_testFilePath);

  std::string ipServerLcd = "127.0.0.1";
  std::string interfaceEth = "lo";
  if (!Lcd_Init((uint8_t *)ipServerLcd.c_str(), PORTA_LCD, interfaceEth.c_str())) {
    LOG_F(ERROR, "Error initializing LCD...");
  }

  if (Event_LcdInitialize() != 0) LOG_F(ERROR, "Error initializing Event LCD...");

  if (actionModule_xmlGetOpModeDoor() == DOOR_MODE_DVIATOR_Y) Event_SetMode(EVENT_MODE_BYPASS);
  Lcd_Status(SOFT_VERSION);  // Mostra versão do software
  Event_LcdRefresh();        // Atualiza o LCD
  Event_Lcd(EVENT_TYPE_POWER_UP);

  string IP_bloq_imagem = MiscellaneousNetworkOperations::GetInstance()->GetIpHost();
  string Mask_bloq_imagem = MiscellaneousNetworkOperations::GetInstance()->GetMaskHost();
  MiscellaneousNetworkOperations::GetInstance()->LoadNetworkConfigurations(ip_file);

  LOG_IF_F(INFO, STDERR_DEBUG, "Output folder: %s", output_directory.c_str());

  if (!readConfigFile) {
    LOG_F(ERROR, "Failed to open %s", config_file.c_str());

    IndicLum_Initialize((char *)typeConvLeds.c_str(), (char *)descriptor_stripLeds.c_str(), flagStatusIO, stripTopSize,
                        stripFrontSize, stripBackSize, stripLedAnt, stripLedBlink, stripLed2D,
                        actionModule_xmlGetBrManiaEnable());

    errorIndicator->SetError(ErrorIndicator::ERROR_OPENING_CONFIG_FILE);
    return waitingCommandToCloseApp();
  } else {
    LOG_F(INFO, "Read from %s file:", config_file.c_str());
    // salvar o XML
    actionModule_xmlWrite(config_file.c_str());
    // print xml variables
    actionModule_xmlPrint();
  }

  if (actionModule_xmlGetModelCam() == P23X) frameRate = 25;
  LOG_IF_F(WARNING, STDERR_DEBUG, "-frameRate: %u", frameRate);
  qtyFps = frameRate;
  uint32_t timeoutGetFrame = (1000 / frameRate) + (((1000 / frameRate) * 100) / 100);
  LOG_IF_F(WARNING, STDERR_DEBUG, "timeoutGetFrame: %u", timeoutGetFrame);

#ifdef DPRINT_STAND_ALONE
  if (initializeRemoteConfigModule()) {
    LOG_F(INFO, "Remote configuration module connected");
  } else {
    LOG_F(WARNING, "Remote configuration module DISCONNECTED");
  }

  sleep(2);
  Lcd_Msg(LCD_FIELD_DATE_HOUR, FONT_SIZE_G, FONT_COLOR_WHITE, strlen("TRUE"), (const uint8_t *)"TRUE");
  Lcd_Msg(LCD_FIELD_IMG, FONT_SIZE_LOAD, 0, strlen(IMG_EV_INIT), (const uint8_t *)IMG_EV_INIT);
  Lcd_Msg(LCD_FIELD_LIN1, FONT_SIZE_G, FONT_COLOR_WHITE, strlen("dPrint DEMO"), (const uint8_t *)"dPrint DEMO");
  Lcd_Msg(LCD_FIELD_LIN2, FONT_SIZE_G, FONT_COLOR_WHITE, strlen("WELCOME"), (const uint8_t *)"WELCOME");
  Lcd_Msg(LCD_FIELD_LIN3, FONT_SIZE_G, FONT_COLOR_WHITE, 0, nullptr);
  Lcd_Msg(LCD_FIELD_LIN4, FONT_SIZE_G, FONT_COLOR_WHITE, 0, nullptr);
  Lcd_Msg(LCD_FIELD_STATUS, FONT_SIZE_G, FONT_COLOR_WHITE, strlen("dPrint DIGICON"), (const uint8_t *)"dPrint DIGICON");
  Lcd_Refresh();
  std::string serialDprintButton;
  actionModule_xmlGetSerialDprintButton(serialDprintButton);
  DprintButton::DprintButtonOpMode opModeButton = actionModule_xmlGetDprintButtonOpMode();
  BrMania::GetInstance(brManiaConnection, serialDprintButton, opModeButton);

  while (true) {
    sleep(1);
    if (main_ChecksIfToCloseApp()) {
      LOG_F(WARNING, "Closing application...");
      break;
    }
  }

  remoteConfig_finish();
  BrMania::Destroy();
  sleep(1);
  return EXIT_SUCCESS;
#endif

  if (!bltstream_file.empty()) {
    syncServer_SetReprocMode();
    if (monitorPort) monitorPort = 0;
  } else if (!demoMode && !actionModule_xmlGetBrManiaBypassMode()) {
    // start the syncServer
    syncServer_InitializeModule(camFireMode);
    GateLineServer_Create();
    initializeSyncClientModule(frameRate);
  }

  // initialize infoCount
  if (infoCount_initialize(output_directory.c_str())) {
    LOG_F(INFO, "Initialize infoCount");
  } else {
    LOG_F(ERROR, "Error initialize infoCount");
  }
  // clean the infoMonitor Values
  infoMonitor_setDadosDefaultValues();

  if (clearCounters) {
    infoCount_print();
    LOG_F(WARNING, "Counters will be reset to zero...");
    infoCount_cleanCyclesDoors();
    infoCount_cleanTimePartial();
    infoCount_ForceUpdateFile();
    Timeout timeFileCountersUpdate = Timeout_Create();
    Timeout_Start(timeFileCountersUpdate, 2000);
    while ((!infoCount_IsFileUpdated()) && (!Timeout_Check(timeFileCountersUpdate))) {
      usleep(100000);
    }
    if (!Timeout_IsStarted(timeFileCountersUpdate)) {
      LOG_F(ERROR, "failed to update count files");
    } else {
      LOG_F(INFO, "Success when updating count files");
    }
    // infoSystem();
    infoCount_print();
    Timeout_Destroy(timeFileCountersUpdate);
    KillApp();
    return EXIT_SUCCESS;
  }

  // test if are using the demoMode
  if (demoMode) {
    // if are using the demoMode. Don't pass the readerFile to actionModule
    actionModule_initialize(" ", config_file.c_str(), output_directory.c_str());
  } else {
    // else initialize the actionModule with the readersFile
    actionModule_initialize(reader_file.c_str(), config_file.c_str(), output_directory.c_str());
  }

  actionModule_CreateSymbolicLinkFromWindowImage();
  actionModule_SetSoftExecParam_Rotate(rotateAngle);
  actionModule_SetSoftExecParam_ShowLayers(showLayers);
  actionModule_SetIpFilePath(ip_file);

  DebugFileManager::GetInstance()->SetOutputFolder(output_directory);
  VisualCortex::GetInstance()->SetDbrFolder(dbrFolder);
  DoorsManager::GetInstance()->SetNoCheckDoors(noCheckDoors);
  DoorsLogManager::GetInstance()->SetFilePath(doorInfo);

  actionModule_DiagnosticInfo_SetValueKey(actionModule_DiagnosticInfo_KeyToString(SOFTWARE_VERSION), VERSION);

  // set door mode after initialize actionModule
  actionModule_setOpModeDoor(actionModule_xmlGetOpModeDoor());

  actionModule_setNumberOfDoors(numberDoors);
  LOG_IF_F(1, STDERR_DEBUG, "Number of doors: %u", actionModule_getNumberOfDoors());

  if (testeMorphoWave) {
    LOG_F(WARNING, "Test Morpho Wave Enabled");
    actionModule_setTestMorphoWave();
  }

  if (flagCheckStatusDoors) {
    LOG_F(WARNING, "Enable Check Status Doors");
    actionModule_setCheckStatusDoors();
  }

  if ((actionModule_xmlGetWaitingTimeCloseDoors() > 0) && (actionModule_getCheckStatusDoors())) {
    LOG_F(WARNING, "Close Doors Mode In Idle Enable");
  } else {
    LOG_F(WARNING, "Close Doors Mode In Idle Disable");
  }

  if (flagSitaEnable) actionModule_setUsingSita();
  PeripheralDemonstration_Create();
  if (!actionModule_xmlGetBrManiaBypassMode()) {
    if (dflowAsValidationZone) {
      LOG_F(INFO, "Dflow as validation zone");
      actionModule_setDflowAsValidationZone(dflowAsValidationZone);
      actionModule_xmlSetEnableFraudTriggerInvalidCrossing(false);
      actionModule_xmlSetEnableFraudTriggerJumpOverModule(false);
      actionModule_xmlSetEnableFraudTriggerPersonWithoutVolume(false);
    }

    // test if are NOT using the demoMode
    if (!demoMode) {
      if (bltstream_file.length()) {
        LOG_IF_F(1, STDERR_DEBUG, "MODO DE LEITURA DO ARQUIVO COM INFORMAÇÕES DE FRAME");
        size_t found = bltstream_file.find_last_of("/\\");
        string filePath = bltstream_file.substr(0, found);
        string fileName = bltstream_file.substr(found + 1);
        if (!strcmp(fileName.c_str(), filePath.c_str())) {
          filePath = output_directory.c_str();
          filePath.append("/bltstream");
        }
        if (Bltstream::GetInstance()->InitializeReadMode(filePath.c_str(), fileName.c_str(), initialFrameFile,
                                                         endFrameFile)) {
          LOG_F(INFO, "Bltstream module initialized successfully in read mode");
          _bltstreamFileOpMode = BLTSTREAM_FILE_MODE_READ;
          actionModule_setLevelStatusDoors(LEVEL_STATUS_DOOR_WITHOUT_VERSION);
          if (!VisualCortex::GetInstance()->GetDbrFolder().empty()) {
            VisualCortex::GetInstance()->SetReprocMode();
          }
        } else {
          LOG_F(ERROR, "Error initializing the Bltstream module in read mode, exiting app");
          KillApp();
          return EXIT_SUCCESS;
        }
      } else {
        if (flagWriteBltstream) {
          if ((modelCam == TIMETH) || (modelCam == M100) || (modelCam == P323) || (modelCam == P23X)) {
            if (Bltstream::GetInstance()->InitializeWriteMode(output_directory.c_str())) {
              LOG_F(INFO, "Bltstream module initialized successfully in write mode");
            } else {
              LOG_F(ERROR, "Error initializing the Bltstream module in write mode");
            }

            _bltstreamFileOpMode = BLTSTREAM_FILE_MODE_WRITE;
          }
        }
      }

      if ((frameRateEnergySaving) && (_bltstreamFileOpMode != BLTSTREAM_FILE_MODE_READ)) {
        // Enable sensor operation mode change during the execution of the application
        actionModule_SetUseChangeModeOpCam(frameRateEnergySaving);
      }

      // se estiver habilitado o POC inicializa modulo de controle de arquivos
      if (actionModule_xmlGetFlagPocAeroporto()) {
        buffCirc.init();
        buffCirc.setAmountReused(actionModule_xmlGetAmountReused());
        ArquivosGatesEmbarque_Create();
        if (actionModule_xmlGetFlagTravelInspection()) {
          ArquivosGatesEmbarque_InspectionFileClose();
          ArquivosGatesEmbarque_InspectionFileCreate();
          ArquivosGatesEmbarque_InspectionFileNameCreate();
        }
        Event_SetMode(EVENT_MODE_AIRPORT_POC);
      }

      int tmpRetInitVideoAnalyzer = VideoAnalyzer_Initialize(
          frame, tmpBltstreamFrame, minAreaHighestHeight, minAreaLowestHeight, maxHeightValue, minHeightValue,
          _bltstreamFileOpMode, showWindows, percentChosenRamdomly, qtyFps, turningSimulationPercentage,
          MAIN_TIME_WAIT_FIRST_FRAME, minAreaSensorHeight, minAreaFloor);

      if (tmpRetInitVideoAnalyzer < 0) {
        LOG_F(ERROR, "Error initializing VideoAnalyzer module.");
        if (tmpRetInitVideoAnalyzer == -2) {
          KillApp();
          return EXIT_SUCCESS;
        }
      }
    }

    actionModule_setState(actionModule_xmlGetStateEntrance(), actionModule_xmlGetStateExit());

    static bool _flag_statusControlBoard = false;
    if (IndicLum_Initialize((char *)typeConvLeds.c_str(), (char *)descriptor_stripLeds.c_str(), flagStatusIO,
                            stripTopSize, stripFrontSize, stripBackSize, stripLedAnt, stripLedBlink, stripLed2D,
                            actionModule_xmlGetBrManiaEnable()) == true) {
      LOG_F(INFO, "IndicLum module initialized successfully");
      _flag_statusControlBoard = true;

      DoorsManager::GetInstance()->WaitingInitialProcedures();
    } else {
      LOG_F(ERROR, "Error initializing the IndicLum module");
      actionModule_setFlagUpdateControlBoard(false);
      actionModule_setFlagUpdateMotorBoard(false);
      IndicLum_UnlockMessageAdd();
      actionModule_cleanCheckStatusDoors();
    }

    if (initializeRemoteConfigModule()) {
      LOG_F(INFO, "Remote configuration module connected");
    } else {
      LOG_F(WARNING, "Remote configuration module DISCONNECTED");
    }

    if ((!actionModule_getFlagUpdateControlBoard()) && IndicLum_GetCheckVersionControlBoard()) {
      DoorsManager::GetInstance()->InitialSetupProcedure();
    }

    if (actionModule_xmlGetBrManiaEnable()) {
      Pictogram::GetInstance()->SetsManualControlMode();
    }

    if (IndicLum_GetCheckVersionControlBoard()) {
      _retThreadFireAlarm = pthread_create(&_threadTestFireAlarm, nullptr, &TestFireAlarm, nullptr);
      if (_retThreadFireAlarm == 0) {
        ThreadStack::GetInstance()->Push(&_threadTestFireAlarm, &_isTestFireAlarmRunning, "main _threadTestFireAlarm",
                                         nullptr);
      } else {
        LOG_F(ERROR, "Error while creating thread TestFireAlarm: %s", strerror(_retThreadFireAlarm));
      }
    }

    // get pixel per meter
    int multPixH = 1, multPixV = 1;
    VideoAnalyzer_GetPixPmeterFloor(multPixH, multPixV);

    // update the tailgater values
    if (!actionModule_xmlGetTailgaterMinDistanceCM()) {
      // pixels convert to centimeters
      actionModule_xmlSetTailgaterMinDistanceCM(
          (((int)(((float)(actionModule_xmlGetTailgaterMinDistance()) * 1000.f / multPixH))) / 10));
    }

    // centimeters convert to pixels
    actionModule_xmlSetTailgaterMinDistance(
        (int)(((float)(actionModule_xmlGetTailgaterMinDistanceCM() * 10) / 1000.f) * multPixH));

    // set the tailgater
    VideoAnalyzer_SetTailgaterMinimunDistance(actionModule_xmlGetTailgaterMinDistance());

    ///////Start the server update
    int ret = serverUpdate_Initialize(output_directory.c_str(), argv[0], (char *)typeConvLeds.c_str(),
                                      (char *)descriptor_stripLeds.c_str(), _IndicLum_gstInfoPlDoors,
                                      main_FquestCanUpdate, main_FsetStateUpdate);

    if (ret == EXIT_SUCCESS) {
      LOG_F(INFO, "Server Update module initialized successfully");
    } else if (ret == -1) {
      LOG_F(ERROR, "Error initializing the Server Update module");
    } else if (ret == -2) {
      if (_flag_statusControlBoard) {
        // set Op State
        actionModule_setState(OP_STATE_CLOSED, OP_STATE_CLOSED);
        IndicLum_SetCheckStatusDoors(LEVEL_STATUS_DOOR_OFF, MESSAGE_DELIVERY_GUARANTEE);

        LOG_F(WARNING, "***** __Will start the initial update__ *****");
        do {
          usleep(25000);
          // process the actions in the end of this loop
          actionModule_processActions();

          if (_needStartIndiclum || IndicLum_NeedRestartIndiclum()) {
            if (IndicLum_Initialize((char *)typeConvLeds.c_str(), (char *)descriptor_stripLeds.c_str(), flagStatusIO,
                                    stripTopSize, stripFrontSize, stripBackSize, stripLedAnt, stripLedBlink, stripLed2D,
                                    actionModule_xmlGetBrManiaEnable()) == true) {
              LOG_F(INFO, "IndicLum module initialized successfully");
            } else {
              LOG_F(ERROR, "Error initializing the IndicLum module");
              actionModule_setFlagUpdateControlBoard(false);
              actionModule_setFlagUpdateMotorBoard(false);
            }

            _needStartIndiclum = false;
            _flagGetStatusButtonUrn = false;
          }
        } while (!actionModule_getEndFirstUpdate());

        LOG_F(WARNING, "End of initial update. System reboot required");
        usleep(500000);
        KillApp();
        return EXIT_SUCCESS;

      } else {
        LOG_F(ERROR, "It is not possible to perform the initial update. Control board disconnected");
      }
    }
    ///////Server update started

    // Verifica necessidade de atualizar firmware das placas
    static bool flagNeedKillApp = false;

    if (actionModule_getFlagUpdateControlBoard()) {
      // set Op State
      actionModule_setState(OP_STATE_CLOSED, OP_STATE_CLOSED);
      LOG_F(WARNING, "Update Control Board");
      if (Threads_CopyBackupBin(EN_PL_CTRL)) {
        do {
          usleep(100000);
        } while (!actionModule_getEndFirstUpdate());

        LOG_F(WARNING, "End of initial update. System reboot required");
      } else {
        LOG_F(ERROR, "Could not update control board");
        // indicLum_setInfoError(enumListError.error_motorBoard);
      }

      flagNeedKillApp = true;
    }

    if (actionModule_getFlagUpdateMotorBoard()) {
      // set Op State
      actionModule_setState(OP_STATE_CLOSED, OP_STATE_CLOSED);
      LOG_F(WARNING, "Update Motor Board");
      if (Threads_CopyBackupBin(EN_DOORS)) {
        sleep(10);
        do {
          usleep(25000);
          // process the actions in the end of this loop
          actionModule_processActions();
        } while (!actionModule_getEndFirstUpdate());
        LOG_F(WARNING, "End of initial update. System reboot required");
      } else {
        LOG_F(ERROR, "Could not update motor board");
        KillThreadTestFireAlarm();
        errorIndicator->SetError(ErrorIndicator::ERROR_MOTOR_BOARD_COM);
        return waitingCommandToCloseApp();
      }
      flagNeedKillApp = true;
    }

    if (flagNeedKillApp) {
      usleep(500000);
      KillApp();
      return EXIT_SUCCESS;
    }

    KillThreadTestFireAlarm();

    if (_flag_statusControlBoard && actionModule_getVersionControlBoard() < VERS_CONTROL_BOARD_COMP) {
      errorIndicator->SetError(ErrorIndicator::ERROR_CONTROL_BOARD_OUTDATED_VERSION);
      return waitingCommandToCloseApp();
    }

    if (actionModule_isDifferentVersionsMotorBoard()) {
      errorIndicator->SetError(ErrorIndicator::ERROR_MOTOR_BOARD_DIFF_VERSION);
      return waitingCommandToCloseApp();
    }

    if (_flag_statusControlBoard && !DoorsManager::GetInstance()->IsMotorBoardPresent()) {
      errorIndicator->SetError(ErrorIndicator::ERROR_MOTOR_BOARD_COM);
      return waitingCommandToCloseApp();
    }

    // test if are NOT using the demo mode
    if (!demoMode) {
      if (ImageCalibration::GetInstance()->LoadSavedCalibration()) {
        LOG_F(INFO, "Image Calibration module initialized successfully");
      } else {
        if (_bltstreamFileOpMode == BLTSTREAM_FILE_MODE_READ) {
          LOG_F(WARNING, "Method of reprocessing, first calibration is not necessary.");
        } else {
          LOG_F(ERROR, "Error initializing the Image Calibration module");
          LOG_F(WARNING, "Initial calibration required for operation");
          sleep(2);
          ActionManager::GetInstance()->SetFirstCalibrateRequirement();
          while (ActionManager::GetInstance()->IsCalibrating()) {
            ActionManager::GetInstance()->Update();
            if (main_ChecksIfToCloseApp() || ActionManager::GetInstance()->IsKillApp()) {
              KillApp();
              return EXIT_SUCCESS;
            }
            usleep(10000);
          }
          flag_sendIdle = false;
        }
      }
    }

    if (actionModule_IsDflowAsValidationZone()) LedStripTotem_Create();

    if (NewValidation_Initialize((char *)typeConvAnt.c_str(), (char *)descriptor_antenaIn.c_str(),
                                 (char *)descriptor_antenaOut.c_str()) == true) {
      LOG_F(INFO, "Validation module initialized successfully");
      Event_LcdIdleEventCard(true);
    } else {
      LOG_F(ERROR, "Error initializing validation module");
    }
  }

  if (actionModule_xmlGetOpModeDoor() == DOOR_MODE_TRAP) Dpass::GetInstance();

  FaceMatch_Create(60, 9001);

  if (HoneywellReader_Create((char *)descriptor_honeywell_reader.c_str(), _acceptAnyTicket)) {
    usleep(1000);  // Timeout inserido para garantir a impressao do texto abaixo apos a utilizacao de SCOPE
    LOG_F(INFO, "Barcode honeywell module initialized successfully");
    Event_LcdIdleEventCode(true);
  } else {
    usleep(1000);  // Timeout inserido para garantir a impressao do texto abaixo apos a utilizacao de SCOPE
    LOG_F(ERROR, "Error initializing the barcode honeywell module");
  }

  OldFilesDeleter::GetInstance()->setOutputDir(output_directory.c_str());

  if (errorIndicator->GetError() == ErrorIndicator::ERROR_STARTING_DELETING_FILES) {
    return waitingCommandToCloseApp();
  }

  VideoOutput_Create(output_directory, qtyFps);

  if (logPass_initialize(output_directory.c_str(), string("logFile.txt").c_str(), false)) {
    LOG_F(INFO, "LogPass module initialized successfully");
  } else {
    LOG_F(ERROR, "Error initializing the LogPass module");
  }

  if (flagStatusIO) Event_LcdIdleEventCard(true);

  // test if are not using the demoMode
  if (!demoMode && !actionModule_xmlGetBrManiaBypassMode()) {
    // Get initial frames
    if (VideoAnalyzer_GetFrame(frame, imgFrame, tmpBltstreamFrame, false, false, timeoutGetFrame) < 0) {
      LOG_F(ERROR, "Error getting new frame");
    }
  }

  tempoAtualizacao.Start(1000);
  tempoAtualizacaoInfo.Start(timeIntervalInfo);

  uint32_t scafisPort = actionModule_xmlGetScafisDflowPort();

  if (scafisPort) {
    LOG_F(INFO, "Start SCAFIS. Port: %u", scafisPort);
    SbgArgs param = {.protocol = SCAFIS_PROTOCOL,
                     .serialFilePath = nullptr,
                     .serialBaudRate = 0,
                     .printerFilePath = printerConection.c_str(),
                     .ReadBarcode = actionModule_getBarcode};
    // Initialize Scafis
    Scafis::GetInstance()->Configure(param, scafisPort);

    actionModule_xmlSetTimeOutValidation(0);
    actionModule_xmlSetEnableFraudTriggerInvalidCrossing(false);
    if (actionModule_xmlGetSpeedDoorPermanentlyOpenMode() < 50) actionModule_xmlSetSpeedDoorPermanentlyOpenMode(50);
    if (actionModule_xmlGetOpModeDoor() != DoorsOperatingMode::DOOR_MODE_CENTRALIZED_CLOSED)
      actionModule_xmlSetOpModeDoor(DoorsOperatingMode::DOOR_MODE_CENTRALIZED_CLOSED);

    Event_SetMode(EVENT_MODE_BYPASS);

    DeviceInformation_SetCompilationDate(__DATE__);
    DeviceInformation_SetFirmwareVersion(VERSAO, REVISAO);
    DeviceInformation_SetSerialNumber(_serialNumber->ToString());
  } else if (arincPortNumber) {
    LOG_F(INFO, "Starting ARINC server on port %u", arincPortNumber);
    Event_SetMode(EVENT_MODE_BYPASS);

    if (arincTimeOutComm < 15) arincTimeOutComm = 15;

    LOG_F(INFO, "ARINC communication timed out: %d", arincTimeOutComm);
    arinc_initialize(arincPortNumber, arincTimeOutComm);
    actionModule_setUsingArinc();
  } else if (flagSitaEnable) {
    LOG_F(INFO, "Start SITA. Serial: %s", sitaConection.c_str());
    LOG_F(WARNING, "Serial printer: %s", printerConection.c_str());
    Event_SetMode(EVENT_MODE_BYPASS);
    actionModule_enableBarcodeReader();

    SbgArgs sitaParameters = {.protocol = SITA_PROTOCOL,
                              .serialFilePath = sitaConection.c_str(),
                              .serialBaudRate = B19200,
                              .printerFilePath = printerConection.c_str(),
                              .ReadBarcode = actionModule_getBarcode};

    _sita = Sita::GetInstance();
    _sita->Run(sitaParameters);

    DeviceInformation_SetCompilationDate(__DATE__);
    DeviceInformation_SetFirmwareVersion(VERSAO, REVISAO);
    DeviceInformation_SetSerialNumber(_serialNumber->ToString());
  } else {
    if (!scafisPort) LOG_F(INFO, "SCAFIS is disable");
    if (!arincPortNumber) LOG_F(INFO, "ARINC is disable");
    if (!flagSitaEnable) LOG_F(INFO, "SITA is disable");

    if (_acceptAnyTicket || actionModule_xmlGetFlagPocAeroporto()) {
      actionModule_enableBarcodeReader();
    }
  }

  // Initialize SOAP
  if (actionModule_xmlGetSoapDFlowPort() && actionModule_xmlGetSoapOrchestratorPort()) actionModule_SetSoapEnable();
  if (actionModule_GetSoapEnable()) {
    soapDFlow_initialize();
    soapDFlow_initializeUpdateImages();
    soapSensor_initialize();
  }

  // Initialize Rest
  if (actionModule_xmlGetRestDFlowPort() > 0 && !actionModule_xmlGetRestListAcceptedRequesterEndpoints().empty()) {
    RestServer::GetInstance()->Configure(actionModule_xmlGetRestListAcceptedRequesterEndpoints(),
                                         actionModule_xmlGetRestDFlowPort());
    RestServer::GetInstance()->SetReaderFile(reader_file);
    actionModule_SetRestServerEnable();
  }
  if (actionModule_xmlGetRestClientPort() > 0 && !actionModule_xmlGetRestClientEndpoint().empty()) {
    RestClient::GetInstance()->Configure(actionModule_xmlGetRestClientEndpoint(), actionModule_xmlGetRestClientPort());
    actionModule_SetRestClientEnable();
  }

  if (actionModule_GetSoapEnable() && (actionModule_GetRestServerEnable() || actionModule_GetRestClientEnable())) {
    errorIndicator->SetError(ErrorIndicator::ERROR_INVALID_CONFIGURATIONS_01);
    return waitingCommandToCloseApp();
  }

  if (actionModule_GetSoapEnable() || actionModule_GetRestServerEnable() || actionModule_GetRestClientEnable()) {
    ResponseMaintenance ret = actionModule_ParseMaintenanceMessage(actionModule_getSOAPStatus());
    if (ret.returnCode != SOAP_OK || !ret.success) LOG_F(ERROR, "Error setting default operating status");
  }

  IndicLum_SendCardCollectorConfig();

  IndicLum_SetAttentionIn(200, 0, 0, 0, MESSAGE_DELIVERY_GUARANTEE);
  IndicLum_SetAttentionOut(200, 0, 0, 0, MESSAGE_DELIVERY_GUARANTEE);

  _errorTime = cvGetTickCount();
  actionModule_setDoorsSpeed(145, 145);

  // conecta com o servidor de monitoramento
  infoMonitor_initialize(monitorHost.c_str(), monitorPort, output_directory.c_str(), monitorVersion.c_str());

  int sgmIdentifier = atoi(&_sgmIdentifier->ToString()[5]);
  infoMonitor_setSerialNumber(sgmIdentifier);

  // set the downloadFolder
  char tmpDownloadFolder[MAXNAME];
  serverUpdate_getDownloadFolder(tmpDownloadFolder);
  infoMonitor_setDownloadFolder(tmpDownloadFolder);
  // set the serial number in infof

  // On demoMode don't create the checkValidationThread because the bloq Will not validate users.
  if (!demoMode) {
    int ret = pthread_create(&_threadCheckValidation, nullptr, &ValidationCheck, nullptr);
    if (ret == 0) {
      ThreadStack::GetInstance()->Push(&_threadCheckValidation, &_isValidationCheckRunning,
                                       "main _threadCheckValidation", nullptr);
    } else {
      LOG_F(ERROR, "Error while creating thread ValidationCheck: %s", strerror(ret));
    }
  }

  // actionModule_setState(actionModule_xmlGetStateEntrance(), actionModule_xmlGetStateExit());
  // changeOpState(actionModule_getStateIn(), actionModule_getStateOut());
  IndicLum_SendSyncMsg(true);

  actionModule_saveState();

  if (!demoMode) {
    _readers->SetPortMCASP(actionModule_xmlGetMCASPPort());
  }

  // set the MCA connection to the actionModule
  actionModule_setMCAConnected();
  actionModule_startClock();

  // Set the currentDay to clean the counters tomorrow
  _currentDay = Util_GetStructTm_LocalTime_Milliseconds(Util_GetMilliseconds()).tm_yday;

  // struct to get the time
  //	struct timeval tmpTimeVal;
  //	struct tm tmpTime;
  // save the last frame if don't have the camera frame
  Mat frameOrig = frame.clone();
  Mat imgFrameOrig = imgFrame.clone();

  if (actionModule_xmlGetBrManiaEnable()) {
    Event_SetMode(EVENT_MODE_BYPASS);
    Event_LcdClear();
    std::string serialDprintButton;
    actionModule_xmlGetSerialDprintButton(serialDprintButton);
    DprintButton::DprintButtonOpMode opModeButton = actionModule_xmlGetDprintButtonOpMode();
    BrMania::GetInstance(brManiaConnection, serialDprintButton, opModeButton);
    uint8_t serialConnectionsBrMania = actionModule_xmlGetBrManiaBypassMode();
    if (serialConnectionsBrMania == 1) {
      string pathSerial = "";
      actionModule_xmlGetSerialConnectionBrManiaPass1(pathSerial);
      DtowerBoard::GetInstance()->AddNewBoard(pathSerial, DtowerBoard::BOTH);
    } else if (serialConnectionsBrMania == 2) {
      string pathSerial = "";
      actionModule_xmlGetSerialConnectionBrManiaPass1(pathSerial);
      DtowerBoard::GetInstance()->AddNewBoard(pathSerial, DtowerBoard::ENTRANCE);
      actionModule_xmlGetSerialConnectionBrManiaPass2(pathSerial);
      DtowerBoard::GetInstance()->AddNewBoard(pathSerial, DtowerBoard::EXIT);
    }
  }

  if (actionModule_xmlGetFlagActivateSNMPModule()) {
    if (SnmpModule::GetInstance() == nullptr) {
      LOG_F(WARNING, "SNMP Module was not started");
    }
  } else {
    LOG_F(INFO, "SNMP Module is deactivated");
  }

  Event_Lcd(EVENT_TYPE_IDLE);
  if (actionModule_xmlGetOpModeDoor() == DOOR_MODE_DVIATOR_Y) {
    LcdActivationRules_Action(IDLE_RULE, nullptr);
    Lcd_Status("DIGICON");
  }

  tempoRodando.Start(0);
  InfoSystem();
  MotorBoardSerialCommands::GetInstance()->StartsCheckingDoorState();
  DoorsFraudCheck::GetInstance();
  LicenseVerifier::GetInstance();
  Configurator::GetInstance()->SetReaderFile(reader_file);
  if (actionModule_xmlGetEnablesAcknowledgeSignal()) AcknowledgeSignalManager::GetInstance();

  if (actionModule_xmlGetEnablesCleaningMode()) CleaningMode::GetInstance()->Enable();

  LOG_F(INFO, "***** Start Main Loop *****");

  // Test if need run the bloq_imagem using demoMode.
  if (demoMode) {
    // int numberReader;
    char strInfoLine[1024];
    char strInfoComLine[1024];
    cv::Vec3b color;

    // test if are running the demo
    if (!PeripheralDemonstration_IsEnable()) {
      PeripheralDemonstration_Enable();
    }

    frame.create(frame.cols, frame.rows, CV_8UC3);
    for (int y = 0; y < frame.rows; y++) {
      for (int x = 0; x < frame.cols; x++) {
        color = frame.at<Vec3b>(Point(x, y));
        color.val[0] = 0;
        color.val[1] = 0;
        color.val[2] = 0;
      }
    }

    sprintf(strInfoComLine, "dFlow Digicon");
    sprintf(strInfoLine, "Demo Mode");

    VideoAnalyzer_WriteInfoLine(frame, strInfoLine, strInfoComLine);

    int curSec = Util_GetStructTm_LocalTime_Milliseconds(Util_GetMilliseconds()).tm_sec;
    static int lastSaveImg = 70;
    if (lastSaveImg != curSec) {
      VideoAnalyzer_SavedFlowTmpImage(frame);
      lastSaveImg = curSec;
      // LOG_F(INFO, "Saving img");
    }

    while (isRunning) {
      IndicLum_ClearMemDoor();
      PeripheralDemonstration_Update();
      IndicLum_SendMessageDoorMem(MESSAGE_DELIVERY_GUARANTEE);

      if (main_ChecksIfToCloseApp()) {
        INThandler(SIGQUIT);
      }
      // run 40FPS
      usleep(25000);
    }
  }

  int ret = pthread_create(&_threadSaveOpenCVFrames, nullptr, &SaveOpenCVFrames, nullptr);
  if (ret == 0) {
    ThreadStack::GetInstance()->Push(&_threadSaveOpenCVFrames, &_isSaveOpenCVFramesThreadRunning,
                                     "main _threadSaveOpenCVFrames", nullptr);
  } else {
    LOG_F(ERROR, "Error while creating thread SaveOpenCVFrames: %s", strerror(ret));
  }

  sem_post(&VisualCortex::GetInstance()->startframeFileSemaphore);
  Timeout timeoutScatterbrain = Timeout_Create();
  Timeout timeoutLedScatterbrain = Timeout_Create();
  Timeout timeoutSomethingProtectInToOut = Timeout_Create();
  Timeout timeoutSomethingProtectOutToIn = Timeout_Create();
  Timeout timeoutForceCollectCard = Timeout_Create();

  unsigned mainLoopTime = Util_GetMicroseconds();
  while (isRunning) {
    uint32_t timeInit = 0, timeValidation = 0, timeFrame = 0, timeContoursAndObjects = 0, timeGetPerson = 0,
             timeDrawPerson = 0, timeWriteInfo = 0, timeShow = 0, timeSave = 0, timeWaitKey = 0,
             timeRemainingRoutines = 0;
    uint32_t totalTimeLoop = Util_GetMicroseconds();
    timeInit = totalTimeLoop;

    int curDay = Util_GetStructTm_LocalTime_Milliseconds(Util_GetMilliseconds()).tm_yday;
    // test if pass the day
    if (_currentDay != curDay) {
      LOG_F(WARNING, "Old day: %d | New day: %d", _currentDay, curDay);
      _currentDay = curDay;
      if (!_isLogFilesDisabled) {
        InfoLog_CreateNewLog();
        LOG_F(INFO, "================================================================================================");
        MiscellaneousNetworkOperations::GetInstance()->LoadNetworkConfigurations(ip_file);
        LOG_F(INFO, "================================================================================================");
        actionModule_xmlPrint();
        LOG_F(INFO, "================================================================================================");
      }
      // set have cleaned the current day
      actionModule_eventCleanDayCounter();
      // set can show the monitor error.
      infoMonitor_canShowError();
      NightMode::GetInstance()->UpdateTimeToNightMode();
    }

    Pictogram::GetInstance()->Update();
    NightMode::GetInstance()->Update();
    _checkSpaceHd = VerificaMemoriaLivre(output_directory.c_str());
    _checkTotalSpaceHd = VerificaMemoriaTotal(output_directory.c_str());
    uint32_t percentAvailable = (_checkSpaceHd * 100) / _checkTotalSpaceHd;

    uint8_t minHardDriveSpace = actionModule_xmlGetMinHardDriveSpace();
    if (percentAvailable < minHardDriveSpace) {
      static uint32_t lastPercent = 0;
      if (lastPercent != percentAvailable) {
        LOG_F(INFO, "%u%% hardDrive available. Minimum limit: %d%%", percentAvailable, minHardDriveSpace);
        lastPercent = percentAvailable;
      }

      if (percentAvailable <= (minHardDriveSpace * 0.5)) {
        errorIndicator->SetError(ErrorIndicator::ERROR_CRITICAL_AVAILABLE_SPACE);
      }

      if (errorIndicator->GetError() == ErrorIndicator::ERROR_CRITICAL_AVAILABLE_SPACE ||
          (_bltstreamFileOpMode != BLTSTREAM_FILE_MODE_READ)) {
        LOG_IF_F(WARNING, false, "Run OldFilesDeleter");
        OldFilesDeleter::GetInstance()->Run();
      }
    } else if (errorIndicator->GetError() == ErrorIndicator::ERROR_CRITICAL_AVAILABLE_SPACE) {
      errorIndicator->CleanError(ErrorIndicator::ERROR_CRITICAL_AVAILABLE_SPACE);
    }

    DiagnosticInterface::GetInstance()->SetMainSensorTemp(VideoAnalyzer_GetMainTemperatureCam());
    DiagnosticInterface::GetInstance()->SetTempSensorLeds(VideoAnalyzer_GetTemperatureCamLeds());
    DiagnosticInterface::GetInstance()->SetCPUTemp((uint32_t)actionModule_readCpuTemperature());
    DiagnosticInterface::GetInstance()->SetPercentAvailableHD(percentAvailable);
    DiagnosticInterface::GetInstance()->SetSoftwareVersion(VERSION);

    DiagnosticInterface::GetInstance()->Update();
    if (DiagnosticInterface::GetInstance()->IsTestRunning()) {
      uint8_t angleDoorA = (DoorStatus_GetAngleDoor(DOOR_06) + DoorStatus_GetAngleDoor(DOOR_10)) / 2;
      uint8_t angleDoorB = (DoorStatus_GetAngleDoor(DOOR_07) + DoorStatus_GetAngleDoor(DOOR_11)) / 2;
      infoMonitor_setAnglePortaA(angleDoorA < DIFF_ANGLE ? 0 : angleDoorA);
      infoMonitor_setAnglePortaB(angleDoorB < DIFF_ANGLE ? 0 : angleDoorB);

      if (main_ChecksIfToCloseApp()) {
        INThandler(SIGQUIT);
      }
      usleep(100000);
      continue;
    }

    if (errorIndicator->GetError() == ErrorIndicator::ERROR_MOTOR_BOARD_COM ||
        errorIndicator->GetError() == ErrorIndicator::ERROR_CRITICAL_MOTOR_BOARD ||
        errorIndicator->GetError() == ErrorIndicator::ERROR_INVALID_READER_POSITION ||
        errorIndicator->GetError() == ErrorIndicator::ERROR_CRITICAL_AVAILABLE_SPACE) {
      if (main_ChecksIfToCloseApp()) {
        INThandler(SIGQUIT);
      }
      usleep(100000);
      continue;
    }

    // calculate the virtual button urn
    if (_virtualUrnLoop == 1u) {
      // test if the button was pressed
      _virtualButtonUrn = false;
    }
    if (_virtualUrnLoop) {
      _virtualUrnLoop--;
    }

    // New configurator
    {
      if (Configurator::GetInstance()->IsDisconnectMonitor()) {
        infoMonitor_disconnect();
      } else if (Configurator::GetInstance()->IsRestartMonitor()) {
        monitorHost = actionModule_xmlGetMonitorHost();
        monitorPort = actionModule_xmlGetMonitorPortNumber();
        monitorVersion = actionModule_xmlGetMonitorVersion();
        infoMonitor_initialize(monitorHost.c_str(), monitorPort, output_directory.c_str(), monitorVersion.c_str());
      }

      if (Configurator::GetInstance()->IsRestartSyncServerLeds()) {
        finishSyncClientModule();
        initializeSyncClientModule(frameRate);
      }
    }

    // test if are using the MCA
    if ((MCAPersonCross_MCASPGetPort() ||
         (_readers->GetSizeMCASP() && _readers->GetPortMCASP() && _readers->IsConnectedMCASP())) &&
        !restartCamera) {
      // test if dont have the MCA connection
      if (!(actionModule_getMCASPConnected() || _readers->IsClientsMCASP())) {
        if (main_ChecksIfToCloseApp()) {
          INThandler(SIGQUIT);
        }

        errorIndicator->SetError(ErrorIndicator::ERROR_MCA);
        actionModule_processActions();
        if (!_mcaAnimation) {
          IndicLum_ChangeLedAnt(false, false, MESSAGE_DELIVERY_GUARANTEE);
          actionModule_setFlagTestLedAntena(false);
        }
        _mcaAnimation = true;

        // clean all validations in actionModule
        actionModule_cleanValidationsEntranceByOccupied();
        actionModule_cleanValidationsExitByOccupied();

        // clear the persons
        VideoAnalyzer_ClearPersonWithCameraError();
        // clear all validations
        VideoAnalyzer_KillAllUserValidation(ACTIONS_ERROR_CAMERA_ENTRANCE, ACTIONS_ERROR_CAMERA_EXIT);

        /// then send the event
        if (!_mcaAnimationLOG) {
          _mcaAnimationLOG = true;
          LOG_F(ERROR, "Dont have MCA connection");

          if (actionModule_IsDflowAsValidationZone()) {
            LOG_F(WARNING, "Sends LED_TOTEM_OFF after MCA disconnection");
            vector<StateArgStruct> argsList;
            ClearLedsStripTotem(argsList);
            LedStripTotem_SetState(argsList);
          }
        }

        usleep(250000);
        continue;
      }
    }
    // test if has use the mcaAnimation
    if (_mcaAnimation) {
      errorIndicator->CleanError(ErrorIndicator::ERROR_MCA);

      // start the idle
      actionModule_startIdle(velIdle1, velIdle2, MAIN_INDIC_LUM_TAM_IDLE, arincPortNumber);
      actionModule_setFlagTestLedAntena(true);

      if (actionModule_IsDflowAsValidationZone()) {
        LOG_F(WARNING, "Sends LED_TOTEM_IDLE after MCA connection");
        vector<Reader *> readerList = _readers->GetList();
        vector<ReaderServer *> readerServerList = _readers->GetServerList();
        vector<ReaderServerPersons *> readerServerPersonsList = _readers->GetServerPersonsList();
        vector<ReaderMCASP *> MCASPServerList = MCASPServer::getMCASPList();
        vector<StateArgStruct> argsList;
        CheckReaderListToLedsStripTotemOff(readerList, argsList);
        CheckReaderServerListToLedsStripTotemOff(readerServerList, argsList);
        CheckReaderServerPersonListToLedsStripTotemOff(readerServerPersonsList, argsList);
        CheckReaderMCASPListToLedsStripTotemOff(MCASPServerList, argsList);
        LedStripTotem_FillListId(argsList);
        vector<StateArgStruct> ledsList = LedStripTotem_OrderList(argsList);
        LedStripTotem_SetState(ledsList);
      }
    }

    _mcaAnimation = false;
    _mcaAnimationLOG = false;

    if (actionModule_xmlGetEnablesCleaningMode() && CleaningMode::GetInstance()->IsRunning()) {
      CleaningMode::GetInstance()->Update();
      flagIdleSent = false;
      if (main_ChecksIfToCloseApp()) INThandler(SIGQUIT);
      usleep(10000);
      continue;
    }

    ActionManager::GetInstance()->Update();

    // test if need restart the camera connection
    if ((Configurator::GetInstance()->IsRestartVideoAnalyzer() || restartCamera) &&
        !actionModule_xmlGetBrManiaBypassMode()) {
      // clean all validations in actionModule
      actionModule_cleanValidationsEntranceByOccupied();
      actionModule_cleanValidationsExitByOccupied();
      // clear all MCA validations
      MCAPersonCross_MCASPSendErrorCameraForAllUsers();
      _readers->SendErrorCameraForAllUsersMCASP();
      // remove the validations from the ReaderPerson's
      _readers->RemoveAllPersons();

      // updates minimum area according to detection height
      minAreaHighestHeight =
          VideoAnalyzer_CalculateMinimumArea(maxHeightValue, camHeight, minAreaSensorHeight, minAreaFloor);
      minAreaLowestHeight =
          VideoAnalyzer_CalculateMinimumArea(minHeightValue, camHeight, minAreaSensorHeight, minAreaFloor);
      actionModule_xmlSetMinAreaHighestHeight(minAreaHighestHeight);
      actionModule_xmlSetMinAreaLowestHeight(minAreaLowestHeight);

      if (VideoAnalyzer_Initialize(frame, tmpBltstreamFrame, minAreaHighestHeight, minAreaLowestHeight, maxHeightValue,
                                   minHeightValue, _bltstreamFileOpMode, showWindows, percentChosenRamdomly, qtyFps,
                                   turningSimulationPercentage, MAIN_TIME_WAIT_FIRST_FRAME, minAreaSensorHeight,
                                   minAreaFloor) < 0) {
        LOG_IF_F(ERROR, STDERR_DEBUG, "Error initializing VideoAnalyzer module.");
      }
      // clean the readers update
      actionModule_cleanUpdateReaders();
    }
    _tempLed = VideoAnalyzer_GetTemperatureCamLeds();
    _tempMain = VideoAnalyzer_GetMainTemperatureCam();

    // envia a temperatura principal da camera para o monitor
    infoMonitor_setTemperSensor(_tempMain);
    // update the state
    if (errorIndicator->GetError() == ErrorIndicator::ERROR_NONE &&
        (actionModule_getChangeStateIn() || actionModule_getChangeStateOut()) &&
        (((_toggleStateOp == OP_STATE_ALL_FREE && actionModule_getStateIn() == OP_STATE_ALL_FREE &&
           actionModule_getStateOut() == OP_STATE_ALL_FREE) ||
          (_toggleStateOp == OP_STATE_COLLECT_CARD_URN && actionModule_getStateIn() == OP_STATE_CLOSED &&
           actionModule_getStateOut() == OP_STATE_CLOSED)) ||
         (_toggleStateOp != OP_STATE_ALL_FREE && _toggleStateOp != OP_STATE_COLLECT_CARD_URN)) &&
        !actionModule_xmlGetBrManiaBypassMode()) {
      // clears flag from operation state changed
      actionModule_getChangeStateIn();
      actionModule_getChangeStateOut();
      IndicLum_ChangeOpState(actionModule_getStateIn(), actionModule_getStateOut());
      IndicLum_StartIdle(1, 1, 30, true);

      VideoAnalyzer_RemoveAllValidations();
      // clean the MCA users from the list
      _readers->SendChangeStatusForAllUsersMCASP();
      // remove the validations from the ReaderPerson's
      _readers->RemoveAllPersons();
    }

    int timeRunning = tempoRodando.GetElapsed() / 1000;

    // calculate errorTime to blink the leds
    if ((cvGetTickCount() - _errorTime) > _errorLimit) {
      _errorTime = cvGetTickCount();
      if (_errorRed) {
        _errorRed = 0u;
      } else {
        _errorRed = 255u;
      }
    }

    // test if need start indiclum
    if (_needStartIndiclum || IndicLum_NeedRestartIndiclum()) {
      if (IndicLum_Initialize((char *)typeConvLeds.c_str(), (char *)descriptor_stripLeds.c_str(), flagStatusIO,
                              stripTopSize, stripFrontSize, stripBackSize, stripLedAnt, stripLedBlink, stripLed2D,
                              actionModule_xmlGetBrManiaEnable()) == true) {
        LOG_F(INFO, "IndicLum module initialized successfully");

        if (actionModule_getVersionControlBoard() < CONTROL_BOARD_VERSION_2_00) {
          LOG_F(ERROR, "Disable Check Status Doors. Version of the control board below 2.00");
          actionModule_cleanCheckStatusDoors();
        } else if (actionModule_getVersionControlBoard() >= CONTROL_BOARD_VERSION_2_00) {
          LOG_F(INFO, "Waiting control board internal communication with doors");
          Timeout tmpTime = Timeout_Create();
          Timeout_Start(tmpTime, 4000);
          do {
            IndicLum_CheckDoorsPerformed(MESSAGE_DELIVERY_GUARANTEE);
            Timeout_Delay(100);
          } while ((!Timeout_Check(tmpTime)) && (!actionModule_getDoorsPerformed()));
          Timeout_Destroy(tmpTime);
          if (actionModule_getDoorsPerformed()) {
            LOG_F(INFO, "Control board internal communication with doors ended");
          } else {
            LOG_F(ERROR, "Control board internal communication with doors timed out");
          }
        }

        if ((IndicLum_GetCheckVersionControlBoard()) &&
            (actionModule_getVersionControlBoard() >= CONTROL_BOARD_VERSION_2_00)) {
          if (actionModule_getCheckStatusDoors()) {
            IndicLum_SetCheckStatusDoors(LEVEL_STATUS_DOOR_WITHOUT_VERSION, MESSAGE_DELIVERY_GUARANTEE);
          } else {
            IndicLum_SetCheckStatusDoors(LEVEL_STATUS_DOOR_OFF, MESSAGE_DELIVERY_GUARANTEE);
          }
          usleep(200000);
        }
      } else {
        LOG_F(ERROR, "Error initializing the IndicLum module");
        actionModule_setFlagUpdateControlBoard(false);
        actionModule_setFlagUpdateMotorBoard(false);
      }

      IndicLum_ChangeOpState(actionModule_getStateIn(), actionModule_getStateOut());
      _needStartIndiclum = false;
      _flagGetStatusButtonUrn = false;
    }

    pthread_mutex_lock(&_validationMutex);
    OperationalState tmpflagToggleStateOp = _toggleStateOp;
    pthread_mutex_unlock(&_validationMutex);
    timeInit = Util_GetMicroseconds() - timeInit;

    if (!_flagPause || (_flagPause && _flagStep)) {
      timeValidation = Util_GetMicroseconds();
      long int timeBetweenFrames = 0;
      std::vector<ContoursInfo> contours;

      std::vector<DrawObjectStruct> newObjectList;
      bool newValidationAvailableEntrance = false;
      bool newValidationAvailableExit = false;
      bool tmp_validationEntrance = false;
      bool tmp_validationExit = false;
      bool flagWriteFrameFiles = false;
      bool flagDeleteLastFile = false;
      bool offlineValidationEntrance = false;
      bool offlineValidationExit = false;
      int localUserIdEntrance = -1;
      int localUserIdExit = -1;
      int localGroupIdEntrance = -1;
      int localGroupIdExit = -1;
      ValidationInterface localValidationInterfaceEntrance = VALIDATION_INTERFACE_NULL;
      ValidationInterface localValidationInterfaceExit = VALIDATION_INTERFACE_NULL;
      std::string localValidationStringEntrance = "";
      std::string localValidationStringExit = "";
      std::vector<Rect> protectionAreas;

      if (timeSchedule && (timeRunning >= timeSchedule)) {
        LOG_F(INFO, "Reached the stipulated time of %d s (%d s), closing", timeSchedule, timeRunning);
        INThandler(SIGQUIT);
      }

      // Verifica flag para solicitar status das portas
      if (actionModule_getCheckStatusDoors()) {
        // update door status
        DoorStatus_Update();
      }

      DoorCtrl_SetDoorSpeedIn(actionModule_xmlGetMaxDoorsMovSpeed());
      DoorCtrl_SetDoorSpeedOut(actionModule_xmlGetMaxDoorsMovSpeed());

      VideoAnalyzer_CheckTimeoutValidations();

      // validate persons
      if (actionModule_xmlGetFlagAccumulateCredits()) {
        // Verifica se existe validação na entrada
        ReaderStartReadingEntrance();
        tmp_validationEntrance = GetNewValidationEntrance(
            localUserIdEntrance, localGroupIdEntrance, localValidationInterfaceEntrance, localValidationStringEntrance);
        if ((tmp_validationEntrance) && (localUserIdEntrance != -1))
          newValidationAvailableEntrance = true;
        else {
          tmp_validationEntrance = actionModule_getNewValidationEntrance(
              offlineValidationEntrance, localUserIdEntrance, localGroupIdEntrance, localValidationInterfaceEntrance,
              localValidationStringEntrance);
          if ((tmp_validationEntrance) && (localUserIdEntrance != -1))
            newValidationAvailableEntrance = true;
          else {
            // else test if have the MCA validation
            if (MCAPersonCross_HavePersonEntranceReceived()) {
              // get the person
              _person = MCA_getPersonReceived();
              // add validation
              if (strlen(_person.id)) {
                localUserIdEntrance = _idCountEntrance++;
                localGroupIdEntrance = _person.group;
                localValidationInterfaceEntrance = VALIDATION_INTERFACE_CARD;
                localValidationStringEntrance = "MCA_";
                localValidationStringEntrance += _person.id;
                newValidationAvailableEntrance = true;
              }
            } else {
              if (MCAPersonCross_MCASPHavePersonEntranceReceived()) {
                // get the person
                _personSP = MCAPersonCross_MCASPGetPersonReceived();
                // add validation
                if (seguranca::MCASPPersonList::validateId((const char *)_personSP.str, sizeof(_personSP.str))) {
                  localUserIdEntrance = _idCountEntrance++;
                  mcasp_getColorRGB(MCAPersonCross_MCASPGetPersonColorById((const char *)_personSP.str), &_spR, &_spG,
                                    &_spB);
                  localGroupIdEntrance = IdentificationRegister_GetGroupByColor(_spR, _spG, _spB);
                  localValidationInterfaceEntrance = VALIDATION_INTERFACE_CARD;
                  localValidationStringEntrance = "MCASP_";
                  // convert the ID to string
                  MCAPersonCross_Char23ToStrHexa(_personSP.str, &_strSP);
                  localValidationStringEntrance += _strSP;
                  newValidationAvailableEntrance = true;
                }
              }
            }
          }
        }

        // Verifica se existe validação na saída
        ReaderStartReadingExit();
        tmp_validationExit = GetNewValidationExit(localUserIdExit, localGroupIdExit, localValidationInterfaceExit,
                                                  localValidationStringExit);

        if ((tmp_validationExit) && (localUserIdExit != -1)) {
          newValidationAvailableExit = true;
        } else {
          tmp_validationExit =
              actionModule_getNewValidationExit(offlineValidationExit, localUserIdExit, localGroupIdExit,
                                                localValidationInterfaceExit, localValidationStringExit);

          if ((tmp_validationExit) && (localUserIdExit != -1)) {
            newValidationAvailableExit = true;
          } else {
            // else test if have the MCA validation
            if (MCAPersonCross_HavePersonExitReceived()) {
              // get the person
              _person = MCA_getPersonReceived();
              if (strlen(_person.id)) {
                // add validation
                localUserIdExit = _idCountExit++;
                localGroupIdExit = _person.group;
                localValidationInterfaceExit = VALIDATION_INTERFACE_CARD;
                localValidationStringExit = "MCA_";
                localValidationStringExit += _person.id;
                newValidationAvailableExit = true;
              }
            } else {
              if (MCAPersonCross_MCASPHavePersonExitReceived()) {
                // get the person
                _personSP = MCAPersonCross_MCASPGetPersonReceived();
                // add validation
                if (seguranca::MCASPPersonList::validateId((const char *)_personSP.str, sizeof(_personSP.str))) {
                  localUserIdExit = _idCountExit++;
                  mcasp_getColorRGB(MCAPersonCross_MCASPGetPersonColorById((const char *)_personSP.str), &_spR, &_spG,
                                    &_spB);
                  localGroupIdExit = IdentificationRegister_GetGroupByColor(_spR, _spG, _spB);
                  localValidationInterfaceExit = VALIDATION_INTERFACE_CARD;
                  localValidationStringExit = "MCASP_";
                  // convert the ID to string
                  MCAPersonCross_Char23ToStrHexa(_personSP.str, &_strSP);
                  localValidationStringExit += _strSP;
                  newValidationAvailableExit = true;
                }
              }
            }
          }
        }
      } else {
        if (!VideoAnalyzer_IsValidInviteEntrance()) {
          ReaderStartReadingEntrance();
          tmp_validationEntrance =
              GetNewValidationEntrance(localUserIdEntrance, localGroupIdEntrance, localValidationInterfaceEntrance,
                                       localValidationStringEntrance);

          if ((tmp_validationEntrance) && (localUserIdEntrance != -1)) {
            newValidationAvailableEntrance = true;
          } else {
            tmp_validationEntrance = actionModule_getNewValidationEntrance(
                offlineValidationEntrance, localUserIdEntrance, localGroupIdEntrance, localValidationInterfaceEntrance,
                localValidationStringEntrance);

            if ((tmp_validationEntrance) && (localUserIdEntrance != -1)) {
              newValidationAvailableEntrance = true;
            } else {
              // else test if have the MCA validation
              if (MCAPersonCross_HavePersonEntranceReceived()) {
                // get the person
                _person = MCA_getPersonReceived();
                if (strlen(_person.id)) {
                  // add validation
                  localUserIdEntrance = _idCountEntrance++;
                  localGroupIdEntrance = _person.group;
                  localValidationInterfaceEntrance = VALIDATION_INTERFACE_CARD;
                  localValidationStringEntrance = "MCA_";
                  localValidationStringEntrance += _person.id;
                  newValidationAvailableEntrance = true;
                }
              } else {
                if (MCAPersonCross_MCASPHavePersonEntranceReceived()) {
                  // get the person
                  _personSP = MCAPersonCross_MCASPGetPersonReceived();
                  // add validation
                  if (seguranca::MCASPPersonList::validateId((const char *)_personSP.str, sizeof(_personSP.str))) {
                    localUserIdEntrance = _idCountEntrance++;
                    mcasp_getColorRGB(MCAPersonCross_MCASPGetPersonColorById((const char *)_personSP.str), &_spR, &_spG,
                                      &_spB);
                    localGroupIdEntrance = IdentificationRegister_GetGroupByColor(_spR, _spG, _spB);
                    localValidationInterfaceEntrance = VALIDATION_INTERFACE_CARD;
                    localValidationStringEntrance = "MCASP_";
                    // convert the ID to string
                    MCAPersonCross_Char23ToStrHexa(_personSP.str, &_strSP);
                    localValidationStringEntrance += _strSP;
                    newValidationAvailableEntrance = true;
                  }
                }
              }
            }
          }
        } else {
          pthread_mutex_lock(&_validationMutex);
          _flagStartReaderEntrance = false;
          // else remove the next person and send a error message
          if (MCAPersonCross_HavePersonEntranceReceived()) {
            _person = MCA_getPersonReceived();
            if (strlen(_person.id)) {
              // send the error message
              MCAPersonCross_SendErrorValidationById(_person.id);
            }
          }
          // test if have the person from MCASP
          if (MCAPersonCross_MCASPHavePersonEntranceReceived()) {
            // get the person
            _personSP = MCAPersonCross_MCASPGetPersonReceived();
            // add validation
            if (seguranca::MCASPPersonList::validateId((const char *)_personSP.str, sizeof(_personSP.str))) {
              MCAPersonCross_MCASPSendErrorOccupiedById((const char *)_personSP.str);
            }
          }
          // clean all validations in actionModule
          actionModule_cleanValidationsEntranceByOccupied();
          pthread_mutex_unlock(&_validationMutex);
        }

        if (!VideoAnalyzer_IsValidInviteExit()) {
          ReaderStartReadingExit();
          tmp_validationExit = GetNewValidationExit(localUserIdExit, localGroupIdExit, localValidationInterfaceExit,
                                                    localValidationStringExit);
          if ((tmp_validationExit) && (localUserIdExit != -1)) {
            newValidationAvailableExit = true;
          } else {
            tmp_validationExit =
                actionModule_getNewValidationExit(offlineValidationExit, localUserIdExit, localGroupIdExit,
                                                  localValidationInterfaceExit, localValidationStringExit);
            if ((tmp_validationExit) && (localUserIdExit != -1)) {
              newValidationAvailableExit = true;
            } else {
              // else test if have the MCA validation
              if (MCAPersonCross_HavePersonExitReceived()) {
                // get the person
                _person = MCA_getPersonReceived();
                if (strlen(_person.id)) {
                  // add validation
                  localUserIdExit = _idCountExit++;
                  localGroupIdExit = _person.group;
                  localValidationInterfaceExit = VALIDATION_INTERFACE_CARD;
                  localValidationStringExit = "MCA_";
                  localValidationStringExit += _person.id;
                  newValidationAvailableExit = true;
                }
              } else {
                if (MCAPersonCross_MCASPHavePersonExitReceived()) {
                  // get the person
                  _personSP = MCAPersonCross_MCASPGetPersonReceived();
                  // add validation
                  if (seguranca::MCASPPersonList::validateId((const char *)_personSP.str, sizeof(_personSP.str))) {
                    localUserIdExit = _idCountExit++;
                    mcasp_getColorRGB(MCAPersonCross_MCASPGetPersonColorById((const char *)_personSP.str), &_spR, &_spG,
                                      &_spB);
                    localGroupIdExit = IdentificationRegister_GetGroupByColor(_spR, _spG, _spB);
                    localValidationInterfaceExit = VALIDATION_INTERFACE_CARD;
                    localValidationStringExit = "MCASP_";
                    // convert the ID to string
                    MCAPersonCross_Char23ToStrHexa(_personSP.str, &_strSP);
                    localValidationStringExit += _strSP;
                    newValidationAvailableExit = true;
                  }
                }
              }
            }
          }
        } else {
          pthread_mutex_lock(&_validationMutex);
          _flagStartReaderExit = false;
          // else remove the next person and send a error message
          if (MCAPersonCross_HavePersonExitReceived()) {
            _person = MCA_getPersonReceived();

            if (strlen(_person.id)) {
              // send the error message
              MCAPersonCross_SendErrorValidationById(_person.id);
            }
          }
          // test if have the person from MCASP
          if (MCAPersonCross_MCASPHavePersonExitReceived()) {
            // get the person
            _personSP = MCAPersonCross_MCASPGetPersonReceived();
            // add validation
            if (seguranca::MCASPPersonList::validateId((const char *)_personSP.str, sizeof(_personSP.str))) {
              MCAPersonCross_MCASPSendErrorOccupiedById((const char *)_personSP.str);
            }
          }
          // clean all validations in actionModule
          actionModule_cleanValidationsExitByOccupied();
          pthread_mutex_unlock(&_validationMutex);
        }
      }

      // Check and add new validations
      if (newValidationAvailableEntrance) {
        if (actionModule_getStateIn() == OP_STATE_CONTROLED && tmpflagToggleStateOp != OP_STATE_FIRE_ALARM &&
            tmpflagToggleStateOp != OP_STATE_COLLECT_CARD_URN && tmpflagToggleStateOp != OP_STATE_ALL_FREE) {
          if (!actionModule_xmlGetBrManiaBypassMode()) {
            ReaderPositionValidationInfo readerPosition;
            ValidationStructure validation(
                true, 0, localGroupIdEntrance, (localUserIdEntrance < 0) ? 0 : localUserIdEntrance,
                VALIDATION_TYPE_INVITE, localValidationInterfaceEntrance, localValidationStringEntrance,
                VALIDATION_WAY_IN_OUT, offlineValidationEntrance, Util_GetMilliseconds_Monotonic(), readerPosition);
            _validateMCA = VideoAnalyzer_AddValidation(validation, true);
          } else {
            DtowerBoard::ValidationStruct validation;
            validation.timeValidation = Util_GetMilliseconds();
            validation.validationId = localUserIdEntrance;
            validation.groupId = localGroupIdEntrance;
            validation.identification = localValidationStringEntrance;
            validation.validationInterface = localValidationInterfaceEntrance;
            validation.way = DtowerBoard::ENTRANCE;
            validation.sent = false;
            _validateMCA = DtowerBoard::GetInstance()->NewValidation(validation);
          }
        } else {
          _validateMCA = false;
          IndicLum_SetBuzzer(actionModule_xmlGetBuzzerTimeRefuseValidation(), 0, 0, MESSAGE_DELIVERY_GUARANTEE);
          // remove the validation from the ReaderPerson's
          _readers->RemovePerson(localValidationStringEntrance.c_str());
        }

        if (!_validateMCA) {
          // remove the validation from the ReaderPerson's
          _readers->RemovePerson(localValidationStringEntrance.c_str());
          //
          char *identification = (char *)localValidationStringEntrance.c_str();
          // test if it's MCASP
          if (_readers->ValidateUserStringMCASP(identification)) {
            // send the error for the MCASP
            _readers->SendErrorValidationMCASP(identification);
          } else if (identification)  // test if it's MCA
          {
            // test if the string are from MCA
            if (identification[0u] == 'M') {
              if (identification[1u] == 'C') {
                if (identification[2u] == 'A') {
                  if (identification[3u] == '_') {
                    if (identification[4u]) {
                      // convert the string to MCA ID
                      MCAPersonCross_SendErrorValidationById((const char *)&identification[4u]);
                    }
                  } else if (identification[3u] == 'S') {
                    if (identification[4u] == 'P') {
                      if (identification[5u] == '_') {
                        if (identification[6u]) {
                          // convert the string to MCA ID
                          MCAPersonCross_StrHexaToChar23((const char *)&identification[6u], _idSP);
                          MCAPersonCross_MCASPSendErrorOccupiedById((const char *)_idSP);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      if (newValidationAvailableExit) {
        if (actionModule_getStateOut() == OP_STATE_CONTROLED && tmpflagToggleStateOp != OP_STATE_FIRE_ALARM &&
            tmpflagToggleStateOp != OP_STATE_COLLECT_CARD_URN && tmpflagToggleStateOp != OP_STATE_ALL_FREE) {
          if (!actionModule_xmlGetBrManiaBypassMode()) {
            ReaderPositionValidationInfo readerPosition;
            ValidationStructure validation(true, 0, localGroupIdExit, (localUserIdExit < 0) ? 0 : localUserIdExit,
                                           VALIDATION_TYPE_INVITE, localValidationInterfaceExit,
                                           localValidationStringExit, VALIDATION_WAY_OUT_IN, offlineValidationExit,
                                           Util_GetMilliseconds_Monotonic(), readerPosition);
            _validateMCA = VideoAnalyzer_AddValidation(validation, true);
          } else {
            DtowerBoard::ValidationStruct validation;
            validation.timeValidation = Util_GetMilliseconds();
            validation.validationId = localUserIdExit;
            validation.groupId = localGroupIdExit;
            validation.identification = localValidationStringExit;
            validation.validationInterface = (ValidationInterface)localValidationInterfaceExit;
            validation.way = DtowerBoard::EXIT;
            validation.sent = false;
            _validateMCA = DtowerBoard::GetInstance()->NewValidation(validation);
          }
        } else {
          _validateMCA = false;
          IndicLum_SetBuzzer(actionModule_xmlGetBuzzerTimeRefuseValidation(), 0, 0, MESSAGE_DELIVERY_GUARANTEE);
          // remove the validation from the ReaderPerson's
          _readers->RemovePerson(localValidationStringEntrance.c_str());
        }

        if (!_validateMCA) {
          // remove the validation from the ReaderPerson's
          _readers->RemovePerson(localValidationStringEntrance.c_str());
          //
          char *identification = (char *)localValidationStringExit.c_str();
          // test if it's MCASP
          if (_readers->ValidateUserStringMCASP(identification)) {
            // send the error for the MCASP
            _readers->SendErrorValidationMCASP(identification);
          } else if (identification)  // test if it's MCA
          {
            // test if the string are from MCA
            if (identification[0u] == 'M') {
              if (identification[1u] == 'C') {
                if (identification[2u] == 'A') {
                  if (identification[3u] == '_') {
                    if (identification[4u]) {
                      // convert the string to MCA ID
                      MCAPersonCross_SendErrorValidationById((const char *)&identification[4u]);
                    }
                  } else if (identification[3u] == 'S') {
                    if (identification[4u] == 'P') {
                      if (identification[5u] == '_') {
                        if (identification[6u]) {
                          // convert the string to MCA ID
                          MCAPersonCross_StrHexaToChar23((const char *)&identification[6u], _idSP);
                          MCAPersonCross_MCASPSendErrorOccupiedById((const char *)_idSP);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      if (actionModule_xmlGetBrManiaEnable() && actionModule_xmlGetBrManiaBypassMode()) {
        DtowerBoard::GetInstance()->Update();
        usleep((1000 / frameRate) * 1000);
      }

      timeFrame = Util_GetMicroseconds();
      timeValidation = timeFrame - timeValidation;

      // Get frame
      int tmpRetGetFrame = 0;
      // test if are not using the demoMode
      if (!actionModule_xmlGetBrManiaBypassMode()) {
        if ((tmpRetGetFrame = VideoAnalyzer_GetFrame(frame, imgFrame, tmpBltstreamFrame, _flagBackward,
                                                     accelerationFrame, timeoutGetFrame)) < 0) {
          if (tmpRetGetFrame == -2) {
            frameOrig.release();
            imgFrameOrig.release();
            videoAnalyzer_deallocateFrames();
            INThandler(SIGQUIT);
          }

          haveFrame = false;

          if (timeoutNewFrame.Check()) {
            // reset the camera connection
            LOG_F(INFO, "The sensor will be reset. The time limit for receiving frames has been exceeded.");
            restartCamera = true;
            contours.clear();
            newObjectList.clear();
            VideoAnalyzer_ClearPersonWithCameraError();
            VideoAnalyzer_KillAllUserValidation(ACTIONS_ERROR_CAMERA_ENTRANCE, ACTIONS_ERROR_CAMERA_EXIT);
            MCAPersonCross_MCASPSendErrorCameraForAllUsers();
            _readers->SendErrorCameraForAllUsersMCASP();
            _readers->RemoveAllPersons();

            if (errorIndicator->GetError() == ErrorIndicator::ERROR_NONE) {
              IndicLum_ChangeLedAnt(false, false, MESSAGE_DELIVERY_GUARANTEE);
              actionModule_setFlagTestLedAntena(false);

              if (actionModule_getUsingSita() || actionModule_xmlGetScafisDflowPort()) {
                LOG_IF_F(1, STDERR_DEBUG, "Send: TEHS");
                EventControlSita_Set(TEHS);
              }
            }

            errorIndicator->SetError(ErrorIndicator::ERROR_SENSOR);
            actionModule_processActions();

            if ((actionModule_xmlGetOpModeDoor() == DOOR_MODE_BIDIRECTIONAL_OPEN) ||
                (actionModule_xmlGetOpModeDoor() == DOOR_MODE_DECENTRALIZED_OPEN)) {
              DoorCtrl_CloseInDoorPercentage(0);
              DoorCtrl_CloseOutDoorPercentage(0);
              IndicLum_ShowWindowsMemDoors(OperationalState::OP_STATE_FREE, OperationalState::OP_STATE_FREE, 0, 0, 0, 0,
                                           true, true);
            } else if ((actionModule_xmlGetOpModeDoor() == DOOR_MODE_CENTRALIZED_CLOSED) ||
                       (actionModule_xmlGetOpModeDoor() == DOOR_MODE_DECENTRALIZED_CLOSED)) {
              DoorCtrl_CloseInDoorPercentage(100);
              DoorCtrl_CloseOutDoorPercentage(100);
              IndicLum_ShowWindowsMemDoors(OperationalState::OP_STATE_FREE, OperationalState::OP_STATE_FREE, 0, 90, 0,
                                           90, true, true);
            }
          }

          if (main_ChecksIfToCloseApp()) {
            INThandler(SIGQUIT);
          }
          usleep(100);
          continue;
        } else {
          restartCamera = false;

          if (errorIndicator->GetError() == ErrorIndicator::ERROR_SENSOR) {
            errorIndicator->CleanError(ErrorIndicator::ERROR_SENSOR);
            // stop the error animation
            actionModule_stopErrorAnimation();
            actionModule_setFlagTestLedAntena(true);
          }

          haveFrame = true;
          timeoutNewFrame.Start(MAIN_WAIT_CAMERA_FRAME);

          _flagStep = false;
          tTmpImage = (double)cvGetTickCount();
          tGetImage[fpsAvgCount++] = static_cast<int>((tTmpImage - tAntImage) / cvGetTickFrequency());
          tAntImage = tTmpImage;  //
          if (fpsAvgCount == FPS_AVERAGE) {
            fpsAvgCount = 0;
            flagEnoughForAverage = true;
          }
          _fpsAverage = 0.0;
          for (int tmpContAverage = 0; tmpContAverage < FPS_AVERAGE; tmpContAverage++) {
            _fpsAverage += tGetImage[tmpContAverage];
          }

          _fpsAverage = (1000000 * FPS_AVERAGE) / _fpsAverage;
          if (_fpsAverage < 0) _fpsAverage = std::numeric_limits<double>::min();
          actionModule_SetFpsAverage(_fpsAverage);
        }
      } else {
        haveFrame = false;
        frame.create(frame.cols, frame.rows, CV_8UC3);
        imgFrame = frame;
        tmpRetGetFrame++;
      }

      _flagBackward = false;

      // test if have a cameraFrame
      if (haveFrame) {
        // Copy to save frame
        frameOrig = frame.clone();
        imgFrameOrig = imgFrame.clone();
        frame = VideoAnalyzer_CutFrame(frameOrig);
        VideoAnalyzer_SetBmpFrameToAI(imgFrameOrig);
        VideoAnalyzer_SaveImageToPath(frameOrig, actionModule_GetPathTrackingImage(
                                                     ns2__TrackingImageEnumType__DISTANCE_USCOREWITH_USCOREFILTERS));

        // Find motion
        timeContoursAndObjects = Util_GetMicroseconds();
        timeFrame = timeContoursAndObjects - timeFrame;
        float pictureQuality = 0.0;
        contours = VideoAnalyzer_FindContours(frame, &pictureQuality, protectionAreas);
        _flagUpdateBackground = false;
        // Media da qualidade da imagem
        {
          static float avgPictureQuality[MAIN_PICTURE_QUALITY_AVERAGE] = {0.0};
          static uint16_t pictureQualityAvgCounter = 0;
          avgPictureQuality[pictureQualityAvgCounter++] = pictureQuality;
          if (pictureQualityAvgCounter >= MAIN_PICTURE_QUALITY_AVERAGE) pictureQualityAvgCounter = 0;
          _avgPictureQuality = 0;
          for (uint16_t tmpCont = 0; tmpCont < MAIN_PICTURE_QUALITY_AVERAGE; tmpCont++) {
            _avgPictureQuality += avgPictureQuality[tmpCont];
          }
          _avgPictureQuality = _avgPictureQuality / MAIN_PICTURE_QUALITY_AVERAGE;
          LOG_IF_F(1, STDERR_DEBUG, "_avgPictureQuality: %2.2f%%", _avgPictureQuality);
        }

        // protectionAreas = VideoAnalyzer_GetProtectionAreas(frame, ImageCalibration::GetInstance()->GetCalibration());
        if (contours.size()) newObjectList = VideoAnalyzer_GetObjects(contours);
      } else {
        // test if are NOT using the demoMode
        if (!actionModule_xmlGetBrManiaBypassMode()) {
          // if have NOT. Print the old frame
          frame = VideoAnalyzer_CutFrame(frameOrig);
          imgFrame = imgFrameOrig.clone();
        }
      }

      frameAfterFilters = frame.clone();

      timeGetPerson = Util_GetMicroseconds();
      timeContoursAndObjects = timeGetPerson - timeContoursAndObjects;

      // Frame file manager
      if (haveFrame &&
          (newObjectList.size() || _forceSaveFrames ||
           ((VisualCortex::GetInstance()->GetBrainConnected() || VisualCortex::GetInstance()->GetReprocMode()) &&
            (VisualCortex::GetInstance()->IsThereSomeoneInsideCad() ||
             VisualCortex::GetInstance()->IsPersonWithoutVolumeFraud())))) {
        _contFrames++;
        flagWriteFrameFiles = true;
        if ((_contFrames > minAmountFrameSaveFiles) && flagWriteVideoOutput) {
          actionModule_eventVideoRecording();
        }

        // test if need create a new file
        if (_contFrames > maxAmountFrameSaveFiles) {
          // force to create new video files
          Bltstream::GetInstance()->ForceCreateNewFile();
          VideoOutput_ForceCreateNewFile();

          // clean frames to continue writing the frames without delete the file
          _contFrames = minAmountFrameSaveFiles;
          // set the masFrameSaveFiles to increase the minAmountFrameSaveFiles
          maxAmountFrameSaveFiles = MAIN_MAX_FRAME_SAVE_FILES + minAmountFrameSaveFiles;
        }
      } else {
        if ((_contFrames > 0) && (_contFrames <= minAmountFrameSaveFiles)) {
          flagDeleteLastFile = true;
        }

        _contFrames = 0;
        // clean the maxFrameSaveFiles
        maxAmountFrameSaveFiles = MAIN_MAX_FRAME_SAVE_FILES;
      }

      if (!actionModule_xmlGetBrManiaBypassMode()) {
        if (true) {
          // test if are running scanner
          if (actionModule_runningScan()) {
            VideoAnalyzer_Scan(newObjectList);
          } else {
            if ((tmpflagToggleStateOp != OP_STATE_FIRE_ALARM) && (tmpflagToggleStateOp != OP_STATE_ALL_FREE) &&
                (tmpflagToggleStateOp != OP_STATE_COLLECT_CARD_URN) &&
                (actionModule_getOpModeDoor() != DOOR_MODE_ALW_CLOSED)) {
              VideoAnalyzer_GetPersons(newObjectList, protectionAreas);

              // Captures images of each tracked and saved object to create a data model used by the neural network
              if (_snapShotAutoSave == true) {
                VideoAnalyzer_AutoSaveSnapshots(imgFrameOrig);
              }
              if (VideoAnalyzer_SomeoneValidInToOut() || VideoAnalyzer_SomeoneValidOutToIn()) {
                VideoAnalyzer_SetAtLeastOnePersonValidated(true);
              } else {
                VideoAnalyzer_SetAtLeastOnePersonValidated(false);
              }

              if (actionModule_GetSoapEnable() ||
                  (actionModule_GetRestServerEnable() || actionModule_GetRestClientEnable())) {
                if (actionModule_GetSoapEnable()) {
                  if (_bltstreamFileOpMode != BLTSTREAM_FILE_MODE_READ) {
                    SoapPictogramController::GetInstance()->Update();
                    SoapNotificationLightController::GetInstance()->Update();
                  }
                }

                VideoAnalyzer_TailgatingCheck();
                VideoAnalyzer_LoiteringCheck();
                VideoAnalyzer_PaxMovementCheck();
              }
            }

            bool isPersonDetected =
                ((VisualCortex::GetInstance()->GetBrainConnected() || VisualCortex::GetInstance()->GetReprocMode()) &&
                 (VisualCortex::GetInstance()->IsThereSomeoneInsideCad() ||
                  VisualCortex::GetInstance()->IsPersonWithoutVolumeFraud()));

            if (!videoAnalyzer_exceeded && !contours.size() && !isPersonDetected &&
                TestHardware::TEST_LIGHTS != TestHardware::GetInstance()->GetTest()) {
              if (actionModule_getUseChangeModeOpCam()) {
                // Alterna para o modo ENERGY_SAVING quando nao detecta nenhum objeto
                actionModule_changeModeOpCam(ENERGY_SAVING_MODE, bloqID);
              }

              NightMode::GetInstance()->ForcedNightModeDisabled(false);
            }

            if (DoorsFraudCheck::GetInstance()->IsFraud()) {
              videoAnalyzer_exceeded = true;
            }

            static bool flag_lockDoors = false;

            if ((videoAnalyzer_exceeded) &&
                actionModule_getSOAPStatus() == ns2__StatusEnumType::ns2__StatusEnumType__ACTIVE &&
                ((VideoAnalyzer_FraudulentPersonDetection() && actionModule_getOpModeDoor() != DOOR_MODE_ALW_OPEN &&
                  actionModule_getOpModeDoor() != DOOR_MODE_ALW_OPEN_EXIT) ||
                 (!VideoAnalyzer_FraudulentPersonDetection()))) {
              if (VideoAnalyzer_IsValidInviteEntrance() || VideoAnalyzer_IsValidInviteExit()) {
                VideoAnalyzer_ValidationWaitingCleanTimeoutUser();
              }

              IndicLum_ClearMemDoor();

              if (!flag_lockDoors) {
                uint8_t setDoor = 0;

                if (actionModule_xmlGetFlagInvitationLights() && typeInvitationLights == 0) {
                  IndicLum_SetInvitationLights(false, 0, 0, 0, 0, false, 0, 0, 0, 0, 0, 0, MESSAGE_PRIORITY);
                }

                IndicLum_ChangeLedAnt(false, false, MESSAGE_DELIVERY_GUARANTEE);
                actionModule_setFlagTestLedAntena(false);

                if (VideoAnalyzer_FraudulentPersonDetection()) {
                  soapDFlow_addEventToSend(ns2__EventEnumType__SPOOFING_USCOREDETECTED);
                }

                if (actionModule_xmlGetOpModeDoor() == DOOR_MODE_CENTRALIZED_CLOSED ||
                    actionModule_xmlGetOpModeDoor() == DOOR_MODE_DECENTRALIZED_CLOSED ||
                    actionModule_xmlGetOpModeDoor() == DOOR_MODE_DECENTRALIZED_OPEN ||
                    (actionModule_xmlGetOpModeDoor() == DOOR_MODE_BIDIRECTIONAL_OPEN &&
                     (actionModule_getStateOut() == OperationalState::OP_STATE_CLOSED ||
                      actionModule_getStateOut() == OperationalState::OP_STATE_FREE))) {
                  setDoor = DOOR_ENTRANCE;
                } else if (VideoAnalyzer_GetDoorIntense(DoorActivation::DOOR_ENT)) {
                  setDoor = DOOR_ENTRANCE;
                } else if (VideoAnalyzer_GetDoorIntense(DoorActivation::DOOR_EXT)) {
                  setDoor = DOOR_EXIT;
                } else if (!setDoor) {
                  setDoor = VideoAnalyzer_CheckDoorRun();
                }

                flag_lockDoors = true;
                bool closeDoorEntrance = false;
                bool closeDoorExit = false;
                if (setDoor == DOOR_EXIT) {
                  closeDoorExit = true;
                  if (!DoorsFraudCheck::GetInstance()->IsFraud()) {
                    LOG_F(INFO, "Triggers fraud relay: RELAY_OUT");
                    IndicLum_SetFraudRelay(RELAY_OUT, actionModule_xmlGetTimeFraudRelay());
                  }
                } else {
                  closeDoorEntrance = true;
                  if (!DoorsFraudCheck::GetInstance()->IsFraud()) {
                    LOG_F(INFO, "Triggers fraud relay: RELAY_IN");
                    IndicLum_SetFraudRelay(RELAY_IN, actionModule_xmlGetTimeFraudRelay());
                  }
                }

                if (actionModule_xmlGetOpModeDoor() == DOOR_MODE_TRAP) {
                  LOG_F(WARNING, "Fraud detected on dPass.");
                  IndicLum_ClearMemDoor();
                  uint8_t speedDoor = actionModule_xmlGetSpeedDoorPermanentlyOpenMode();
                  uint16_t angle_06 = DoorStatus_GetAngleDoor(DOOR_06);
                  uint16_t angle_07 = DoorStatus_GetAngleDoor(DOOR_07);
                  uint16_t angle_10 = DoorStatus_GetAngleDoor(DOOR_10);
                  uint16_t angle_11 = DoorStatus_GetAngleDoor(DOOR_11);
                  uint16_t angleEntry = (angle_06 + angle_10) * 0.5;
                  uint16_t angleExit = (angle_07 + angle_11) * 0.5;
                  if (angleEntry < 90 - DIFF_ANGLE) {
                    LOG_F(WARNING, "Opening entrance doors inwards.");
                    IndicLum_AddMemCommandDoor(2, CommandDoors::DOOR_OPEN_ENTRANCE, speedDoor);
                    IndicLum_AddMemCommandDoor(3, CommandDoors::DOOR_CLOSED_CENTRALIZED, 50);
                  } else if (angleEntry > 90 + DIFF_ANGLE) {
                    LOG_F(WARNING, "Opening entrance doors outwards.");
                    IndicLum_AddMemCommandDoor(2, CommandDoors::DOOR_OPEN_EXIT, speedDoor);
                    IndicLum_AddMemCommandDoor(3, CommandDoors::DOOR_CLOSED_CENTRALIZED, 50);
                  } else if (angleExit < 90 - DIFF_ANGLE) {
                    LOG_F(WARNING, "Opening exit doors inwards.");
                    IndicLum_AddMemCommandDoor(3, CommandDoors::DOOR_OPEN_ENTRANCE, speedDoor);
                    IndicLum_AddMemCommandDoor(2, CommandDoors::DOOR_CLOSED_CENTRALIZED, 50);
                  } else if (angleExit > 90 + DIFF_ANGLE) {
                    LOG_F(WARNING, "Opening exit doors outwards.");
                    IndicLum_AddMemCommandDoor(3, CommandDoors::DOOR_OPEN_EXIT, speedDoor);
                    IndicLum_AddMemCommandDoor(2, CommandDoors::DOOR_CLOSED_CENTRALIZED, 50);
                  } else {
                    if ((actionModule_getStateIn() == OP_STATE_CONTROLED) &&
                        (actionModule_getStateOut() == OP_STATE_CLOSED)) {
                      IndicLum_AddMemCommandDoor(2, CommandDoors::DOOR_OPEN_EXIT, speedDoor);
                      IndicLum_AddMemCommandDoor(3, CommandDoors::DOOR_CLOSED_CENTRALIZED, 50);
                      LOG_F(WARNING, "Opening entrance doors outwards, as operational state.");
                    } else if ((actionModule_getStateOut() == OP_STATE_CONTROLED) &&
                               (actionModule_getStateIn() == OP_STATE_CLOSED)) {
                      LOG_F(WARNING, "Opening exit doors outwards, as operational state.");
                      IndicLum_AddMemCommandDoor(3, CommandDoors::DOOR_OPEN_EXIT, speedDoor);
                      IndicLum_AddMemCommandDoor(2, CommandDoors::DOOR_CLOSED_CENTRALIZED, 50);
                    } else {
                      LOG_F(WARNING, "Don't move doors.");
                    }
                  }

                  IndicLum_SendMessageDoorMem(MESSAGE_DELIVERY_GUARANTEE);
                  LOG_F(WARNING, "Triggers buzzer and doors");
                  IndicLum_SetBuzzer(50, 50, 50, MESSAGE_DELIVERY_GUARANTEE);
                } else {
                  if (DoorsFraudCheck::GetInstance()->GetDoorFraud()) {
                    closeDoorEntrance = false;
                    closeDoorExit = false;
                  }

                  if ((actionModule_getStateIn() == OP_STATE_FREE) && (actionModule_getStateOut() == OP_STATE_FREE)) {
                    // set leds green windows
                    IndicLum_ChangeOpState(OP_STATE_ALL_FREE, OP_STATE_ALL_FREE);

                    if (VideoAnalyzer_FraudulentPersonDetection()) {
                      IndicLum_StartIdle(velIdle1, velIdle2, MAIN_INDIC_LUM_TAM_IDLE, actionModule_getUsingArinc());
                    }
                  } else {
                    if (actionModule_getOpModeDoor() != DOOR_MODE_ALW_OPEN &&
                        actionModule_getOpModeDoor() != DOOR_MODE_ALW_OPEN_EXIT &&
                        actionModule_xmlGetOpModeDoor() != DOOR_MODE_NONE &&
                        actionModule_getSOAPStatus() !=
                            ns2__StatusEnumType::ns2__StatusEnumType__PERMANENT_USCOREOPEN &&
                        actionModule_getSOAPStatus() !=
                            ns2__StatusEnumType::ns2__StatusEnumType__PERMANENT_USCOREOPEN_USCOREENTRY_USCOREINWARD &&
                        actionModule_getSOAPStatus() !=
                            ns2__StatusEnumType::ns2__StatusEnumType__PERMANENT_USCOREOPEN_USCOREENTRY_USCOREOUTWARD &&
                        actionModule_getSOAPStatus() !=
                            ns2__StatusEnumType::ns2__StatusEnumType__PERMANENT_USCOREOPEN_USCOREEXIT_USCOREINWARD &&
                        actionModule_getSOAPStatus() !=
                            ns2__StatusEnumType::ns2__StatusEnumType__PERMANENT_USCOREOPEN_USCOREEXIT_USCOREOUTWARD &&
                        actionModule_getSOAPStatus() !=
                            ns2__StatusEnumType::ns2__StatusEnumType__PERMANENT_USCOREOPEN_USCOREBY_USCOREKEY) {
                      LOG_IF_F(1, STDERR_DEBUG, "Fecha porta devagar");
                      IndicLum_CloseDoors(closeDoorEntrance, 50, closeDoorExit, 50);
                    }

                    LOG_F(WARNING, "Triggers buzzer and doors");
                    IndicLum_SetBuzzer(50, 50, 50, MESSAGE_DELIVERY_GUARANTEE);
                  }
                }
              }

              if (!((actionModule_getStateIn() == OP_STATE_FREE) && (actionModule_getStateOut() == OP_STATE_FREE))) {
                // set the red windows
                actionModule_setWindowTop(0, 100, _errorRed, 0, 0);
                actionModule_setWindowFront(0, 100, _errorRed, 0, 0);
                actionModule_setWindowBack(0, 100, _errorRed, 0, 0);
                IndicLum_ShowWindowsMem(OP_STATE_CLOSED, OP_STATE_CLOSED);
              }
            } else if (flag_lockDoors) {
              actionModule_setFlagTestLedAntena(true);
              IndicLum_TurnOffBuzzer(MESSAGE_DELIVERY_GUARANTEE);
              IndicLum_ChangeOpState(actionModule_getStateIn(), actionModule_getStateOut());
              flag_lockDoors = false;
              DoorCtrl_SetDoorSpeedIn(actionModule_xmlGetMaxDoorsMovSpeed());
              DoorCtrl_SetDoorSpeedOut(actionModule_xmlGetMaxDoorsMovSpeed());
              LOG_IF_F(1, STDERR_DEBUG, "Libera acionamento de portas");
              flag_sendIdle = false;
              actionModule_startIdle(velIdle1, velIdle2, MAIN_INDIC_LUM_TAM_IDLE,
                                     (arincPortNumber || actionModule_xmlGetFlagPocAeroporto()));
              soapDFlow_addEventToSend(ns2__EventEnumType__SPOOFING_USCOREDETECTED_USCORECLEAR);
            }

            // test if have a person validated passed on the bloq
            if (actionModule_havePersonCrossValidatedEntrance()) {
              // ENTROU
              actionModule_finishEntrance();
            }

            if (actionModule_havePersonCrossValidatedExit()) {
              // SAIU
              actionModule_finishExit();
            }

            bool haveValidation = false;
            // test if have persons
            if (VideoAnalyzer_GetPersonListSize() && actionModule_getOpModeDoor() != DOOR_MODE_ALW_CLOSED &&
                actionModule_getOpModeDoor() != DOOR_MODE_ALW_OPEN &&
                actionModule_getOpModeDoor() != DOOR_MODE_ALW_OPEN_EXIT) {
              //                uint32_t size = newPersonList.size();
              bool notInvitationLights = false;
              bool flag_personValidEntrance = false;
              bool flag_personValidExit = false;
              // clean flags
              flag_personEntrance = flag_personExit = false;

              // test the attemption for each person

              VideoAnalyzer_SetInvitationLightsByVisiblePerson(notInvitationLights, typeInvitationLights,
                                                               _statusInvitationLights, timeUpdateInviteOn,
                                                               timeUpdateInviteOff, tempoAtualizacao);

              VideoAnalyzer_CheckPositionPersonToSetInvitationLights(notInvitationLights, flag_personEntrance,
                                                                     flag_personValidEntrance, flag_personExit,
                                                                     flag_personValidExit, haveValidation);

              if (actionModule_xmlGetFlagInvitationLights() && !videoAnalyzer_exceeded) {
                if ((typeInvitationLights) && ((flag_personEntrance) || (flag_personExit))) {
                  if (timeUpdateInviteOn.Check()) {
                    IndicLum_SetInvitationLeds((flag_personEntrance) ? typeInvitationLights : 0,
                                               (flag_personExit) ? typeInvitationLights : 0, flag_personValidEntrance,
                                               flag_personValidExit, ((typeInvitationLights == 1) ? 3 : 1),
                                               MESSAGE_PRIORITY);

                    if (!_statusInvitationLights) {
                      timeUpdateInviteOff.Start(TIMEOUT_INVITE);
                      _statusInvitationLights = true;
                    }

                    timeUpdateInviteOn.Start(TIMEOUT_INVITE);
                  }
                } else if (typeInvitationLights == 0) {
                  colorR_entrance = 0;
                  colorG_entrance = 0;
                  colorB_entrance = 0;
                  colorR_exit = 0;
                  colorG_exit = 0;
                  colorB_exit = 0;

                  switch (actionModule_getStateIn()) {
                    case OP_STATE_CONTROLED:
                      if (flag_personValidEntrance) {
                        colorR_entrance = 0;
                        colorG_entrance = 255;
                        colorB_entrance = 0;
                      } else {
                        colorR_entrance = 255;
                        colorG_entrance = 255;
                        colorB_entrance = 0;
                      }
                      break;
                    case OP_STATE_FREE:
                      colorR_entrance = 0;
                      colorG_entrance = 255;
                      colorB_entrance = 0;
                      break;
                    case OP_STATE_CLOSED:
                      colorR_entrance = 255;
                      colorG_entrance = 0;
                      colorB_entrance = 0;
                      break;
                    default:
                      break;
                  }

                  switch (actionModule_getStateOut()) {
                    case OP_STATE_CONTROLED:
                      if (flag_personValidExit) {
                        colorR_exit = 0;
                        colorG_exit = 255;
                        colorB_exit = 0;
                      } else {
                        colorR_exit = 255;
                        colorG_exit = 255;
                        colorB_exit = 0;
                      }
                      break;
                    case OP_STATE_FREE:
                      colorR_exit = 0;
                      colorG_exit = 255;
                      colorB_exit = 0;
                      break;
                    case OP_STATE_CLOSED:
                      colorR_exit = 255;
                      colorG_exit = 0;
                      colorB_exit = 0;
                      break;
                    default:
                      break;
                  }

                  if (flag_personEntrance && flag_personExit) {
                    IndicLum_SetInvitationLights(flag_personEntrance, 200, colorR_entrance, colorG_entrance,
                                                 colorB_entrance, flag_personExit, 200, colorR_exit, colorG_exit,
                                                 colorB_exit, 200, 200, MESSAGE_PRIORITY);
                  } else if (flag_personEntrance) {
                    // SEND IN  attemption
                    // indicLum_setAttentionIn(200, 255, 255, 255, MESSAGE_PRIORITY);
                    IndicLum_SetInvitationLights(flag_personEntrance, 200, colorR_entrance, colorG_entrance,
                                                 colorB_entrance, flag_personExit, 0, 0, 0, 0, 200, 0,
                                                 MESSAGE_PRIORITY);
                  } else if (flag_personExit) {
                    // SEND OUT attemption
                    // indicLum_setAttentionOut(200, 255, 255, 255, MESSAGE_PRIORITY);
                    IndicLum_SetInvitationLights(flag_personEntrance, 0, 0, 0, 0, flag_personExit, 200, colorR_exit,
                                                 colorG_exit, colorB_exit, 0, 200, MESSAGE_PRIORITY);
                  }
                }
              }
            } else if ((actionModule_xmlGetFlagInvitationLights()) && (typeInvitationLights) &&
                       (!videoAnalyzer_exceeded)) {
              if (timeUpdateInviteOff.Check()) {
                IndicLum_SetInvitationLeds(false, false, false, false, 1, MESSAGE_PRIORITY);

                if (_statusInvitationLights) {
                  timeUpdateInviteOn.Start(TIMEOUT_INVITE);
                  _statusInvitationLights = false;
                }

                timeUpdateInviteOff.Start(TIMEOUT_INVITE);
              }
            }
            // test if are waiting for a user
            if (VideoAnalyzer_IsValidInviteEntrance()) {
              _lastWaitingUserEntrace = true;
            } else {
              // tes if have not a validate person
              if (!haveValidation) {
                // test if the last was true
                if (_lastWaitingUserEntrace) {
                  actionModule_cancelEntranceValidated();
                } else if ((actionModule_getUsingArinc()) &&
                           (actionModule_getStatusValidateEntranceAnswer() == ACTIONS_WAITING)) {
                  // Adicionado este teste para liberar leituras de bilhetes no modo ARINC
                  LOG_F(WARNING, "Force Cancel Entrance Validated");
                  actionModule_cancelEntranceValidated();
                }
              }

              _lastWaitingUserEntrace = false;
            }

            if (VideoAnalyzer_IsValidInviteExit()) {
              _lastWaitingUserExit = true;
            } else {
              if (!haveValidation && _lastWaitingUserExit) {
                actionModule_cancelExitValidated();
              }

              _lastWaitingUserExit = false;
            }
          }
        }
      }

      if (contours.size()) {
        if (_testModeRead) {
          if (!PeopleTrackingTest::GetInstance()->CheckInfoPerson(timeBetweenFrames, contours)) {
            LOG_F(ERROR, "Error found in the tracking test");
            if (showWindows)
              _flagPause = true;
            else
              INThandler(SIGQUIT);
          }
        } else if (_testModeWrite) {
          PeopleTrackingTest::GetInstance()->SaveInfoPerson(timeBetweenFrames, contours);
        }
      }

      timeDrawPerson = Util_GetMicroseconds();
      timeGetPerson = timeDrawPerson - timeGetPerson;

      if (remoteConfig_stopApp() || Configurator::GetInstance()->IsStopApp()) {
        INThandler(SIGQUIT);
      }

      int tmpDemo = remoteConfig_get_Demo();
      int tmpIntervalTimePersonPerMinute = 0;
      if (tmpIntervalTimePersonPerMinute != intervalTimePersonPerMinute) {
        intervalTimePersonPerMinute = tmpIntervalTimePersonPerMinute;
      }

      if (tmpDemo) {
        flagIdleSent = false;

        if (!flagDemoSent) {
          IndicLum_StartDemoStripLeds();
          flagDemoSent = true;
          LOG_IF_F(1, STDERR_DEBUG, "Demo sent");
        }
      } else {
        flagDemoSent = false;

        if (!flagIdleSent) {
          IndicLum_StartIdle(velIdle1, velIdle2, MAIN_INDIC_LUM_TAM_IDLE, actionModule_getUsingArinc());
          LOG_IF_F(1, STDERR_DEBUG, "Idle sent");
          flagIdleSent = true;
        }
      }

      // test state animation
      switch (remoteConfig_get_EstadoAnimacao()) {
        case STATEANIMATION_IDLE:
          // play stop all
          if (_saveAnimatioState != STATEANIMATION_IDLE) {
            // stop all
            _saveAnimatioState = STATEANIMATION_IDLE;
            actionModule_stopDemoAnimation();

            if ((tmpflagToggleStateOp == OP_STATE_ALL_FREE) && (!ActionManager::GetInstance()->IsFireAlarmEnabled())) {
              StateOpAllFree();
              pthread_mutex_lock(&_validationMutex);
              tmpflagToggleStateOp = _toggleStateOp;
              pthread_mutex_unlock(&_validationMutex);
            }
          }

          break;
        case STATEANIMATION_DEMOWITHDOORS:
          if ((_saveAnimatioState != STATEANIMATION_DEMOWITHDOORS) &&
              (!ActionManager::GetInstance()->IsFireAlarmEnabled())) {
            // play demo
            _saveAnimatioState = STATEANIMATION_DEMOWITHDOORS;

            if (tmpflagToggleStateOp != OP_STATE_ALL_FREE) {
              StateOpAllFree();
              pthread_mutex_lock(&_validationMutex);
              tmpflagToggleStateOp = _toggleStateOp;
              pthread_mutex_unlock(&_validationMutex);
            }

            if (tmpflagToggleStateOp == OP_STATE_ALL_FREE) {
              actionModule_playDemoAnimationWithDoors(15, DoorCtrl_GetDoorAngleIn(),
                                                      actionModule_getDemoEntranceSpeed(), DoorCtrl_GetDoorAngleOut(),
                                                      actionModule_getDemoExitSpeed());
            }
          }

          break;
        case STATEANIMATION_DEMOLEDSONLY:
          if ((_saveAnimatioState != STATEANIMATION_DEMOLEDSONLY) &&
              (!ActionManager::GetInstance()->IsFireAlarmEnabled())) {
            // play demo
            _saveAnimatioState = STATEANIMATION_DEMOLEDSONLY;

            if (tmpflagToggleStateOp != OP_STATE_ALL_FREE) {
              StateOpAllFree();
              pthread_mutex_lock(&_validationMutex);
              tmpflagToggleStateOp = _toggleStateOp;
              pthread_mutex_unlock(&_validationMutex);
            }

            if (tmpflagToggleStateOp == OP_STATE_ALL_FREE) {
              actionModule_playDemoAnimation(15);
            }
          }

          break;
        default:
          break;
      }

      actionModule_setDoorsSpeed(remoteConfig_get_doorDemoSpeed(),
                                 remoteConfig_get_doorDemoSpeed());  // get the door demo speed
      remoteConfig_set_doorDemoSpeed(actionModule_getDemoEntranceSpeed());

      // get the door demo speed
      actionModule_setDoorsSpeed(remoteConfig_get_doorDemoSpeed(), remoteConfig_get_doorDemoSpeed());
      remoteConfig_set_doorDemoSpeed(actionModule_getDemoEntranceSpeed());

      if ((!VideoAnalyzer_IsValidInviteEntrance()) && (!VideoAnalyzer_IsValidInviteExit()) &&
          (!VideoAnalyzer_WaitingForValidationStack()) && (VideoAnalyzer_IdleStatus())) {
        if (!flag_sendIdle) {
          if (tempoAtualizacao.Check()) {
            // LOG_F(INFO, "Manda idle");
            if (!ActionManager::GetInstance()->IsDoorsCalibProgress()) {
              IndicLum_StartIdle(velIdle1, velIdle2, MAIN_INDIC_LUM_TAM_IDLE, actionModule_getUsingArinc());
              flag_sendIdle = true;
            }
            tempoAtualizacao.Start(1000);
          }
        }
        if (actionModule_xmlGetOpModeDoor() != DOOR_MODE_DVIATOR_Y) {
          if ((!VideoAnalyzer_IsValidationInToOutAvailable()) && (VideoAnalyzer_EndTimerEventNotOk())) {
            if (!flag_sendIdleLcd) {
              if (!actionModule_xmlGetSoapOrchestratorPort() ||
                  (actionModule_xmlGetSoapOrchestratorPort() &&
                   (soapDFlow_IsOnline() || actionModule_xmlGetSoapCredentialBuffer() ||
                    actionModule_xmlGetFlagPocAeroporto()))) {
                LOG_IF_F(INFO, STDERR_DEBUG, "Manda idle LCD");
                Event_Lcd(EVENT_TYPE_IDLE);
              }
              flag_sendIdleLcd = true;
            }
          } else {
            if ((VideoAnalyzer_IsValidationInToOutAvailable()) && (VideoAnalyzer_EndTimerEventNotOk()) &&
                (actionModule_getStateIn() != OP_STATE_FREE)) {
              Event_Lcd(EVENT_TYPE_VALIDATION_OK);
            }
            flag_sendIdleLcd = false;
          }
        }
      } else {
        if ((VideoAnalyzer_IsValidationInToOutAvailable()) && (VideoAnalyzer_EndTimerEventNotOk()) &&
            (actionModule_getStateIn() != OP_STATE_FREE)) {
          Event_Lcd(EVENT_TYPE_VALIDATION_OK);
        }
        flag_sendIdle = false;
        flag_sendIdleLcd = false;
      }

      if (flag_acionaPorta) {
        VideoAnalyzer_SetFlagCloseDoor(true);
      } else {
        VideoAnalyzer_SetFlagCloseDoor(false);
      }

      if (!actionModule_xmlGetCudaPreprocessingEnabled() && actionModule_xmlGetCudaClaheFilterEnabled()) {
        imgFrame = VideoAnalyzer_ApplyClaheImage(imgFrame);
      } else
        imgFrame = VideoAnalyzer_SaturateImage(imgFrame);

      // Calculate the average pixel value of the image
      //      cv::Scalar avgPixelValue = cv::mean(imgFrameOrig);
      //      cv::Scalar avgPixelValue2 = cv::mean(imgFrame);
      //      LOG_F(WARNING, "Average Pixel Value (Grayscale): Original: %.2f | After: %.2f", avgPixelValue[0],
      //            avgPixelValue2[0]);

      // if don't show depth. Copy the imgFrame to frame
      if (!showDepth) {
        // copy the image
        imgFrame.copyTo(frame);
        // cut the frame
        frame = VideoAnalyzer_CutFrame(frame);
      }

      if (actionModule_IsDflowAsValidationZone()) {
        LedStripTotem_SetStatePerson();
        LedStripTotem_Update();
      }

      if (actionModule_getUsingSita() || actionModule_xmlGetScafisDflowPort()) {
        if (actionModule_getOpModeDoor() != DOOR_MODE_ALW_OPEN &&
            actionModule_getOpModeDoor() != DOOR_MODE_ALW_OPEN_EXIT) {
          DflowEvent_OnUnauthorizedPersonBlockingEntrance(VideoAnalyzer_UnauthorisedPersonBlockingEntry());
          DflowEvent_OnUnauthorizedPersonBlockingExit(VideoAnalyzer_UnauthorisedPersonBlockingExit());
          DflowEvent_OnNobodyInsideGate(VideoAnalyzer_NobodyInsideGate());
        }
      }

// Carrega estado e ângulo das portas
//#define TESTE_ANGLE_DOORS
#ifdef TESTE_ANGLE_DOORS
      DoorPassingState stateDoor[DOORS_TOTAL] = {DOOR_STATE_UNDEFINED, DOOR_STATE_UNDEFINED, DOOR_STATE_UNDEFINED,
                                                 DOOR_STATE_UNDEFINED, DOOR_STATE_UNDEFINED, DOOR_STATE_UNDEFINED,
                                                 DOOR_STATE_UNDEFINED, DOOR_STATE_UNDEFINED};

#endif
      DoorOperationalState statusDoor[DOORS_TOTAL] = {DOOR_OP_INDEF, DOOR_OP_INDEF, DOOR_OP_INDEF, DOOR_OP_INDEF,
                                                      DOOR_OP_INDEF, DOOR_OP_INDEF, DOOR_OP_INDEF, DOOR_OP_INDEF};
      uint16_t angleDoor[DOORS_TOTAL] = {0, 0, 0, 0, 0, 0, 0, 0};
      for (uint8_t door = DOOR_06; door < DOORS_TOTAL; door++) {
#ifdef TESTE_ANGLE_DOORS
        stateDoor[door] = DoorStatus_GetStateDoor((DoorId)door);
#endif
        statusDoor[door] = DoorStatus_GetOpStatusDoor((DoorId)door);
        angleDoor[door] = DoorStatus_GetAngleDoor((DoorId)door);
      }

#ifdef TESTE_ANGLE_DOORS
      static DoorPassingState lastStateDoor[DOORS_TOTAL] = {DOOR_STATE_STOP, DOOR_STATE_STOP, DOOR_STATE_STOP,
                                                            DOOR_STATE_STOP, DOOR_STATE_STOP, DOOR_STATE_STOP,
                                                            DOOR_STATE_STOP, DOOR_STATE_STOP};

      static DoorOperationalState lastStatusDoor[DOORS_TOTAL] = {
          DOOR_OP_TEST_MODE, DOOR_OP_TEST_MODE, DOOR_OP_TEST_MODE, DOOR_OP_TEST_MODE,
          DOOR_OP_TEST_MODE, DOOR_OP_TEST_MODE, DOOR_OP_TEST_MODE, DOOR_OP_TEST_MODE};

      static uint16_t lastAngleDoor[DOORS_TOTAL] = {0xFFFE, 0xFFFE, 0xFFFE, 0xFFFE, 0xFFFE, 0xFFFE, 0xFFFE, 0xFFFE};
      for (uint8_t door = DOOR_06; door < DOORS_TOTAL; door++) {
        if ((((lastAngleDoor[door] > angleDoor[door]) && (lastAngleDoor[door] - angleDoor[door] >= 2)) ||
             ((angleDoor[door] > lastAngleDoor[door]) && (angleDoor[door] - lastAngleDoor[door] >= 2))) &&
            (statusDoor[door] == DOOR_OP_OPEN_CLOSE || statusDoor[door] == DOOR_OP_ANGLE)) {
          LOG_F(WARNING, "Angle DOOR_%02d: %u", door + 6, angleDoor[door]);
          lastAngleDoor[door] = angleDoor[door];
        }
        if (lastStateDoor[door] != stateDoor[door]) {
          LOG_F(ERROR, "State DOOR_%02d: %s", door + 6, stateDoor[door] == DOOR_STATE_OPEN
                                                            ? "DOOR_STATE_OPEN"
                                                            : stateDoor[door] == DOOR_STATE_CLOSED
                                                                  ? "DOOR_STATE_CLOSED"
                                                                  : stateDoor[door] == DOOR_STATE_OPENING
                                                                        ? "DOOR_STATE_OPENING"
                                                                        : stateDoor[door] == DOOR_STATE_CLOSING
                                                                              ? "DOOR_STATE_CLOSING"
                                                                              : stateDoor[door] == DOOR_STATE_STOP
                                                                                    ? "DOOR_STATE_STOP"
                                                                                    : "DOOR_STATE_UNDEFINED");
          lastStateDoor[door] = stateDoor[door];
        }
        if (lastStatusDoor[door] != statusDoor[door]) {
          LOG_F(
              ERROR, "Status DOOR_%02d: %s", door + 6,
              statusDoor[door] == DOOR_OP_CRITICAL_ERROR
                  ? "DOOR_OP_ERROR"
                  : statusDoor[door] == DOOR_OP_INITIALIZING
                        ? "DOOR_OP_INITIALIZING"
                        : statusDoor[door] == DOOR_OP_CALIBRATING
                              ? "DOOR_OP_CALIBRATING"
                              : statusDoor[door] == DOOR_OP_OPEN_CLOSE
                                    ? "DOOR_OP_NORMAL"
                                    : statusDoor[door] == DOOR_OP_ANGLE
                                          ? "DOOR_OP_POSICAO"
                                          : statusDoor[door] == DOOR_OP_TEST_MODE ? "DOOR_OP_TESTE" : "DOOR_OP_INDEF");
          lastStatusDoor[door] = statusDoor[door];
        }
      }
#endif

      // Verifica se funcionalidade de fechamento de portas esta habilitada
      if ((actionModule_getCheckStatusDoors()) && ((actionModule_xmlGetOpModeDoor() == DOOR_MODE_BIDIRECTIONAL_OPEN) ||
                                                   (actionModule_xmlGetOpModeDoor() == DOOR_MODE_DECENTRALIZED_OPEN)) &&
          (tmpflagToggleStateOp != OP_STATE_FIRE_ALARM) && (tmpflagToggleStateOp != OP_STATE_ALL_FREE) &&
          (tmpflagToggleStateOp != OP_STATE_COLLECT_CARD_URN)) {
        ChecksIdlingOfDoors(flagSetTimeoutOpenDoor, flagMovimentDoorsClose, flagMovimentDoorsOpen, angleDoor);
      }

      static int previousPercentageDoor_ENT = -1;
      static int previousPercentageDoor_EXT = -1;
      static int previousAngleDoor_08 = -1;
      static int previousAngleDoor_09 = -1;
      static int previousAngleDoor_12 = -1;
      static int previousAngleDoor_13 = -1;
      DoorActivation forceDoor = DOOR_ENT;

      bool _doorClosingForce = false;
      // Adicao de variaveis para verificar acionamento das portas
      // do desviador no modo de fechamento forcado
      bool _forceOpenDoorLft = false;
      bool _forceClosedDoorLft = false;
      bool _forceOpenDoorRgt = false;
      bool _forceClosedDoorRgt = false;

      if (!videoAnalyzer_exceeded) {
        int currentPercentageDoor_ENT = VideoAnalyzer_GetDoorIntense(DOOR_ENT) * 100 / 255;
        int currentPercentageDoor_EXT = VideoAnalyzer_GetDoorIntense(DOOR_EXT) * 100 / 255;
        int currentPercentageDoor_LFT = VideoAnalyzer_GetDoorIntense(DOOR_LFT) * 100 / 255;
        int currentPercentageDoor_RGT = VideoAnalyzer_GetDoorIntense(DOOR_RGT) * 100 / 255;

        int currentPercentageBuzzer_ENT = VideoAnalyzer_GetBuzzerIntense(DOOR_ENT) * 100 / 255;
        int currentPercentageBuzzer_EXT = VideoAnalyzer_GetBuzzerIntense(DOOR_EXT) * 100 / 255;
        int currentPercentageBuzzer_LFT = VideoAnalyzer_GetBuzzerIntense(DOOR_LFT) * 100 / 255;

        LOG_IF_F(1, STDERR_DEBUG, "currentPercentageDoor_ENT: %d", currentPercentageDoor_ENT);
        LOG_IF_F(1, STDERR_DEBUG, "currentPercentageDoor_EXT: %d", currentPercentageDoor_EXT);
        LOG_IF_F(1, STDERR_DEBUG, "currentPercentageDoor_LFT: %d", currentPercentageDoor_LFT);
        LOG_IF_F(1, STDERR_DEBUG, "currentPercentageDoor_RGT: %d", currentPercentageDoor_RGT);

        LOG_IF_F(1, STDERR_DEBUG, "lastAngle_ENT: %d", previousPercentageDoor_ENT);
        LOG_IF_F(1, STDERR_DEBUG, "lastAngle_EXT: %d", previousPercentageDoor_EXT);

        static bool sentUnauthorisedPerson = false;
        static bool sentAuthorisedPerson = false;
        static TimeoutCpp timeAuthorised;
        static TimeoutCpp timeUnauthorised;
        uint64_t debounceTime = 500;
        bool invalidPersonInsideGate = VideoAnalyzer_InvalidPersonInside();
        bool nobodyUnauthorised = VideoAnalyzer_NobodyUnauthorisedInsideGate();
        bool validPersonInsideGate = VideoAnalyzer_IsPersonValidInsideGateAfterPercent(20);
        bool nobodyAuthorised = VideoAnalyzer_NobodyAuthorisedInsideGate();

        if (invalidPersonInsideGate) {
          timeUnauthorised.Start(debounceTime);
          if (!sentUnauthorisedPerson) {
            if (sentAuthorisedPerson && nobodyAuthorised) {
              LOG_IF_F(INFO, STDERR_DEBUG, "addEventToSend: EVENT_GATE_CLEAR_FROM_VALID");
              soapDFlow_addEventToSend(ns2__EventEnumType__GATE_USCORECLEAR_USCOREFROM_USCOREVALID);
              sentAuthorisedPerson = false;
            }

            LOG_IF_F(INFO, STDERR_DEBUG, "addEventToSend: EVENT_UNAUTHORISED_CROSSING");
            if (!VideoAnalyzer_AddTravellerToUnauthorisedCrossing()) {
              soapDFlow_addEventToSend(ns2__EventEnumType__UNAUTHORISED_USCORECROSSING);
            }
            sentUnauthorisedPerson = true;
          }
        } else if (sentUnauthorisedPerson && nobodyUnauthorised && timeUnauthorised.Check()) {
          LOG_IF_F(INFO, STDERR_DEBUG, "addEventToSend: EVENT_GATE_CLEAR_FROM_FRAUD");
          soapDFlow_addEventToSend(ns2__EventEnumType__GATE_USCORECLEAR_USCOREFROM_USCOREFRAUD);
          sentUnauthorisedPerson = false;
        }

        if (validPersonInsideGate) {
          timeAuthorised.Start(debounceTime);
          if (!sentAuthorisedPerson) {
            if (sentUnauthorisedPerson && nobodyUnauthorised) {
              LOG_IF_F(INFO, STDERR_DEBUG, "addEventToSend: EVENT_GATE_CLEAR_FROM_FRAUD");
              soapDFlow_addEventToSend(ns2__EventEnumType__GATE_USCORECLEAR_USCOREFROM_USCOREFRAUD);
              sentUnauthorisedPerson = false;
            }

            LOG_IF_F(INFO, STDERR_DEBUG, "addEventToSend: EVENT_AUTHORISED_CROSSING");
            if (!VideoAnalyzer_AddTravellerToAuthorisedCrossing()) {
              soapDFlow_addEventToSend(ns2__EventEnumType__AUTHORISED_USCORECROSSING);
            }
            sentAuthorisedPerson = true;
          }
        } else if (sentAuthorisedPerson && nobodyAuthorised && timeAuthorised.Check()) {
          LOG_IF_F(INFO, STDERR_DEBUG, "addEventToSend: EVENT_GATE_CLEAR_FROM_VALID");
          soapDFlow_addEventToSend(ns2__EventEnumType__GATE_USCORECLEAR_USCOREFROM_USCOREVALID);
          sentAuthorisedPerson = false;
        }

        if (actionModule_xmlGetOpModeDoor() != DOOR_MODE_TRAP) {
          bool isProtectionAreaInsideGate = VideoAnalyzer_IsProtectionAreaInsideGate_NoBoundPerson(protectionAreas);
          static bool isProtectionAreaInsideGateLast = false;
          static TimeoutCpp timeObjectLeftBehind;

          if (!isProtectionAreaInsideGate && !isProtectionAreaInsideGateLast) {
            if (timeObjectLeftBehind.IsStarted()) timeObjectLeftBehind.Stop();
          }

          if (isProtectionAreaInsideGate && !isProtectionAreaInsideGateLast) {
            if (!timeObjectLeftBehind.IsStarted())
              timeObjectLeftBehind.Start(SoapConfigurations::GetInstance()->GetValue(
                  SoapConfigurations::TIME_TO_SEND_OBJECT_LEFT_BEHIND_EVENT));
            if (VideoAnalyzer_NobodyInsideGate()) {
              if (timeObjectLeftBehind.CheckAndRestart(debounceTime)) {
                isProtectionAreaInsideGateLast = isProtectionAreaInsideGate;
                LOG_IF_F(INFO, STDERR_DEBUG, "addEventToSend: EVENT_OBJECT_LEFT_BEHIND");
                soapDFlow_addEventToSend(ns2__EventEnumType__OBJECT_USCORELEFT_USCOREBEHIND);
              }
            }
          } else if (!isProtectionAreaInsideGate && isProtectionAreaInsideGateLast && timeObjectLeftBehind.Check()) {
            isProtectionAreaInsideGateLast = isProtectionAreaInsideGate;
            LOG_IF_F(INFO, STDERR_DEBUG, "addEventToSend: EVENT_OBJECT_LEFT_BEHIND_CLEAR");
            soapDFlow_addEventToSend(ns2__EventEnumType__OBJECT_USCORELEFT_USCOREBEHIND_USCORECLEAR);
          }
        }

        if ((flagSendViolation) && (flagStatusIO))  // se estiver habilitado validacao via input (placa de controle)
        {
          // Verifica valor de acionamento da porta, para indicar violação
          if ((currentPercentageBuzzer_ENT < turningSimulationPercentage) ||
              (currentPercentageBuzzer_EXT < turningSimulationPercentage) ||
              (currentPercentageBuzzer_LFT < turningSimulationPercentage)) {
            static uint8_t state_relay[NUM_RELAY] = {false, false};

            // intrusion in
            if ((currentPercentageBuzzer_ENT >= percentageToIndicateViolation ||
                 currentPercentageBuzzer_LFT >= percentageToIndicateViolation) &&
                !state_relay[RELAY_IN]) {
              IndicLum_SetRelay(RELAY_IN, REL_ON);
              state_relay[RELAY_IN] = true;
            }

            if ((currentPercentageBuzzer_ENT == 0 && currentPercentageBuzzer_LFT == 0) && state_relay[RELAY_IN]) {
              IndicLum_SetRelay(RELAY_IN, REL_OFF);
              state_relay[RELAY_IN] = false;
            }

            // intrusion out
            if (currentPercentageBuzzer_EXT >= percentageToIndicateViolation && !state_relay[RELAY_OUT]) {
              IndicLum_SetRelay(RELAY_OUT, REL_ON);
              state_relay[RELAY_OUT] = true;
            }

            if (currentPercentageBuzzer_EXT == 0 && state_relay[RELAY_OUT]) {
              IndicLum_SetRelay(RELAY_OUT, REL_OFF);
              state_relay[RELAY_OUT] = false;
            }
          }
        }

        if ((tmpflagToggleStateOp != OP_STATE_COLLECT_CARD_URN) && (tmpflagToggleStateOp != OP_STATE_FIRE_ALARM) &&
            (tmpflagToggleStateOp != OP_STATE_ALL_FREE)) {
          enumLevelOfUserProtection levelOfUserProtection = actionModule_xmlGetLevelOfUserProtection();

          // Carrega variaveis de controle de regras para acionamento correto das portas
          bool invalidPersonInside_inToOut = VideoAnalyzer_InvalidPersonInsideInToOut();
          bool invalidPersonInside_outToIn = VideoAnalyzer_InvalidPersonInsideOutToIn();
          bool isValidationAvailable_inToOut = VideoAnalyzer_IsValidationInToOutAvailable();
          bool isValidationAvailable_outToIn = VideoAnalyzer_IsValidationOutToInAvailable();
          bool isValidationRegionBarrier_inToOut = VideoAnalyzer_IsValidationInToOutRegionBarrier();
          bool isValidationRegionBarrier_outToIn = VideoAnalyzer_IsValidationOutToInRegionBarrier();

//#define INFO_TESTE

#ifdef INFO_TESTE
          LOG_F(INFO, "invalidPersonInside_inToOut: %s", invalidPersonInside_inToOut ? "true" : "false");
          LOG_F(INFO, "invalidPersonInside_outToIn: %s", invalidPersonInside_outToIn ? "true" : "false");
          LOG_F(INFO, "isValidationAvailable_inToOut: %s", isValidationAvailable_inToOut ? "true" : "false");
          LOG_F(INFO, "isValidationAvailable_outToIn: %s", isValidationAvailable_outToIn ? "true" : "false");
          LOG_F(INFO, "isValidationRegionBarrier_inToOut: %s", isValidationRegionBarrier_inToOut ? "true" : "false");
          LOG_F(INFO, "isValidationRegionBarrier_outToIn: %s", isValidationRegionBarrier_outToIn ? "true" : "false");
#endif

          bool someoneValidToProtect_inToOut = VideoAnalyzer_SomeoneValidToProtectInToOut();
          bool someoneValidToProtect_outToIn = VideoAnalyzer_SomeoneValidToProtectOutToIn();
          bool someoneToProtect_inToOut = VideoAnalyzer_SomeoneToProtectInToOut();
          bool someoneToProtect_outToIn = VideoAnalyzer_SomeoneToProtectOutToIn();
          bool somethingToProtect_inToOut = VideoAnalyzer_SomethingToProtectInToOut(protectionAreas);
          bool somethingToProtect_outToIn = VideoAnalyzer_SomethingToProtectOutToIn(protectionAreas);

          bool onlyOneValidPerson_InToOut = VideoAnalyzer_OnlyOneValidPerson_InToOut(protectionAreas);
          bool onlyOneValidPerson_OutToIn = VideoAnalyzer_OnlyOneValidPerson_OutToIn(protectionAreas);

#ifdef INFO_TESTE
          static bool tmpOnlyOneValidPerson_InToOut = true;
          static bool tmpOnlyOneValidPerson_OutToIn = true;

          if (tmpOnlyOneValidPerson_InToOut != onlyOneValidPerson_InToOut) {
            LOG_F(WARNING, "onlyOneValidPerson_InToOut: %s", onlyOneValidPerson_InToOut ? "true" : "false");
            tmpOnlyOneValidPerson_InToOut = onlyOneValidPerson_InToOut;
          }
          if (tmpOnlyOneValidPerson_OutToIn != onlyOneValidPerson_OutToIn) {
            LOG_F(WARNING, "onlyOneValidPerson_OutToIn: %s", onlyOneValidPerson_OutToIn ? "true" : "false");
            tmpOnlyOneValidPerson_OutToIn = onlyOneValidPerson_OutToIn;
          }
#endif

          if ((!somethingToProtect_inToOut) && (Timeout_IsStarted(timeoutSomethingProtectInToOut))) {
            LOG_IF_F(1, STDERR_DEBUG, "Stop timeout timeoutSomethingProtectInToOut");
            Timeout_Stop(timeoutSomethingProtectInToOut);
          }
          if ((!somethingToProtect_outToIn) && (Timeout_IsStarted(timeoutSomethingProtectOutToIn))) {
            LOG_IF_F(1, STDERR_DEBUG, "Stop timeout timeoutSomethingProtectOutToIn");
            Timeout_Stop(timeoutSomethingProtectOutToIn);
          }

#ifdef INFO_TESTE
          LOG_F(INFO, "someoneValidToProtect_inToOut: %s", someoneValidToProtect_inToOut ? "true" : "false");
          LOG_F(INFO, "someoneValidToProtect_outToIn: %s", someoneValidToProtect_outToIn ? "true" : "false");
          LOG_F(INFO, "someoneToProtect_inToOut: %s", someoneToProtect_inToOut ? "true" : "false");
          LOG_F(INFO, "someoneToProtect_outToIn: %s", someoneToProtect_outToIn ? "true" : "false");
          LOG_F(INFO, "somethingToProtect_inToOut: %s", somethingToProtect_inToOut ? "true" : "false");
          LOG_F(INFO, "somethingToProtect_outToIn: %s", somethingToProtect_outToIn ? "true" : "false");
#endif

          static bool sentEventEntranceDoorProtecting = false;
          static bool sentEventExitDoorProtecting = false;
          static bool protectionUserEntrance = false;
          static bool protectionUserExit = false;

          bool forceBrake = false;
          bool stopDoorsEntrance = false;
          bool stopDoorsExit = false;
          DoorStatePersonProtect doorStatePersonProtect = actionModule_xmlGetDoorStateAfterPersonProtection();

          if ((actionModule_getOpModeDoor() == DOOR_MODE_BIDIRECTIONAL_OPEN) ||
              (actionModule_getOpModeDoor() == DOOR_MODE_DECENTRALIZED_OPEN)) {
            //*******************************************************************************************************/
            if (actionModule_getOpModeDoor() == DOOR_MODE_BIDIRECTIONAL_OPEN) {
              LOG_IF_F(1, STDERR_DEBUG, "OPEN MODE DOORS: BIDIRECTIONAL");
            } else {
              LOG_IF_F(1, STDERR_DEBUG, "OPEN MODE DOORS: DECENTRALIZED");
            }

            // Acionamento para pessoa distraida
            if (actionModule_getScatterbrain()) {
              if (Timeout_Check(timeoutScatterbrain)) {
                LOG_IF_F(1, STDERR_DEBUG, "Clear Scatterbrain");
                actionModule_setScatterbrain(false);
                flag_sendIdle = false;
              } else if (!Timeout_IsStarted(timeoutScatterbrain)) {
                LOG_IF_F(1, STDERR_DEBUG, "Start timeout scatterbrain");
                Timeout_Start(timeoutScatterbrain, 300);
                // indicLum_setBuzzer(100, 100, 2, MESSAGE_DELIVERY_GUARANTEE);
                IndicLum_SetBuzzer(300, 0, 1, MESSAGE_DELIVERY_GUARANTEE);
                Timeout_Start(timeoutLedScatterbrain, 0);
              }
              if (Timeout_CheckAndRestart(timeoutLedScatterbrain, 100)) {
                static bool toggleLed = false;
                if (toggleLed) {
                  IndicLum_AddWindowMemTop(0, 100, 0, 0, 0);
                  IndicLum_AddWindowMemFront(0, 100, 0, 0, 0);
                  IndicLum_AddWindowMemBack(0, 100, 0, 0, 0);
                  toggleLed = false;
                } else {
                  IndicLum_AddWindowMemTop(0, 100, 255, 255, 255);
                  IndicLum_AddWindowMemFront(0, 100, 255, 255, 255);
                  IndicLum_AddWindowMemBack(0, 100, 255, 255, 255);
                  toggleLed = true;
                }
              }
            }

            if ((((currentPercentageDoor_ENT) && (!currentPercentageDoor_EXT)) ||
                 ((!currentPercentageDoor_ENT) && (currentPercentageDoor_EXT))) &&
                ((!isValidationAvailable_inToOut) && (!isValidationAvailable_outToIn)) &&
                (!_flagWaitingInvalidUserGetOut)) {
              LOG_IF_F(1, STDERR_DEBUG,
                       "Pessoa invalida somente na entrada ou somente na saida e nenhuma invalida no sentido oposto e "
                       "nenhuma valida");
              if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                   (((currentPercentageDoor_ENT) && (somethingToProtect_inToOut || someoneToProtect_inToOut)) ||
                    ((currentPercentageDoor_EXT) && (somethingToProtect_outToIn || someoneToProtect_outToIn)))) ||
                  ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) &&
                   (((currentPercentageDoor_ENT) && (someoneToProtect_inToOut)) ||
                    ((currentPercentageDoor_EXT) && (someoneToProtect_outToIn))))) {
                if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                }

                if (currentPercentageDoor_ENT) {
                  if (!protectionUserEntrance) {
                    protectionUserEntrance = true;
                    soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING);
                    sentEventEntranceDoorProtecting = true;
                    if (DoorStatus_EntranceDoorsWithCorrectStatus(statusDoor)) {
                      previousPercentageDoor_ENT = ((((angleDoor[DOOR_06] + angleDoor[DOOR_10]) / 2) * 100) / 90);
                    } else if (DoorStatus_DoorWithCorrectStatus(DOOR_06, statusDoor)) {
                      previousPercentageDoor_ENT = ((angleDoor[DOOR_06] * 100) / 90);
                    } else if (DoorStatus_DoorWithCorrectStatus(DOOR_10, statusDoor)) {
                      previousPercentageDoor_ENT = ((angleDoor[DOOR_10] * 100) / 90);
                    } else {
                      previousPercentageDoor_ENT = 0;
                    }
                  }
                  if (doorStatePersonProtect == STOP_DOOR || doorStatePersonProtect == BRAKE_DOOR) {
                    LOG_IF_F(1, STDERR_DEBUG, "Stop Doors");
                    stopDoorsEntrance = true;
                  } else if (doorStatePersonProtect == LAST_ANGLE) {
                    DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                    DoorCtrl_CloseOutDoorPercentage(currentPercentageDoor_EXT);
                  }
                  VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                  previousPercentageDoor_EXT = currentPercentageDoor_EXT;
                  forceDoor = DOOR_ENT;
                } else {
                  if (!protectionUserExit) {
                    protectionUserExit = true;
                    soapDFlow_addEventToSend(ns2__EventEnumType__EXIT_USCOREDOOR_USCOREPROTECTING);
                    sentEventExitDoorProtecting = true;
                    if (DoorStatus_ExitDoorsWithCorrectStatus(statusDoor)) {
                      previousPercentageDoor_EXT = ((((angleDoor[DOOR_07] + angleDoor[DOOR_11]) / 2) * 100) / 90);
                    } else if (DoorStatus_DoorWithCorrectStatus(DOOR_07, statusDoor)) {
                      previousPercentageDoor_EXT = ((angleDoor[DOOR_07] * 100) / 90);
                    } else if (DoorStatus_DoorWithCorrectStatus(DOOR_11, statusDoor)) {
                      previousPercentageDoor_EXT = ((angleDoor[DOOR_11] * 100) / 90);
                    } else {
                      previousPercentageDoor_EXT = 0;
                    }
                  }
                  if (doorStatePersonProtect == STOP_DOOR || doorStatePersonProtect == BRAKE_DOOR) {
                    LOG_IF_F(1, STDERR_DEBUG, "Stop Doors");
                    stopDoorsExit = true;
                  } else if (doorStatePersonProtect == LAST_ANGLE) {
                    DoorCtrl_CloseInDoorPercentage(currentPercentageDoor_ENT);
                    DoorCtrl_CloseOutDoorPercentage(previousPercentageDoor_EXT);
                  }
                  VideoAnalyzer_SetDoorIntense(DOOR_EXT, (previousPercentageDoor_EXT * 255) / 100);
                  previousPercentageDoor_ENT = currentPercentageDoor_ENT;
                  forceDoor = DOOR_EXT;
                }
                // Deve fechar portas mas não pode
                _doorClosingForce = MustForceDoorMove(forceDoor, statusDoor, angleDoor, currentPercentageDoor_ENT,
                                                      currentPercentageDoor_EXT);
              } else {
                LOG_IF_F(1, STDERR_DEBUG, "Aciona portas");
                if (protectionUserEntrance) {
                  protectionUserEntrance = false;
                  if (sentEventEntranceDoorProtecting) {
                    soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
                    sentEventEntranceDoorProtecting = false;
                  }
                } else if (protectionUserExit) {
                  protectionUserExit = false;
                  if (sentEventExitDoorProtecting) {
                    soapDFlow_addEventToSend(ns2__EventEnumType__EXIT_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
                    sentEventExitDoorProtecting = false;
                  }
                }

                if (currentPercentageDoor_ENT) {
                  if (previousPercentageDoor_EXT > 0 && (somethingToProtect_outToIn || someoneToProtect_outToIn)) {
                    LOG_IF_F(1, STDERR_DEBUG,
                             "Alguma coisa na regiao de protecao das portas, as mesmas nao sao acionadas");
                    DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                    DoorCtrl_CloseOutDoorPercentage(previousPercentageDoor_EXT);
                    forceDoor = DOOR_ENT;
                    // Deve fechar portas mas não pode
                    _doorClosingForce = MustForceDoorMove(forceDoor, statusDoor, angleDoor, currentPercentageDoor_ENT,
                                                          currentPercentageDoor_EXT);
                  } else {
                    DoorCtrl_CloseInDoorPercentage(currentPercentageDoor_ENT);
                    DoorCtrl_CloseOutDoorPercentage(DOOR_OPEN_ENTRANCE);
                    previousPercentageDoor_ENT = currentPercentageDoor_ENT;
                    previousPercentageDoor_EXT = ((DoorCtrl_GetDoorAngleOut() * 100) / 90);
                  }
                } else {
                  if (previousPercentageDoor_ENT > 0 && (somethingToProtect_inToOut || someoneToProtect_inToOut)) {
                    LOG_IF_F(1, STDERR_DEBUG,
                             "Alguma coisa na regiao de protecao das portas, as mesmas nao sao acionadas");
                    DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                    DoorCtrl_CloseOutDoorPercentage(previousPercentageDoor_EXT);
                    forceDoor = DOOR_EXT;
                    // Deve fechar portas mas não pode
                    _doorClosingForce = MustForceDoorMove(forceDoor, statusDoor, angleDoor, currentPercentageDoor_ENT,
                                                          currentPercentageDoor_EXT);
                  } else {
                    DoorCtrl_CloseInDoorPercentage(DOOR_OPEN_ENTRANCE);
                    DoorCtrl_CloseOutDoorPercentage(currentPercentageDoor_EXT);
                    previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
                    previousPercentageDoor_EXT = currentPercentageDoor_EXT;
                  }
                }
              }
            } else if ((currentPercentageDoor_ENT) && (!currentPercentageDoor_EXT)) {
              LOG_IF_F(1, STDERR_DEBUG, "Invalido na entrada e nenhuma pessoa invalida na saida");
              if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                   (somethingToProtect_inToOut || someoneToProtect_inToOut)) ||
                  ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_inToOut)) ||
                  ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) && (someoneValidToProtect_inToOut))) {
                if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                }

                if (!protectionUserEntrance) {
                  protectionUserEntrance = true;
                  soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING);
                  sentEventEntranceDoorProtecting = true;
                  if (DoorStatus_EntranceDoorsWithCorrectStatus(statusDoor)) {
                    previousPercentageDoor_ENT = ((((angleDoor[DOOR_06] + angleDoor[DOOR_10]) / 2) * 100) / 90);
                  } else if (DoorStatus_DoorWithCorrectStatus(DOOR_06, statusDoor)) {
                    previousPercentageDoor_ENT = ((angleDoor[DOOR_06] * 100) / 90);
                  } else if (DoorStatus_DoorWithCorrectStatus(DOOR_10, statusDoor)) {
                    previousPercentageDoor_ENT = ((angleDoor[DOOR_10] * 100) / 90);
                  } else {
                    previousPercentageDoor_ENT = 0;
                  }
                }
                if (doorStatePersonProtect == STOP_DOOR || doorStatePersonProtect == BRAKE_DOOR) {
                  LOG_IF_F(1, STDERR_DEBUG, "Stop Doors");
                  stopDoorsEntrance = true;
                } else if (doorStatePersonProtect == LAST_ANGLE) {
                  DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                  DoorCtrl_CloseOutDoorPercentage(currentPercentageDoor_EXT);
                }
                VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                previousPercentageDoor_EXT = currentPercentageDoor_EXT;
                forceDoor = DOOR_ENT;
                // Deve fechar portas mas não pode
                _doorClosingForce = MustForceDoorMove(forceDoor, statusDoor, angleDoor, currentPercentageDoor_ENT,
                                                      currentPercentageDoor_EXT);
                _flagWaitingInvalidUserGetOut = true;
              } else {
                if ((previousPercentageDoor_EXT >= 0) && (previousPercentageDoor_EXT <= DIFF_ANGLE)) {
                  _flagWaitingInvalidUserGetOut = false;
                }
                if ((_flagWaitingInvalidUserGetOut) && (somethingToProtect_outToIn || someoneToProtect_outToIn)) {
                  LOG_IF_F(1, STDERR_DEBUG,
                           "Alguma coisa na regiao de protecao das portas, as mesmas nao sao acionadas");
                  DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                  DoorCtrl_CloseOutDoorPercentage(previousPercentageDoor_EXT);
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona portas");
                  DoorCtrl_CloseInDoorPercentage(currentPercentageDoor_ENT);
                  DoorCtrl_CloseOutDoorPercentage(DOOR_OPEN_ENTRANCE);
                  previousPercentageDoor_ENT = currentPercentageDoor_ENT;
                  previousPercentageDoor_EXT = ((DoorCtrl_GetDoorAngleOut() * 100) / 90);
                  _flagWaitingInvalidUserGetOut = false;
                  if (protectionUserEntrance) {
                    protectionUserEntrance = false;
                    if (sentEventEntranceDoorProtecting) {
                      soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
                      sentEventEntranceDoorProtecting = false;
                    }
                  }
                }
              }
            } else if ((!currentPercentageDoor_ENT) && (currentPercentageDoor_EXT)) {
              LOG_IF_F(1, STDERR_DEBUG, "Invalido na saida e nenhuma pessoa invalida na entrada");
              if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                   (somethingToProtect_outToIn || someoneToProtect_outToIn)) ||
                  ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_outToIn)) ||
                  ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) && (someoneValidToProtect_outToIn))) {
                if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                }

                if (!protectionUserExit) {
                  protectionUserExit = true;
                  soapDFlow_addEventToSend(ns2__EventEnumType__EXIT_USCOREDOOR_USCOREPROTECTING);
                  sentEventExitDoorProtecting = true;
                  if (DoorStatus_ExitDoorsWithCorrectStatus(statusDoor)) {
                    previousPercentageDoor_EXT = ((((angleDoor[DOOR_07] + angleDoor[DOOR_11]) / 2) * 100) / 90);
                  } else if (DoorStatus_DoorWithCorrectStatus(DOOR_07, statusDoor)) {
                    previousPercentageDoor_EXT = ((angleDoor[DOOR_07] * 100) / 90);
                  } else if (DoorStatus_DoorWithCorrectStatus(DOOR_11, statusDoor)) {
                    previousPercentageDoor_EXT = ((angleDoor[DOOR_11] * 100) / 90);
                  } else {
                    previousPercentageDoor_EXT = 0;
                  }
                }
                if (doorStatePersonProtect == STOP_DOOR || doorStatePersonProtect == BRAKE_DOOR) {
                  LOG_IF_F(1, STDERR_DEBUG, "Stop Doors");
                  stopDoorsExit = true;
                } else if (doorStatePersonProtect == LAST_ANGLE) {
                  DoorCtrl_CloseInDoorPercentage(currentPercentageDoor_ENT);
                  DoorCtrl_CloseOutDoorPercentage(previousPercentageDoor_EXT);
                }
                VideoAnalyzer_SetDoorIntense(DOOR_EXT, (previousPercentageDoor_EXT * 255) / 100);
                previousPercentageDoor_ENT = currentPercentageDoor_ENT;
                forceDoor = DOOR_EXT;
                // Deve fechar portas mas não pode
                _doorClosingForce = MustForceDoorMove(forceDoor, statusDoor, angleDoor, currentPercentageDoor_ENT,
                                                      currentPercentageDoor_EXT);
                _flagWaitingInvalidUserGetOut = true;
              } else {
                if (previousPercentageDoor_ENT >= 0 && previousPercentageDoor_ENT <= DIFF_ANGLE) {
                  _flagWaitingInvalidUserGetOut = false;
                }

                if ((_flagWaitingInvalidUserGetOut) && (somethingToProtect_inToOut || someoneToProtect_inToOut)) {
                  LOG_IF_F(1, STDERR_DEBUG,
                           "Alguma coisa na regiao de protecao das portas, as mesmas nao sao acionadas");
                  DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                  DoorCtrl_CloseOutDoorPercentage(previousPercentageDoor_EXT);
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona portas");
                  DoorCtrl_CloseInDoorPercentage(DOOR_OPEN_ENTRANCE);
                  DoorCtrl_CloseOutDoorPercentage(currentPercentageDoor_EXT);
                  previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
                  previousPercentageDoor_EXT = currentPercentageDoor_EXT;
                  _flagWaitingInvalidUserGetOut = false;
                  if (protectionUserExit) {
                    protectionUserExit = false;
                    if (sentEventExitDoorProtecting) {
                      soapDFlow_addEventToSend(ns2__EventEnumType__EXIT_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
                      sentEventExitDoorProtecting = false;
                    }
                  }
                }
              }
            } else if (currentPercentageDoor_ENT && currentPercentageDoor_EXT) {
              LOG_IF_F(1, STDERR_DEBUG, "Pessoa invalida na entrada e na saida");
              if (!_flagWaitingInvalidUserGetOut) {
                _flagWaitingInvalidUserGetOut = true;

                if (currentPercentageDoor_ENT && currentPercentageDoor_EXT) {
                  if (currentPercentageDoor_ENT >= currentPercentageDoor_EXT) {
                    if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                         (somethingToProtect_inToOut || someoneToProtect_inToOut)) ||
                        ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_inToOut)) ||
                        ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) && (someoneValidToProtect_inToOut))) {
                      if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                        LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                      } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                        LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                      } else {
                        LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                      }

                      if (!protectionUserEntrance) {
                        protectionUserEntrance = true;
                        soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING);
                        sentEventEntranceDoorProtecting = true;
                        if (DoorStatus_EntranceDoorsWithCorrectStatus(statusDoor)) {
                          previousPercentageDoor_ENT = ((((angleDoor[DOOR_06] + angleDoor[DOOR_10]) / 2) * 100) / 90);
                        } else if (DoorStatus_DoorWithCorrectStatus(DOOR_06, statusDoor)) {
                          previousPercentageDoor_ENT = ((angleDoor[DOOR_06] * 100) / 90);
                        } else if (DoorStatus_DoorWithCorrectStatus(DOOR_10, statusDoor)) {
                          previousPercentageDoor_ENT = ((angleDoor[DOOR_10] * 100) / 90);
                        } else {
                          previousPercentageDoor_ENT = 0;
                        }
                      }
                      if (doorStatePersonProtect == STOP_DOOR || doorStatePersonProtect == BRAKE_DOOR) {
                        LOG_IF_F(1, STDERR_DEBUG, "Stop Doors");
                        stopDoorsEntrance = true;
                      } else if (doorStatePersonProtect == LAST_ANGLE) {
                        DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                        DoorCtrl_CloseOutDoorPercentage(previousPercentageDoor_EXT);
                      }
                      VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                      VideoAnalyzer_SetDoorIntense(DOOR_EXT, (previousPercentageDoor_EXT * 255) / 100);
                      forceDoor = DOOR_ENT;
                      // Deve fechar portas mas não pode
                      _doorClosingForce = MustForceDoorMove(forceDoor, statusDoor, angleDoor, currentPercentageDoor_ENT,
                                                            currentPercentageDoor_EXT);
                    } else {
                      LOG_IF_F(1, STDERR_DEBUG, "Fecha porta da entrada");
                      DoorCtrl_CloseInDoorPercentage(DOOR_CLOSED_CENTRALIZED);
                      DoorCtrl_CloseOutDoorPercentage(DOOR_OPEN_ENTRANCE);
                      previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
                      previousPercentageDoor_EXT = ((DoorCtrl_GetDoorAngleOut() * 100) / 90);
                      DoorCtrl_SetDoorSpeedIn(100);
                      if (protectionUserEntrance) {
                        protectionUserEntrance = false;
                        if (sentEventEntranceDoorProtecting) {
                          soapDFlow_addEventToSend(
                              ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
                          sentEventEntranceDoorProtecting = false;
                        }
                      }
                    }
                  } else {
                    if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                         (somethingToProtect_outToIn || someoneToProtect_outToIn)) ||
                        ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_outToIn)) ||
                        ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) && (someoneValidToProtect_outToIn))) {
                      if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                        LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                      } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                        LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                      } else {
                        LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                      }

                      if (!protectionUserExit) {
                        protectionUserExit = true;
                        soapDFlow_addEventToSend(ns2__EventEnumType__EXIT_USCOREDOOR_USCOREPROTECTING);
                        sentEventExitDoorProtecting = true;
                        if (DoorStatus_ExitDoorsWithCorrectStatus(statusDoor)) {
                          previousPercentageDoor_EXT = ((((angleDoor[DOOR_07] + angleDoor[DOOR_11]) / 2) * 100) / 90);
                        } else if (DoorStatus_DoorWithCorrectStatus(DOOR_07, statusDoor)) {
                          previousPercentageDoor_EXT = ((angleDoor[DOOR_07] * 100) / 90);
                        } else if (DoorStatus_DoorWithCorrectStatus(DOOR_11, statusDoor)) {
                          previousPercentageDoor_EXT = ((angleDoor[DOOR_11] * 100) / 90);
                        } else {
                          previousPercentageDoor_EXT = 0;
                        }
                      }
                      if (doorStatePersonProtect == STOP_DOOR || doorStatePersonProtect == BRAKE_DOOR) {
                        LOG_IF_F(1, STDERR_DEBUG, "Stop Doors");
                        stopDoorsEntrance = true;
                      } else if (doorStatePersonProtect == LAST_ANGLE) {
                        DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                        DoorCtrl_CloseOutDoorPercentage(previousPercentageDoor_EXT);
                      }
                      VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                      VideoAnalyzer_SetDoorIntense(DOOR_EXT, (previousPercentageDoor_EXT * 255) / 100);
                      forceDoor = DOOR_EXT;
                      // Deve fechar portas mas não pode
                      _doorClosingForce = MustForceDoorMove(forceDoor, statusDoor, angleDoor, currentPercentageDoor_ENT,
                                                            currentPercentageDoor_EXT);
                    } else {
                      LOG_IF_F(1, STDERR_DEBUG, "Fecha porta da saida");
                      DoorCtrl_CloseInDoorPercentage(DOOR_OPEN_ENTRANCE);
                      DoorCtrl_CloseOutDoorPercentage(DOOR_CLOSED_CENTRALIZED);
                      previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
                      previousPercentageDoor_EXT = ((DoorCtrl_GetDoorAngleOut() * 100) / 90);
                      DoorCtrl_SetDoorSpeedOut(100);
                      if (protectionUserExit) {
                        protectionUserExit = false;
                        if (sentEventExitDoorProtecting) {
                          soapDFlow_addEventToSend(ns2__EventEnumType__EXIT_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
                          sentEventExitDoorProtecting = false;
                        }
                      }
                    }
                  }
                } else {
                  // close the door to the closer person in the bloq
                  switch (VideoAnalyzer_GetCenterCloserInvalidPersonWay()) {
                    case VALIDATION_WAY_IN_OUT: {
                      // close the entrance
                      if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                           (somethingToProtect_inToOut || someoneToProtect_inToOut)) ||
                          ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_inToOut)) ||
                          ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) && (someoneValidToProtect_inToOut))) {
                        if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                          LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                        } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                          LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                        } else {
                          LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                        }

                        if (!protectionUserEntrance) {
                          protectionUserEntrance = true;
                          soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING);
                          sentEventEntranceDoorProtecting = true;
                          if (DoorStatus_EntranceDoorsWithCorrectStatus(statusDoor)) {
                            previousPercentageDoor_ENT = ((((angleDoor[DOOR_06] + angleDoor[DOOR_10]) / 2) * 100) / 90);
                          } else if (DoorStatus_DoorWithCorrectStatus(DOOR_06, statusDoor)) {
                            previousPercentageDoor_ENT = ((angleDoor[DOOR_06] * 100) / 90);
                          } else if (DoorStatus_DoorWithCorrectStatus(DOOR_10, statusDoor)) {
                            previousPercentageDoor_ENT = ((angleDoor[DOOR_10] * 100) / 90);
                          } else {
                            previousPercentageDoor_ENT = 0;
                          }
                        }
                        if (doorStatePersonProtect == STOP_DOOR || doorStatePersonProtect == BRAKE_DOOR) {
                          LOG_IF_F(1, STDERR_DEBUG, "Stop Doors");
                          stopDoorsEntrance = true;
                        } else if (doorStatePersonProtect == LAST_ANGLE) {
                          DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                          DoorCtrl_CloseOutDoorPercentage(previousPercentageDoor_EXT);
                        }
                        VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                        VideoAnalyzer_SetDoorIntense(DOOR_EXT, (previousPercentageDoor_EXT * 255) / 100);
                        forceDoor = DOOR_ENT;
                        // Deve fechar portas mas não pode
                        _doorClosingForce = MustForceDoorMove(forceDoor, statusDoor, angleDoor,
                                                              currentPercentageDoor_ENT, currentPercentageDoor_EXT);
                      } else {
                        LOG_IF_F(1, STDERR_DEBUG, "Fecha porta da entrada");
                        DoorCtrl_CloseInDoorPercentage(DOOR_CLOSED_CENTRALIZED);
                        DoorCtrl_CloseOutDoorPercentage(DOOR_OPEN_ENTRANCE);
                        previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
                        previousPercentageDoor_EXT = ((DoorCtrl_GetDoorAngleOut() * 100) / 90);
                        if (protectionUserEntrance) {
                          protectionUserEntrance = false;
                          if (sentEventEntranceDoorProtecting) {
                            soapDFlow_addEventToSend(
                                ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
                            sentEventEntranceDoorProtecting = false;
                          }
                        }
                      }
                      break;
                    }
                    case VALIDATION_WAY_OUT_IN: {
                      // close the exit
                      if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                           (somethingToProtect_outToIn || someoneToProtect_outToIn)) ||
                          ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_outToIn)) ||
                          ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) && (someoneValidToProtect_outToIn))) {
                        if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                          LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                        } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                          LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                        } else {
                          LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                        }

                        if (!protectionUserExit) {
                          protectionUserExit = true;
                          soapDFlow_addEventToSend(ns2__EventEnumType__EXIT_USCOREDOOR_USCOREPROTECTING);
                          sentEventExitDoorProtecting = true;
                          if (DoorStatus_ExitDoorsWithCorrectStatus(statusDoor)) {
                            previousPercentageDoor_EXT = ((((angleDoor[DOOR_07] + angleDoor[DOOR_11]) / 2) * 100) / 90);
                          } else if (DoorStatus_DoorWithCorrectStatus(DOOR_07, statusDoor)) {
                            previousPercentageDoor_EXT = ((angleDoor[DOOR_07] * 100) / 90);
                          } else if (DoorStatus_DoorWithCorrectStatus(DOOR_11, statusDoor)) {
                            previousPercentageDoor_EXT = ((angleDoor[DOOR_11] * 100) / 90);
                          } else {
                            previousPercentageDoor_EXT = 0;
                          }
                        }
                        if (doorStatePersonProtect == STOP_DOOR || doorStatePersonProtect == BRAKE_DOOR) {
                          LOG_IF_F(1, STDERR_DEBUG, "Stop Doors");
                          stopDoorsEntrance = true;
                        } else if (doorStatePersonProtect == LAST_ANGLE) {
                          DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                          DoorCtrl_CloseOutDoorPercentage(previousPercentageDoor_EXT);
                        }
                        VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                        VideoAnalyzer_SetDoorIntense(DOOR_EXT, (previousPercentageDoor_EXT * 255) / 100);
                        forceDoor = DOOR_EXT;
                        // Deve fechar portas mas não pode
                        _doorClosingForce = MustForceDoorMove(forceDoor, statusDoor, angleDoor,
                                                              currentPercentageDoor_ENT, currentPercentageDoor_EXT);
                      } else {
                        LOG_IF_F(1, STDERR_DEBUG, "Fecha porta da saida");
                        DoorCtrl_CloseInDoorPercentage(DOOR_OPEN_ENTRANCE);
                        DoorCtrl_CloseOutDoorPercentage(DOOR_CLOSED_CENTRALIZED);
                        previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
                        previousPercentageDoor_EXT = ((DoorCtrl_GetDoorAngleOut() * 100) / 90);
                        if (protectionUserExit) {
                          protectionUserExit = false;
                          if (sentEventExitDoorProtecting) {
                            soapDFlow_addEventToSend(ns2__EventEnumType__EXIT_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
                            sentEventExitDoorProtecting = false;
                          }
                        }
                      }
                      break;
                    }
                    default:
                      break;
                  }
                }
              } else {
                LOG_IF_F(1, STDERR_DEBUG, "Mantem portas conforme ultima posicao");
                if ((previousPercentageDoor_ENT >= previousPercentageDoor_EXT) &&
                    (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                      (somethingToProtect_inToOut || someoneToProtect_inToOut)) ||
                     ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_inToOut)) ||
                     ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) && (someoneValidToProtect_inToOut)))) {
                  if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                    LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                  } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                    LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                  } else {
                    LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                  }
                  forceDoor = DOOR_ENT;
                  // Deve fechar portas mas não pode
                  _doorClosingForce = MustForceDoorMove(forceDoor, statusDoor, angleDoor, currentPercentageDoor_ENT,
                                                        currentPercentageDoor_EXT);
                } else if ((previousPercentageDoor_ENT < previousPercentageDoor_EXT) &&
                           (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                             (somethingToProtect_outToIn || someoneToProtect_outToIn)) ||
                            ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_outToIn)) ||
                            ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) &&
                             (someoneValidToProtect_outToIn)))) {
                  if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                    LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                  } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                    LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                  } else {
                    LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                  }
                  forceDoor = DOOR_EXT;
                  // Deve fechar portas mas não pode
                  _doorClosingForce = MustForceDoorMove(forceDoor, statusDoor, angleDoor, currentPercentageDoor_ENT,
                                                        currentPercentageDoor_EXT);
                }
                DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                DoorCtrl_CloseOutDoorPercentage(previousPercentageDoor_EXT);
              }
            } else {
              LOG_IF_F(1, STDERR_DEBUG, "Ninguem invalido");
              _flagWaitingInvalidUserGetOut = false;

              if (protectionUserEntrance) {
                protectionUserEntrance = false;
                if (sentEventEntranceDoorProtecting) {
                  soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
                  sentEventEntranceDoorProtecting = false;
                }
              } else if (protectionUserExit) {
                protectionUserExit = false;
                if (sentEventExitDoorProtecting) {
                  soapDFlow_addEventToSend(ns2__EventEnumType__EXIT_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
                  sentEventExitDoorProtecting = false;
                }
              }

              if (((somethingToProtect_inToOut || someoneToProtect_inToOut) && (!onlyOneValidPerson_InToOut)) &&
                  ((somethingToProtect_outToIn || someoneToProtect_outToIn) && (!onlyOneValidPerson_OutToIn))) {
                LOG_IF_F(1, STDERR_DEBUG, "Protege alguma coisa na entrada e saida");
                DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                DoorCtrl_CloseOutDoorPercentage(previousPercentageDoor_EXT);
              } else if ((somethingToProtect_inToOut || someoneToProtect_inToOut) && (!onlyOneValidPerson_InToOut)) {
                LOG_IF_F(1, STDERR_DEBUG, "Protege alguma coisa na entrada");
                DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                DoorCtrl_CloseOutDoorPercentage(DOOR_OPEN_ENTRANCE);
                previousPercentageDoor_EXT = ((DoorCtrl_GetDoorAngleOut() * 100) / 90);
              } else if ((somethingToProtect_outToIn || someoneToProtect_outToIn) && (!onlyOneValidPerson_OutToIn)) {
                LOG_IF_F(1, STDERR_DEBUG, "Protege alguma coisa na saida");
                DoorCtrl_CloseInDoorPercentage(DOOR_OPEN_ENTRANCE);
                DoorCtrl_CloseOutDoorPercentage(previousPercentageDoor_EXT);
                previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
              } else {
                LOG_IF_F(1, STDERR_DEBUG, "Abre as portas");
                DoorCtrl_CloseInDoorPercentage(DOOR_OPEN_ENTRANCE);
                DoorCtrl_CloseOutDoorPercentage(DOOR_OPEN_ENTRANCE);
                previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
                previousPercentageDoor_EXT = ((DoorCtrl_GetDoorAngleOut() * 100) / 90);
              }
            }

            if (actionModule_getOpModeDoor() == DOOR_MODE_DECENTRALIZED_OPEN) {
              DoorCtrl_CloseOutDoorPercentage(DOOR_OPEN_ENTRANCE);
            }

//#define DBG_ANGLE_SPEED_DOORS
#ifdef DBG_ANGLE_SPEED_DOORS
            static uint8_t tmpAngleIn = 0;
            static uint8_t tmpAngleOut = 0;
            static uint8_t tmpSpeedIn = 0;
            static uint8_t tmpSpeedOut = 0;
            if (tmpAngleIn != DoorCtrl_GetDoorAngleIn() || tmpAngleOut != DoorCtrl_GetDoorAngleOut() ||
                tmpSpeedIn != DoorCtrl_GetDoorSpeedIn() || tmpSpeedOut != DoorCtrl_GetDoorSpeedOut()) {
              tmpAngleIn = DoorCtrl_GetDoorAngleIn();
              tmpAngleOut = DoorCtrl_GetDoorAngleOut();
              tmpSpeedIn = DoorCtrl_GetDoorSpeedIn();
              tmpSpeedOut = DoorCtrl_GetDoorSpeedOut();
              LOG_F(INFO, "AngleIn: %d | SpeedIn: %d", tmpAngleIn, tmpSpeedIn);
              LOG_F(INFO, "AngleOut: %d | SpeedOut: %d", tmpAngleOut, tmpSpeedOut);
            }
#endif

//#define TESTE_BRAKE
#ifdef TESTE_BRAKE
            static bool lastStateBrakeEntrance = false;
            static bool lastStateBrakeExit = false;
            if (lastStateBrakeEntrance != stopDoorsEntrance) {
              lastStateBrakeEntrance = stopDoorsEntrance;
              if (stopDoorsEntrance) {
                LOG_F(ERROR, "BRAKE_DOOR ENTRANCE");
              } else {
                LOG_F(WARNING, "FREE DOOR ENTRANCE");
              }
            }
            if (lastStateBrakeExit != stopDoorsExit) {
              lastStateBrakeExit = stopDoorsExit;
              if (stopDoorsExit) {
                LOG_F(ERROR, "BRAKE_DOOR EXIT");
              } else {
                LOG_F(WARNING, "FREE DOOR EXIT");
              }
            }
#endif

            if (stopDoorsEntrance) {
              if (doorStatePersonProtect == STOP_DOOR) {
                IndicLum_AddMemStopDoor(DOOR_ENTRANCE);
              } else if (doorStatePersonProtect == BRAKE_DOOR && currentPercentageDoor_ENT) {
                IndicLum_AddMemLockBrake_SwitchOffMotor(DOOR_ENTRANCE, 255);
              }
            } else {
              IndicLum_AddMemAngleDoor(DOOR_ENTRANCE, DoorCtrl_GetDoorAngleIn(), DoorCtrl_GetDoorSpeedIn());
            }
            if (stopDoorsExit) {
              if (doorStatePersonProtect == STOP_DOOR) {
                IndicLum_AddMemStopDoor(DOOR_EXIT);
              } else if (doorStatePersonProtect == BRAKE_DOOR && currentPercentageDoor_EXT) {
                IndicLum_AddMemLockBrake_SwitchOffMotor(DOOR_EXIT, 255);
              }
            } else {
              IndicLum_AddMemAngleDoor(DOOR_EXIT, DoorCtrl_GetDoorAngleOut(), DoorCtrl_GetDoorSpeedOut());
            }
          } else if (actionModule_getOpModeDoor() == DOOR_MODE_DECENTRALIZED_CLOSED) {
            //*******************************************************************************************************/
            const bool debugCloseMode = false;
            LOG_IF_F(INFO, STDERR_DEBUG, "CLOSED MODE DOORS: DECENTRALIZED");
            // Abre a porta da saida, se existir
            DoorCtrl_CloseOutDoorPercentage(DOOR_OPEN_ENTRANCE);
            uint16_t minAngle = 90 - DoorsComments::DIFF_ANGLE;
            uint16_t entryDoorsAngle = ((angleDoor[DOOR_06] + angleDoor[DOOR_10]) * 0.5);
            bool someoneOutToInToProtect_EntranceDoors = VideoAnalyzer_SomeoneOutToInToProtect_EntranceDoors();
            bool isNotClosedDoors = (entryDoorsAngle < minAngle);
            bool openDoors = ((isValidationRegionBarrier_inToOut && flagOpenDoorsOnlyPersonValidInside) ||
                              (isValidationAvailable_inToOut && !flagOpenDoorsOnlyPersonValidInside));
            bool isProtect = ((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT &&
                               (somethingToProtect_inToOut || someoneToProtect_inToOut)) ||
                              (levelOfUserProtection == PROTECTION_LEVEL_ANYONE && someoneToProtect_inToOut) ||
                              (levelOfUserProtection == PROTECTION_LEVEL_VALID_USER && someoneValidToProtect_inToOut));

            if (doorStatePersonProtect == BRAKE_DOOR && doorCtrl_IsToBrakeClosedDoors()) {
              forceBrake = stopDoorsEntrance = true;
            } else if (openDoors && !currentPercentageDoor_ENT && !someoneOutToInToProtect_EntranceDoors) {
              LOG_IF_F(WARNING, debugCloseMode || STDERR_DEBUG, "Open doors");
              if (protectionUserEntrance) {
                protectionUserEntrance = false;
                soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
              }
              DoorCtrl_CloseInDoorPercentage(DOOR_OPEN_ENTRANCE);
              previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
            } else {
              // Test if protect someone or something
              if ((isNotClosedDoors && !currentPercentageDoor_ENT && somethingToProtect_inToOut) ||
                  (openDoors && someoneOutToInToProtect_EntranceDoors) ||
                  (currentPercentageDoor_ENT > previousPercentageDoor_ENT && isNotClosedDoors && isProtect)) {
                LOG_IF_F(WARNING, debugCloseMode || STDERR_DEBUG, "Dont move doors - Protecting");
                if (!protectionUserEntrance) {
                  protectionUserEntrance = true;
                  soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING);
                }
                if (doorStatePersonProtect == STOP_DOOR || doorStatePersonProtect == BRAKE_DOOR) {
                  LOG_IF_F(WARNING, debugCloseMode || STDERR_DEBUG, "Stop Doors");
                  stopDoorsEntrance = true;
                } else if (doorStatePersonProtect == LAST_ANGLE) {
                  DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                }
                VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                forceDoor = DOOR_ENT;
                // Deve fechar portas mas não pode
                _doorClosingForce = MustForceDoorMove(forceDoor, statusDoor, angleDoor, currentPercentageDoor_ENT,
                                                      currentPercentageDoor_EXT);
              } else {
                LOG_IF_F(WARNING, debugCloseMode || STDERR_DEBUG, "Close doors");
                if (protectionUserEntrance) {
                  protectionUserEntrance = false;
                  soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
                }
                DoorCtrl_CloseInDoorPercentage(DOOR_CLOSED_CENTRALIZED);
                previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
              }
            }

            static TimeoutCpp timeToReleaseBrake;
            static bool wasSetBrake = false;
            if (stopDoorsEntrance) {
              if (!forceBrake || doorStatePersonProtect == STOP_DOOR) {
                IndicLum_AddMemStopDoor(DOOR_ENTRANCE);
              } else if (doorStatePersonProtect == BRAKE_DOOR &&
                         (forceBrake || (currentPercentageDoor_ENT || currentPercentageDoor_EXT))) {
                IndicLum_AddMemLockBrake_SwitchOffMotor(DOOR_ENTRANCE, 255);
                wasSetBrake = true;
                timeToReleaseBrake.Start(500);
              }
            } else {
              IndicLum_AddMemAngleDoor(DOOR_ENTRANCE, DoorCtrl_GetDoorAngleIn(), DoorCtrl_GetDoorSpeedIn());
            }

            if (doorStatePersonProtect == BRAKE_DOOR && wasSetBrake && !DoorCtrl_GetDoorAngleIn()) {
              bool door06StillClosed = angleDoor[DOOR_06] > 70 && angleDoor[DOOR_06] < 100;
              bool door10StillClosed = angleDoor[DOOR_10] > 70 && angleDoor[DOOR_10] < 100;
              if (/*DoorStatus_ForcingEntrance() && */ (door06StillClosed || door10StillClosed)) {
                const static uint64_t timeBetweenShake = 2000;  // Cada movimento demora 1s (para cada lado), portanto
                                                                // não convem enviar com tempo menor que 2s.
                if (timeToReleaseBrake.CheckAndRestart(timeBetweenShake)) {
                  uint8_t addrShake = DOOR_ENTRANCE;
                  if (door06StillClosed && !door10StillClosed)
                    addrShake = 06;
                  else if (!door06StillClosed && door10StillClosed)
                    addrShake = 10;
                  IndicLum_ClearMemDoor();
                  IndicLum_AddMemShakeDoor(addrShake);
                }
              } else if (!door06StillClosed && !door10StillClosed) {
                timeToReleaseBrake.Stop();
                wasSetBrake = false;
              }
            }

            IndicLum_AddMemAngleDoor(DOOR_EXIT, DoorCtrl_GetDoorAngleOut(), DoorCtrl_GetDoorSpeedOut());
          } else if (actionModule_getOpModeDoor() == DOOR_MODE_CENTRALIZED_CLOSED) {
            //*******************************************************************************************************/
            LOG_IF_F(1, STDERR_DEBUG, "CLOSED MODE DOORS: CENTRALIZED");

            DoorCtrl_CloseOutDoorPercentage(0);
#define timeoutOpenDoorsSomethingProtect 250  // ms

            if (doorStatePersonProtect == BRAKE_DOOR && doorCtrl_IsToBrakeClosedDoors()) {
              forceBrake = stopDoorsEntrance = true;
            } else if ((((isValidationRegionBarrier_inToOut) && (flagOpenDoorsOnlyPersonValidInside)) ||
                        ((isValidationAvailable_inToOut) && (!flagOpenDoorsOnlyPersonValidInside)) ||
                        ((somethingToProtect_outToIn || someoneToProtect_outToIn) &&
                         (actionModule_getStateIn() == OP_STATE_FREE))) &&
                       (((isValidationRegionBarrier_outToIn) && (flagOpenDoorsOnlyPersonValidInside)) ||
                        ((isValidationAvailable_outToIn) && (!flagOpenDoorsOnlyPersonValidInside)) ||
                        ((somethingToProtect_inToOut || someoneToProtect_inToOut) &&
                         (actionModule_getStateOut() == OP_STATE_FREE))) &&
                       !invalidPersonInside_inToOut && !invalidPersonInside_outToIn) {
              LOG_IF_F(1, STDERR_DEBUG,
                       "Validacao ou pessoa validada na entrada e validacao ou pessoa validada na saida e ninguem "
                       "invalido");
              bool endTimeoutEntranceFree = false;

              if (((isValidationRegionBarrier_inToOut) && (flagOpenDoorsOnlyPersonValidInside)) ||
                  ((isValidationAvailable_inToOut) && (!flagOpenDoorsOnlyPersonValidInside))) {
                endTimeoutEntranceFree = true;
              } else if ((actionModule_getStateIn() == OP_STATE_FREE) &&
                         (somethingToProtect_outToIn || someoneToProtect_outToIn)) {
                if (previousPercentageDoor_ENT >= (DOOR_CLOSED_CENTRALIZED + DIFF_ANGLE) ||
                    previousPercentageDoor_ENT <= (DOOR_CLOSED_CENTRALIZED - DIFF_ANGLE)) {
                  endTimeoutEntranceFree = true;
                } else if (Timeout_Check(timeoutSomethingProtectOutToIn)) {
                  LOG_IF_F(1, STDERR_DEBUG, "End timeout timeoutSomethingProtectOutToIn");
                  endTimeoutEntranceFree = true;
                } else if (!Timeout_IsStarted(timeoutSomethingProtectOutToIn)) {
                  LOG_IF_F(1, STDERR_DEBUG, "Start timeout timeoutSomethingProtectOutToIn");
                  Timeout_Start(timeoutSomethingProtectOutToIn, timeoutOpenDoorsSomethingProtect);
                }
              }

              bool endTimeoutExitFree = false;

              if (((isValidationRegionBarrier_outToIn) && (flagOpenDoorsOnlyPersonValidInside)) ||
                  ((isValidationAvailable_outToIn) && (!flagOpenDoorsOnlyPersonValidInside))) {
                endTimeoutExitFree = true;
              } else if ((actionModule_getStateOut() == OP_STATE_FREE) &&
                         (somethingToProtect_inToOut || someoneToProtect_inToOut)) {
                if (previousPercentageDoor_ENT >= (DOOR_CLOSED_CENTRALIZED + DIFF_ANGLE) ||
                    previousPercentageDoor_ENT <= (DOOR_CLOSED_CENTRALIZED - DIFF_ANGLE)) {
                  endTimeoutExitFree = true;
                } else if (Timeout_Check(timeoutSomethingProtectInToOut)) {
                  LOG_IF_F(1, STDERR_DEBUG, "End timeout timeoutSomethingProtectInToOut");
                  endTimeoutExitFree = true;
                } else if (!Timeout_IsStarted(timeoutSomethingProtectInToOut)) {
                  LOG_IF_F(1, STDERR_DEBUG, "Start timeout timeoutSomethingProtectInToOut");
                  Timeout_Start(timeoutSomethingProtectInToOut, timeoutOpenDoorsSomethingProtect);
                }
              }

              if (endTimeoutEntranceFree || endTimeoutExitFree) {
                if (previousPercentageDoor_ENT >= (DOOR_CLOSED_CENTRALIZED - DIFF_ANGLE) &&
                    previousPercentageDoor_ENT <= (DOOR_CLOSED_CENTRALIZED + DIFF_ANGLE)) {
                  if ((!somethingToProtect_inToOut && !someoneToProtect_inToOut) || (onlyOneValidPerson_InToOut)) {
                    LOG_IF_F(1, STDERR_DEBUG, "Abre a porta na entrada");
                    DoorCtrl_CloseInDoorPercentage(DOOR_OPEN_ENTRANCE);
                    previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
                    if (protectionUserEntrance) {
                      protectionUserEntrance = false;
                      if (sentEventEntranceDoorProtecting) {
                        soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
                        sentEventEntranceDoorProtecting = false;
                      }
                    }
                  } else if ((!somethingToProtect_outToIn && !someoneToProtect_outToIn) ||
                             (onlyOneValidPerson_OutToIn)) {
                    LOG_IF_F(1, STDERR_DEBUG, "Abre a porta na saida");
                    DoorCtrl_CloseInDoorPercentage(DOOR_OPEN_EXIT);
                    previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
                    if (protectionUserEntrance) {
                      protectionUserEntrance = false;
                      if (sentEventEntranceDoorProtecting) {
                        soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
                        sentEventEntranceDoorProtecting = false;
                      }
                    }
                  } else {
                    LOG_IF_F(1, STDERR_DEBUG, "Protege alguma coisa, mantem a porta na posicao anterior");
                    if (!protectionUserEntrance) {
                      protectionUserEntrance = true;
                      soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING);
                      sentEventEntranceDoorProtecting = true;
                      if (DoorStatus_EntranceDoorsWithCorrectStatus(statusDoor)) {
                        previousPercentageDoor_ENT = ((((angleDoor[DOOR_06] + angleDoor[DOOR_10]) / 2) * 100) / 90);
                      } else if (DoorStatus_DoorWithCorrectStatus(DOOR_06, statusDoor)) {
                        previousPercentageDoor_ENT = ((angleDoor[DOOR_06] * 100) / 90);
                      } else if (DoorStatus_DoorWithCorrectStatus(DOOR_10, statusDoor)) {
                        previousPercentageDoor_ENT = ((angleDoor[DOOR_10] * 100) / 90);
                      } else {
                        previousPercentageDoor_ENT = 0;
                      }
                    }
                    if (doorStatePersonProtect == STOP_DOOR || doorStatePersonProtect == BRAKE_DOOR) {
                      LOG_IF_F(1, STDERR_DEBUG, "Stop Doors");
                      stopDoorsEntrance = true;
                      if (currentPercentageDoor_ENT) {
                        VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                      }
                    } else if (doorStatePersonProtect == LAST_ANGLE) {
                      DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                      VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                    }
                  }
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Porta ja esta aberta, mantem a porta na posicao anterior");
                  DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                }
              }
            } else if (((isValidationRegionBarrier_inToOut) && (flagOpenDoorsOnlyPersonValidInside)) ||
                       ((isValidationAvailable_inToOut) && (!flagOpenDoorsOnlyPersonValidInside)) ||
                       ((somethingToProtect_outToIn || someoneToProtect_outToIn) &&
                        (actionModule_getStateIn() == OP_STATE_FREE))) {
              LOG_IF_F(1, STDERR_DEBUG, "Validacao ou pessoa validada na entrada");

              bool endTimeout = false;

              if (((isValidationRegionBarrier_inToOut) && (flagOpenDoorsOnlyPersonValidInside)) ||
                  ((isValidationAvailable_inToOut) && (!flagOpenDoorsOnlyPersonValidInside))) {
                endTimeout = true;
              } else if ((actionModule_getStateIn() == OP_STATE_FREE) &&
                         (somethingToProtect_outToIn || someoneToProtect_outToIn)) {
                if (previousPercentageDoor_ENT >= (DOOR_CLOSED_CENTRALIZED + DIFF_ANGLE) ||
                    previousPercentageDoor_ENT <= (DOOR_CLOSED_CENTRALIZED - DIFF_ANGLE)) {
                  endTimeout = true;
                } else if (Timeout_Check(timeoutSomethingProtectOutToIn)) {
                  LOG_IF_F(1, STDERR_DEBUG, "End timeout timeoutSomethingProtectOutToIn");
                  endTimeout = true;
                } else if (!Timeout_IsStarted(timeoutSomethingProtectOutToIn)) {
                  LOG_IF_F(1, STDERR_DEBUG, "Start timeout timeoutSomethingProtectOutToIn");
                  Timeout_Start(timeoutSomethingProtectOutToIn, timeoutOpenDoorsSomethingProtect);
                }
              }

              if (endTimeout) {
                if (invalidPersonInside_inToOut && !invalidPersonInside_outToIn) {
                  if (previousPercentageDoor_ENT > (DOOR_OPEN_EXIT - DIFF_ANGLE)) {
                    LOG_IF_F(1, STDERR_DEBUG, "Porta aberta no sentido de saida, a mesma nao e acionada");
                    DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                    forceDoor = DOOR_ENT;
                    // Deve fechar portas mas não pode
                    _doorClosingForce = MustForceDoorMove(forceDoor, statusDoor, angleDoor, currentPercentageDoor_ENT,
                                                          currentPercentageDoor_EXT);
                  } else {
                    if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                         (somethingToProtect_inToOut || someoneToProtect_inToOut)) ||
                        ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_inToOut)) ||
                        ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) && (someoneValidToProtect_inToOut))) {
                      if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                        LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                      } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                        LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                      } else {
                        LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                      }

                      if (!protectionUserEntrance) {
                        protectionUserEntrance = true;
                        soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING);
                        sentEventEntranceDoorProtecting = true;
                        if (DoorStatus_EntranceDoorsWithCorrectStatus(statusDoor)) {
                          previousPercentageDoor_ENT = ((((angleDoor[DOOR_06] + angleDoor[DOOR_10]) / 2) * 100) / 90);
                        } else if (DoorStatus_DoorWithCorrectStatus(DOOR_06, statusDoor)) {
                          previousPercentageDoor_ENT = ((angleDoor[DOOR_06] * 100) / 90);
                        } else if (DoorStatus_DoorWithCorrectStatus(DOOR_10, statusDoor)) {
                          previousPercentageDoor_ENT = ((angleDoor[DOOR_10] * 100) / 90);
                        } else {
                          previousPercentageDoor_ENT = 0;
                        }
                      }
                      if (doorStatePersonProtect == STOP_DOOR || doorStatePersonProtect == BRAKE_DOOR) {
                        LOG_IF_F(1, STDERR_DEBUG, "Stop Doors");
                        stopDoorsEntrance = true;
                        if (currentPercentageDoor_ENT) {
                          VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                        }
                      } else if (doorStatePersonProtect == LAST_ANGLE) {
                        DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                        VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                      }
                      forceDoor = DOOR_ENT;
                      // Deve fechar portas mas não pode
                      _doorClosingForce = MustForceDoorMove(forceDoor, statusDoor, angleDoor, currentPercentageDoor_ENT,
                                                            currentPercentageDoor_EXT);
                    } else {
                      LOG_IF_F(1, STDERR_DEBUG, "Fecha a porta");
                      DoorCtrl_CloseInDoorPercentage(currentPercentageDoor_ENT);
                      previousPercentageDoor_ENT = currentPercentageDoor_ENT;
                      if (protectionUserEntrance) {
                        protectionUserEntrance = false;
                        if (sentEventEntranceDoorProtecting) {
                          soapDFlow_addEventToSend(
                              ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
                          sentEventEntranceDoorProtecting = false;
                        }
                      }
                    }
                  }
                } else {
                  if (((somethingToProtect_inToOut || someoneToProtect_inToOut) && (!onlyOneValidPerson_InToOut)) ||
                      (previousPercentageDoor_ENT > (DOOR_OPEN_EXIT - DIFF_ANGLE))) {
                    if (previousPercentageDoor_ENT > (DOOR_OPEN_EXIT - DIFF_ANGLE)) {
                      LOG_IF_F(1, STDERR_DEBUG, "Porta aberta no sentido de saida, a mesma nao e acionada");
                    } else {
                      LOG_IF_F(1, STDERR_DEBUG, "Protege alguem ou alguma coisa na entrada");
                    }

                    if (!protectionUserEntrance) {
                      protectionUserEntrance = true;
                      soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING);
                      sentEventEntranceDoorProtecting = true;
                      if (DoorStatus_EntranceDoorsWithCorrectStatus(statusDoor)) {
                        previousPercentageDoor_ENT = ((((angleDoor[DOOR_06] + angleDoor[DOOR_10]) / 2) * 100) / 90);
                      } else if (DoorStatus_DoorWithCorrectStatus(DOOR_06, statusDoor)) {
                        previousPercentageDoor_ENT = ((angleDoor[DOOR_06] * 100) / 90);
                      } else if (DoorStatus_DoorWithCorrectStatus(DOOR_10, statusDoor)) {
                        previousPercentageDoor_ENT = ((angleDoor[DOOR_10] * 100) / 90);
                      } else {
                        previousPercentageDoor_ENT = 0;
                      }
                    }
                    if (doorStatePersonProtect == STOP_DOOR || doorStatePersonProtect == BRAKE_DOOR) {
                      LOG_IF_F(1, STDERR_DEBUG, "Stop Doors");
                      stopDoorsEntrance = true;
                      if (currentPercentageDoor_ENT) {
                        VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                      }
                    } else if (doorStatePersonProtect == LAST_ANGLE) {
                      DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                      VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                    }
                  } else {
                    LOG_IF_F(1, STDERR_DEBUG, "Abre a porta");
                    DoorCtrl_CloseInDoorPercentage(DOOR_OPEN_ENTRANCE);
                    previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
                    if (protectionUserEntrance) {
                      protectionUserEntrance = false;
                      if (sentEventEntranceDoorProtecting) {
                        soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
                        sentEventEntranceDoorProtecting = false;
                      }
                    }
                  }
                }
              }
            } else if (((isValidationRegionBarrier_outToIn) && (flagOpenDoorsOnlyPersonValidInside)) ||
                       ((isValidationAvailable_outToIn) && (!flagOpenDoorsOnlyPersonValidInside)) ||
                       ((somethingToProtect_inToOut || someoneToProtect_inToOut) &&
                        (actionModule_getStateOut() == OP_STATE_FREE))) {
              LOG_IF_F(1, STDERR_DEBUG, "Validacao ou pessoa validada na saida");

              bool endTimeout = false;

              if (((isValidationRegionBarrier_outToIn) && (flagOpenDoorsOnlyPersonValidInside)) ||
                  ((isValidationAvailable_outToIn) && (!flagOpenDoorsOnlyPersonValidInside))) {
                endTimeout = true;
              } else if ((actionModule_getStateOut() == OP_STATE_FREE) &&
                         (somethingToProtect_inToOut || someoneToProtect_inToOut)) {
                if (previousPercentageDoor_ENT >= (DOOR_CLOSED_CENTRALIZED + DIFF_ANGLE) ||
                    previousPercentageDoor_ENT <= (DOOR_CLOSED_CENTRALIZED - DIFF_ANGLE)) {
                  endTimeout = true;
                } else if (Timeout_Check(timeoutSomethingProtectInToOut)) {
                  LOG_IF_F(1, STDERR_DEBUG, "End timeout timeoutSomethingProtectInToOut");
                  endTimeout = true;
                } else if (!Timeout_IsStarted(timeoutSomethingProtectInToOut)) {
                  LOG_IF_F(1, STDERR_DEBUG, "Start timeout timeoutSomethingProtectInToOut");
                  Timeout_Start(timeoutSomethingProtectInToOut, timeoutOpenDoorsSomethingProtect);
                }
              }

              if (endTimeout) {
                if (!invalidPersonInside_inToOut && invalidPersonInside_outToIn) {
                  if (previousPercentageDoor_ENT <= (DOOR_OPEN_ENTRANCE + DIFF_ANGLE)) {
                    LOG_IF_F(1, STDERR_DEBUG, "Porta aberta no sentido de saida, a mesma nao e acionada");
                    DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                    forceDoor = DOOR_ENT;
                    // Deve fechar portas mas não pode
                    _doorClosingForce = MustForceDoorMove(forceDoor, statusDoor, angleDoor, currentPercentageDoor_ENT,
                                                          currentPercentageDoor_EXT);
                  } else {
                    if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                         (somethingToProtect_outToIn || someoneToProtect_outToIn)) ||
                        ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_outToIn)) ||
                        ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) && (someoneValidToProtect_outToIn))) {
                      if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                        LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                      } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                        LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                      } else {
                        LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                      }

                      if (!protectionUserEntrance) {
                        protectionUserEntrance = true;
                        soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING);
                        sentEventEntranceDoorProtecting = true;
                        if (DoorStatus_EntranceDoorsWithCorrectStatus(statusDoor)) {
                          previousPercentageDoor_ENT = ((((angleDoor[DOOR_06] + angleDoor[DOOR_10]) / 2) * 100) / 90);
                        } else if (DoorStatus_DoorWithCorrectStatus(DOOR_06, statusDoor)) {
                          previousPercentageDoor_ENT = ((angleDoor[DOOR_06] * 100) / 90);
                        } else if (DoorStatus_DoorWithCorrectStatus(DOOR_10, statusDoor)) {
                          previousPercentageDoor_ENT = ((angleDoor[DOOR_10] * 100) / 90);
                        } else {
                          previousPercentageDoor_ENT = 0;
                        }
                      }
                      if (doorStatePersonProtect == STOP_DOOR || doorStatePersonProtect == BRAKE_DOOR) {
                        LOG_IF_F(1, STDERR_DEBUG, "Stop Doors");
                        stopDoorsEntrance = true;
                        if (currentPercentageDoor_ENT) {
                          VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                        }
                      } else if (doorStatePersonProtect == LAST_ANGLE) {
                        DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                        VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                      }
                      forceDoor = DOOR_ENT;
                      // Deve fechar portas mas não pode
                      _doorClosingForce = MustForceDoorMove(forceDoor, statusDoor, angleDoor, currentPercentageDoor_ENT,
                                                            currentPercentageDoor_EXT);
                    } else {
                      LOG_IF_F(1, STDERR_DEBUG, "Fecha a porta");
                      DoorCtrl_CloseInDoorPercentage(DOOR_OPEN_EXIT - currentPercentageDoor_EXT);
                      previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
                      if (protectionUserEntrance) {
                        protectionUserEntrance = false;
                        if (sentEventEntranceDoorProtecting) {
                          soapDFlow_addEventToSend(
                              ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
                          sentEventEntranceDoorProtecting = false;
                        }
                      }
                    }
                  }
                } else {
                  if (((somethingToProtect_outToIn || someoneToProtect_outToIn) && (!onlyOneValidPerson_OutToIn)) ||
                      (previousPercentageDoor_ENT <= (DOOR_OPEN_ENTRANCE + DIFF_ANGLE))) {
                    if (previousPercentageDoor_ENT <= (DOOR_OPEN_ENTRANCE + DIFF_ANGLE)) {
                      LOG_IF_F(1, STDERR_DEBUG, "Porta aberta no sentido de entrada, a mesma nao e acionada");
                    } else {
                      LOG_IF_F(1, STDERR_DEBUG, "Protege alguem ou alguma coisa na saida");
                    }

                    if (!protectionUserEntrance) {
                      protectionUserEntrance = true;
                      soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING);
                      sentEventEntranceDoorProtecting = true;
                      if (DoorStatus_EntranceDoorsWithCorrectStatus(statusDoor)) {
                        previousPercentageDoor_ENT = ((((angleDoor[DOOR_06] + angleDoor[DOOR_10]) / 2) * 100) / 90);
                      } else if (DoorStatus_DoorWithCorrectStatus(DOOR_06, statusDoor)) {
                        previousPercentageDoor_ENT = ((angleDoor[DOOR_06] * 100) / 90);
                      } else if (DoorStatus_DoorWithCorrectStatus(DOOR_10, statusDoor)) {
                        previousPercentageDoor_ENT = ((angleDoor[DOOR_10] * 100) / 90);
                      } else {
                        previousPercentageDoor_ENT = 0;
                      }
                    }
                    if (doorStatePersonProtect == STOP_DOOR || doorStatePersonProtect == BRAKE_DOOR) {
                      LOG_IF_F(1, STDERR_DEBUG, "Stop Doors");
                      stopDoorsEntrance = true;
                      if (currentPercentageDoor_ENT) {
                        VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                      }
                    } else if (doorStatePersonProtect == LAST_ANGLE) {
                      DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                      VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                    }
                  } else {
                    LOG_IF_F(1, STDERR_DEBUG, "Abre a porta");
                    DoorCtrl_CloseInDoorPercentage(DOOR_OPEN_EXIT);
                    previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
                    if (protectionUserEntrance) {
                      protectionUserEntrance = false;
                      if (sentEventEntranceDoorProtecting) {
                        soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
                        sentEventEntranceDoorProtecting = false;
                      }
                    }
                  }
                }
              }
            }  // OK
            else {
              if ((previousPercentageDoor_ENT <= (DOOR_CLOSED_CENTRALIZED - DIFF_ANGLE)) &&
                  (((currentPercentageDoor_ENT) &&
                    (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                      (somethingToProtect_inToOut || someoneToProtect_inToOut)) ||
                     ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_inToOut)) ||
                     ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) && (someoneValidToProtect_inToOut)))) ||
                   (!currentPercentageDoor_ENT && (somethingToProtect_inToOut || someoneToProtect_inToOut)))) {
                if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                }
                if (!protectionUserEntrance) {
                  protectionUserEntrance = true;
                  soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING);
                  sentEventEntranceDoorProtecting = true;
                  if (DoorStatus_EntranceDoorsWithCorrectStatus(statusDoor)) {
                    previousPercentageDoor_ENT = ((((angleDoor[DOOR_06] + angleDoor[DOOR_10]) / 2) * 100) / 90);
                  } else if (DoorStatus_DoorWithCorrectStatus(DOOR_06, statusDoor)) {
                    previousPercentageDoor_ENT = ((angleDoor[DOOR_06] * 100) / 90);
                  } else if (DoorStatus_DoorWithCorrectStatus(DOOR_10, statusDoor)) {
                    previousPercentageDoor_ENT = ((angleDoor[DOOR_10] * 100) / 90);
                  } else {
                    previousPercentageDoor_ENT = 0;
                  }
                }
                if (doorStatePersonProtect == STOP_DOOR || doorStatePersonProtect == BRAKE_DOOR) {
                  LOG_IF_F(1, STDERR_DEBUG, "Stop Doors");
                  stopDoorsEntrance = true;
                  if (currentPercentageDoor_ENT) {
                    VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                  }
                } else if (doorStatePersonProtect == LAST_ANGLE) {
                  DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                  VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                }
                forceDoor = DOOR_ENT;
                // Deve fechar portas mas não pode
                _doorClosingForce = MustForceDoorMove(forceDoor, statusDoor, angleDoor, currentPercentageDoor_ENT,
                                                      currentPercentageDoor_EXT);
              } else if ((previousPercentageDoor_ENT >= (DOOR_CLOSED_CENTRALIZED + DIFF_ANGLE)) &&
                         (((currentPercentageDoor_EXT) &&
                           (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                             (somethingToProtect_outToIn || someoneToProtect_outToIn)) ||
                            ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_outToIn)) ||
                            ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) &&
                             (someoneValidToProtect_outToIn)))) ||
                          (!currentPercentageDoor_EXT && (somethingToProtect_outToIn || someoneToProtect_outToIn)))) {
                if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                }
                if (!protectionUserEntrance) {
                  protectionUserEntrance = true;
                  soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING);
                  sentEventEntranceDoorProtecting = true;
                  if (DoorStatus_EntranceDoorsWithCorrectStatus(statusDoor)) {
                    previousPercentageDoor_ENT = ((((angleDoor[DOOR_06] + angleDoor[DOOR_10]) / 2) * 100) / 90);
                  } else if (DoorStatus_DoorWithCorrectStatus(DOOR_06, statusDoor)) {
                    previousPercentageDoor_ENT = ((angleDoor[DOOR_06] * 100) / 90);
                  } else if (DoorStatus_DoorWithCorrectStatus(DOOR_10, statusDoor)) {
                    previousPercentageDoor_ENT = ((angleDoor[DOOR_10] * 100) / 90);
                  } else {
                    previousPercentageDoor_ENT = 0;
                  }
                }
                if (doorStatePersonProtect == STOP_DOOR || doorStatePersonProtect == BRAKE_DOOR) {
                  LOG_IF_F(1, STDERR_DEBUG, "Stop Doors");
                  stopDoorsEntrance = true;
                  if (currentPercentageDoor_ENT) {
                    VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                  }
                } else if (doorStatePersonProtect == LAST_ANGLE) {
                  DoorCtrl_CloseInDoorPercentage(previousPercentageDoor_ENT);
                  VideoAnalyzer_SetDoorIntense(DOOR_ENT, (previousPercentageDoor_ENT * 255) / 100);
                }
                forceDoor = DOOR_ENT;
                // Deve fechar portas mas não pode
                _doorClosingForce = MustForceDoorMove(forceDoor, statusDoor, angleDoor, currentPercentageDoor_ENT,
                                                      currentPercentageDoor_EXT);
              } else {
                LOG_IF_F(1, STDERR_DEBUG, "Fecha a porta");
                DoorCtrl_CloseInDoorPercentage(DOOR_CLOSED_CENTRALIZED);
                previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
                if (protectionUserEntrance) {
                  protectionUserEntrance = false;
                  if (sentEventEntranceDoorProtecting) {
                    soapDFlow_addEventToSend(ns2__EventEnumType__ENTRANCE_USCOREDOOR_USCOREPROTECTING_USCORECLEAR);
                    sentEventEntranceDoorProtecting = false;
                  }
                }
              }
            }
            if (stopDoorsEntrance) {
              if (!forceBrake || doorStatePersonProtect == STOP_DOOR) {
                IndicLum_AddMemStopDoor(DOOR_ENTRANCE);
              } else if (doorStatePersonProtect == BRAKE_DOOR &&
                         (forceBrake || (currentPercentageDoor_ENT || currentPercentageDoor_EXT))) {
                IndicLum_AddMemLockBrake_SwitchOffMotor(DOOR_ENTRANCE, 255);
              }
            } else {
              IndicLum_AddMemAngleDoor(DOOR_ENTRANCE, DoorCtrl_GetDoorAngleIn(), DoorCtrl_GetDoorSpeedIn());
            }
            IndicLum_AddMemAngleDoor(DOOR_EXIT, DoorCtrl_GetDoorAngleOut(), DoorCtrl_GetDoorSpeedOut());
          } else if (actionModule_getOpModeDoor() == DOOR_MODE_DVIATOR_Y) {
            //*******************************************************************************************************/
            LOG_IF_F(1, STDERR_DEBUG, "DOOR_MODE_DVIATOR_Y");

            VideoAnalyzer_SetDviatorLcdPersonsInfo();

            bool someoneValidToProtect_left = VideoAnalyzer_SomeoneValidToProtectLeft();
            bool someoneValidToProtect_right = VideoAnalyzer_SomeoneValidToProtectRight();
            bool someoneToProtect_left = VideoAnalyzer_SomeoneToProtectLeft();
            bool someoneToProtect_right = VideoAnalyzer_SomeoneToProtectRight();

            // bool somethingToProtect_exception_left = VideoAnalyzer_SomethingToProtectLeft(protectionAreas);
            // bool somethingToProtect_exception_right = VideoAnalyzer_SomethingToProtectRight(protectionAreas);

            // bool someoneToProtect_exception_left = VideoAnalyzer_SomeoneToProtectLeftException(newPersonList);
            // bool someoneToProtect_exception_right = VideoAnalyzer_SomeoneToProtectRightException(newPersonList);
            bool somethingToProtect_exception_left = VideoAnalyzer_SomethingToProtectLeftException(protectionAreas);
            bool somethingToProtect_exception_right = VideoAnalyzer_SomethingToProtectRightException(protectionAreas);

#ifdef INFO_TESTE
            bool somethingToProtect_left = VideoAnalyzer_SomethingToProtectLeft(protectionAreas);
            bool somethingToProtect_right = VideoAnalyzer_SomethingToProtectRight(protectionAreas);

            LOG_F(INFO, "someoneValidToProtect_left: %s", someoneValidToProtect_left ? "true" : "false");
            LOG_F(INFO, "someoneValidToProtect_right: %s", someoneValidToProtect_right ? "true" : "false");
            LOG_F(INFO, "someoneToProtect_left: %s", someoneToProtect_left ? "true" : "false");
            LOG_F(INFO, "someoneToProtect_right: %s", someoneToProtect_right ? "true" : "false");
            LOG_F(INFO, "somethingToProtect_left: %s", somethingToProtect_left ? "true" : "false");
            LOG_F(INFO, "somethingToProtect_right: %s", somethingToProtect_right ? "true" : "false");
#endif

            // open the door
            DoorCtrl_CloseInDoorPercentage(DOOR_OPEN_ENTRANCE);
            DoorCtrl_CloseOutDoorPercentage(DOOR_OPEN_ENTRANCE);
            previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
            previousPercentageDoor_EXT = ((DoorCtrl_GetDoorAngleOut() * 100) / 90);

            // if first run
            if (actionModule_xmlGetDefaultDoorsModeInDviator() == DOOR_LFT) {
              if (previousAngleDoor_08 < 0) {
                previousAngleDoor_08 = DoorCtrl_CalcAngleForPercentage(100, DOOR_08);
              }
              if (previousAngleDoor_12 < 0) {
                previousAngleDoor_12 = DoorCtrl_CalcAngleForPercentage(100, DOOR_12);
              }
              if (previousAngleDoor_09 < 0) {
                previousAngleDoor_09 = DoorCtrl_CalcAngleForPercentage(0, DOOR_09);
              }
              if (previousAngleDoor_13 < 0) {
                previousAngleDoor_13 = DoorCtrl_CalcAngleForPercentage(0, DOOR_13);
              }
            } else {
              if (previousAngleDoor_08 < 0) {
                previousAngleDoor_08 = DoorCtrl_CalcAngleForPercentage(0, DOOR_08);
              }
              if (previousAngleDoor_12 < 0) {
                previousAngleDoor_12 = DoorCtrl_CalcAngleForPercentage(0, DOOR_12);
              }
              if (previousAngleDoor_09 < 0) {
                previousAngleDoor_09 = DoorCtrl_CalcAngleForPercentage(100, DOOR_09);
              }
              if (previousAngleDoor_13 < 0) {
                previousAngleDoor_13 = DoorCtrl_CalcAngleForPercentage(100, DOOR_13);
              }
            }
            // LOG_IF_F(1, STDERR_DEBUG,  "tmpDoor_RGT: %d", tmpDoor_RGT);
            // LOG_IF_F(1, STDERR_DEBUG,  "tmpDoor_LFT: %d", tmpDoor_LFT);

            // if(invalidPersonInside_inToOut && isValidationRegionBarrier_inToOut)
            if (currentPercentageDoor_LFT && currentPercentageDoor_RGT) {
              if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                   (somethingToProtect_exception_left || someoneToProtect_left) &&
                   (somethingToProtect_exception_right || someoneToProtect_right)) ||
                  ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) &&
                   (someoneToProtect_left && someoneToProtect_right)) ||
                  ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) &&
                   (someoneValidToProtect_left && someoneValidToProtect_right))) {
                // LOG_F(WARNING, "Protection enable");
                if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                }

                if (currentPercentageDoor_LFT != DoorCtrl_CalcPercentageForAngle(previousAngleDoor_09, DOOR_09) ||
                    currentPercentageDoor_RGT != DoorCtrl_CalcPercentageForAngle(previousAngleDoor_08, DOOR_08)) {
                  // LOG_F(ERROR, "Deve fechar portas mas não pode");
                  _doorClosingForce = true;
                  _forceClosedDoorLft = true;
                  _forceClosedDoorRgt = true;
                }
              } else if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                          (somethingToProtect_exception_left || someoneToProtect_left)) ||
                         ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_left)) ||
                         ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) && (someoneValidToProtect_left))) {
                // LOG_F(WARNING, "Protection enable");
                if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                }

                if (currentPercentageDoor_LFT != DoorCtrl_CalcPercentageForAngle(previousAngleDoor_09, DOOR_09)) {
                  // LOG_F(ERROR, "Deve fechar portas mas não pode");
                  _doorClosingForce = true;
                  _forceClosedDoorLft = true;
                }

                if (currentPercentageDoor_RGT >= (100 - currentPercentageDoor_LFT)) {
                  previousAngleDoor_08 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_RGT, DOOR_08);
                  previousAngleDoor_12 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_RGT, DOOR_12);
                  if (actionModule_xmlGetDefaultDoorsModeInDviator() == DOOR_LFT) {
                    LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da direita conforme pessoa valida");
                  } else {
                    LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da direita conforme pessoa invalida");
                  }
                } else {
                  previousAngleDoor_08 = DoorCtrl_CalcAngleForPercentage(100 - currentPercentageDoor_LFT, DOOR_08);
                  previousAngleDoor_12 = DoorCtrl_CalcAngleForPercentage(100 - currentPercentageDoor_LFT, DOOR_12);
                  if (actionModule_xmlGetDefaultDoorsModeInDviator() == DOOR_LFT) {
                    LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da direita conforme pessoa invalida");
                  } else {
                    LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da direita conforme pessoa valida");
                  }
                }
              } else if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                          (somethingToProtect_exception_right || someoneToProtect_right)) ||
                         ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_right)) ||
                         ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) && (someoneValidToProtect_right))) {
                // LOG_F(WARNING, "Protection enable");
                if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                }

                if (currentPercentageDoor_RGT != DoorCtrl_CalcPercentageForAngle(previousAngleDoor_08, DOOR_08)) {
                  // LOG_F(ERROR, "Deve fechar portas mas não pode");
                  _doorClosingForce = true;
                  _forceClosedDoorRgt = true;
                }

                if (currentPercentageDoor_LFT >= (100 - currentPercentageDoor_RGT)) {
                  previousAngleDoor_09 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_LFT, DOOR_09);
                  previousAngleDoor_13 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_LFT, DOOR_13);
                  if (actionModule_xmlGetDefaultDoorsModeInDviator() == DOOR_LFT) {
                    LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da esquerda conforme pessoa invalida");
                  } else {
                    LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da esquerda conforme pessoa valida");
                  }
                } else {
                  previousAngleDoor_09 = DoorCtrl_CalcAngleForPercentage(100 - currentPercentageDoor_RGT, DOOR_09);
                  previousAngleDoor_13 = DoorCtrl_CalcAngleForPercentage(100 - currentPercentageDoor_RGT, DOOR_13);
                  if (actionModule_xmlGetDefaultDoorsModeInDviator() == DOOR_LFT) {
                    LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da esquerda conforme pessoa valida");
                  } else {
                    LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da esquerda conforme pessoa invalida");
                  }
                }
              } else {
                if (actionModule_xmlGetDefaultDoorsModeInDviator() == DOOR_LFT) {
                  if (currentPercentageDoor_RGT >= (100 - currentPercentageDoor_LFT)) {
                    previousAngleDoor_08 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_RGT, DOOR_08);
                    previousAngleDoor_12 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_RGT, DOOR_12);
                    LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da direita conforme pessoa valida");
                  } else {
                    previousAngleDoor_08 = DoorCtrl_CalcAngleForPercentage(100 - currentPercentageDoor_LFT, DOOR_08);
                    previousAngleDoor_12 = DoorCtrl_CalcAngleForPercentage(100 - currentPercentageDoor_LFT, DOOR_12);
                    LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da direita conforme pessoa invalida");
                  }

                  previousAngleDoor_09 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_LFT, DOOR_09);
                  previousAngleDoor_13 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_LFT, DOOR_13);
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da esquerda conforme pessoa invalida");
                } else {
                  if (currentPercentageDoor_LFT >= (100 - currentPercentageDoor_RGT)) {
                    previousAngleDoor_09 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_LFT, DOOR_09);
                    previousAngleDoor_13 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_LFT, DOOR_13);
                    LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da esquerda conforme pessoa valida");
                  } else {
                    previousAngleDoor_09 = DoorCtrl_CalcAngleForPercentage(100 - currentPercentageDoor_RGT, DOOR_09);
                    previousAngleDoor_13 = DoorCtrl_CalcAngleForPercentage(100 - currentPercentageDoor_RGT, DOOR_13);
                    LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da esquerda conforme pessoa invalida");
                  }

                  previousAngleDoor_08 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_RGT, DOOR_08);
                  previousAngleDoor_12 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_RGT, DOOR_12);
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da direita conforme pessoa invalida");
                }
              }
            }
            // else if(invalidPersonInside_inToOut)
            else if ((currentPercentageDoor_LFT) && (actionModule_xmlGetDefaultDoorsModeInDviator() == DOOR_LFT) &&
                     ((VideoAnalyzer_InvalidPersonInsideInToOut()) || (VideoAnalyzer_IsValidPersonInsideInToOut()))) {
              LOG_IF_F(1, STDERR_DEBUG, "tmpPercent_09: %u%% | Angle: %u",
                       DoorCtrl_CalcPercentageForAngle(previousAngleDoor_09, DOOR_09), previousAngleDoor_09);
              if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                   (somethingToProtect_exception_left || someoneToProtect_left) &&
                   (somethingToProtect_exception_right || someoneToProtect_right)) ||
                  ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) &&
                   (someoneToProtect_left && someoneToProtect_right)) ||
                  ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) &&
                   (someoneValidToProtect_left && someoneValidToProtect_right))) {
                // LOG_F(WARNING, "Protection enable");
                if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                }

                if (currentPercentageDoor_LFT != DoorCtrl_CalcPercentageForAngle(previousAngleDoor_09, DOOR_09) ||
                    currentPercentageDoor_LFT !=
                        (100 - DoorCtrl_CalcPercentageForAngle(previousAngleDoor_08, DOOR_08))) {
                  // LOG_F(ERROR, "Deve fechar portas mas não pode");
                  _doorClosingForce = true;
                  _forceClosedDoorLft = true;
                  _forceOpenDoorRgt = true;
                }
              } else if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                          (somethingToProtect_exception_left || someoneToProtect_left)) ||
                         ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_left)) ||
                         ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) && (someoneValidToProtect_left))) {
                // LOG_F(WARNING, "Protection enable");
                if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                }

                if (currentPercentageDoor_LFT != DoorCtrl_CalcPercentageForAngle(previousAngleDoor_09, DOOR_09)) {
                  // LOG_F(ERROR, "Deve fechar portas mas não pode");
                  _doorClosingForce = true;
                  _forceClosedDoorLft = true;
                }

                if (100 - currentPercentageDoor_LFT > DoorCtrl_CalcPercentageForAngle(previousAngleDoor_08, DOOR_08)) {
                  previousAngleDoor_08 = DoorCtrl_CalcAngleForPercentage(100 - currentPercentageDoor_LFT, DOOR_08);
                  previousAngleDoor_12 = DoorCtrl_CalcAngleForPercentage(100 - currentPercentageDoor_LFT, DOOR_12);
                }
                LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da direita conforme pessoa invalida");
              } else if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                          (somethingToProtect_exception_right || someoneToProtect_right)) ||
                         ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_right)) ||
                         ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) && (someoneValidToProtect_right))) {
                // LOG_F(WARNING, "Protection enable");
                if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                }

                if (currentPercentageDoor_LFT !=
                    (100 - DoorCtrl_CalcPercentageForAngle(previousAngleDoor_08, DOOR_08))) {
                  // LOG_F(ERROR, "Deve fechar portas mas não pode");
                  _doorClosingForce = true;
                  _forceOpenDoorRgt = true;
                }

                if (currentPercentageDoor_LFT > DoorCtrl_CalcPercentageForAngle(previousAngleDoor_09, DOOR_09)) {
                  previousAngleDoor_09 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_LFT, DOOR_09);
                  previousAngleDoor_13 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_LFT, DOOR_13);
                }
                LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da esquerda conforme pessoa invalida");
              } else {
                previousAngleDoor_09 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_LFT, DOOR_09);
                previousAngleDoor_13 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_LFT, DOOR_13);
                previousAngleDoor_08 = DoorCtrl_CalcAngleForPercentage(100 - currentPercentageDoor_LFT, DOOR_08);
                previousAngleDoor_12 = DoorCtrl_CalcAngleForPercentage(100 - currentPercentageDoor_LFT, DOOR_12);
                LOG_IF_F(1, STDERR_DEBUG, "Aciona portas conforme pessoa invalida");
              }
            } else if ((currentPercentageDoor_RGT) && (actionModule_xmlGetDefaultDoorsModeInDviator() == DOOR_RGT) &&
                       ((VideoAnalyzer_InvalidPersonInsideInToOut()) || (VideoAnalyzer_IsValidPersonInsideInToOut()))) {
              LOG_IF_F(1, STDERR_DEBUG, "tmpPercent_08: %u%% | Angle: %u",
                       DoorCtrl_CalcPercentageForAngle(previousAngleDoor_08, DOOR_08), previousAngleDoor_08);
              if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                   (somethingToProtect_exception_left || someoneToProtect_left) &&
                   (somethingToProtect_exception_right || someoneToProtect_right)) ||
                  ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) &&
                   (someoneToProtect_left && someoneToProtect_right)) ||
                  ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) &&
                   (someoneValidToProtect_left && someoneValidToProtect_right))) {
                // LOG_F(WARNING, "Protection enable");
                if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                }

                if (currentPercentageDoor_RGT != DoorCtrl_CalcPercentageForAngle(previousAngleDoor_08, DOOR_08) ||
                    currentPercentageDoor_RGT !=
                        (100 - DoorCtrl_CalcPercentageForAngle(previousAngleDoor_09, DOOR_09))) {
                  // LOG_F(ERROR, "Deve fechar portas mas não pode");
                  _doorClosingForce = true;
                  _forceClosedDoorLft = true;
                  _forceOpenDoorRgt = true;
                }
              } else if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                          (somethingToProtect_exception_left || someoneToProtect_left)) ||
                         ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_left)) ||
                         ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) && (someoneValidToProtect_left))) {
                // LOG_F(WARNING, "Protection enable");
                if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                }

                if (currentPercentageDoor_RGT != DoorCtrl_CalcPercentageForAngle(previousAngleDoor_08, DOOR_08)) {
                  // LOG_F(ERROR, "Deve fechar portas mas não pode");
                  _doorClosingForce = true;
                  _forceClosedDoorLft = true;
                }

                if (currentPercentageDoor_RGT > DoorCtrl_CalcPercentageForAngle(previousAngleDoor_08, DOOR_08)) {
                  previousAngleDoor_08 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_RGT, DOOR_08);
                  previousAngleDoor_12 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_RGT, DOOR_12);
                }
                LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da direita conforme pessoa invalida");
              } else if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                          (somethingToProtect_exception_right || someoneToProtect_right)) ||
                         ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_right)) ||
                         ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) && (someoneValidToProtect_right))) {
                // LOG_F(WARNING, "Protection enable");
                if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                }

                if (currentPercentageDoor_RGT !=
                    (100 - DoorCtrl_CalcPercentageForAngle(previousAngleDoor_09, DOOR_09))) {
                  // LOG_F(ERROR, "Deve fechar portas mas não pode");
                  _doorClosingForce = true;
                  _forceClosedDoorRgt = true;
                }

                if (100 - currentPercentageDoor_RGT > DoorCtrl_CalcPercentageForAngle(previousAngleDoor_09, DOOR_09)) {
                  previousAngleDoor_09 = DoorCtrl_CalcAngleForPercentage(100 - currentPercentageDoor_RGT, DOOR_09);
                  previousAngleDoor_13 = DoorCtrl_CalcAngleForPercentage(100 - currentPercentageDoor_RGT, DOOR_13);
                }
                LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da esquerda conforme pessoa invalida");
              } else {
                previousAngleDoor_08 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_RGT, DOOR_08);
                previousAngleDoor_12 = DoorCtrl_CalcAngleForPercentage(currentPercentageDoor_RGT, DOOR_12);
                previousAngleDoor_09 = DoorCtrl_CalcAngleForPercentage(100 - currentPercentageDoor_RGT, DOOR_09);
                previousAngleDoor_13 = DoorCtrl_CalcAngleForPercentage(100 - currentPercentageDoor_RGT, DOOR_13);
                LOG_IF_F(1, STDERR_DEBUG, "Aciona portas conforme pessoa invalida");
              }
            } else {
              LOG_IF_F(1, STDERR_DEBUG, "tmpPercent_08: %u%%",
                       DoorCtrl_CalcPercentageForAngle(previousAngleDoor_08, DOOR_08));
              LOG_IF_F(1, STDERR_DEBUG, "tmpPercent_09: %u%%",
                       DoorCtrl_CalcPercentageForAngle(previousAngleDoor_09, DOOR_09));

              if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                   (somethingToProtect_exception_left || someoneToProtect_left) &&
                   (somethingToProtect_exception_right || someoneToProtect_right)) ||
                  ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) &&
                   (someoneToProtect_left && someoneToProtect_right)) ||
                  ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) &&
                   (someoneValidToProtect_left && someoneValidToProtect_right))) {
                // LOG_F(WARNING, "Protection enable");
                if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                }

                if (((actionModule_xmlGetDefaultDoorsModeInDviator() == DOOR_LFT) &&
                     (DoorCtrl_CalcPercentageForAngle(previousAngleDoor_08, DOOR_08) != 100 ||
                      DoorCtrl_CalcPercentageForAngle(previousAngleDoor_09, DOOR_09) != 0)) ||
                    ((actionModule_xmlGetDefaultDoorsModeInDviator() == DOOR_RGT) &&
                     (DoorCtrl_CalcPercentageForAngle(previousAngleDoor_08, DOOR_08) != 0 ||
                      DoorCtrl_CalcPercentageForAngle(previousAngleDoor_09, DOOR_09) != 100))) {
                  // LOG_F(ERROR, "Deve fechar portas mas não pode");
                  _doorClosingForce = true;
                  _forceOpenDoorLft = true;
                  _forceClosedDoorRgt = true;
                }
              } else if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                          (somethingToProtect_exception_left || someoneToProtect_left)) ||
                         ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_left)) ||
                         ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) && (someoneValidToProtect_left))) {
                // LOG_F(WARNING, "Protection enable");
                if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                }

                if (actionModule_xmlGetDefaultDoorsModeInDviator() == DOOR_LFT) {
                  if (DoorCtrl_CalcPercentageForAngle(previousAngleDoor_09, DOOR_09) != 0) {
                    // LOG_F(ERROR, "Deve fechar portas mas não pode");
                    _doorClosingForce = true;
                    _forceOpenDoorLft = true;
                  }

                  previousAngleDoor_08 = DoorCtrl_CalcAngleForPercentage(100, DOOR_08);
                  previousAngleDoor_12 = DoorCtrl_CalcAngleForPercentage(100, DOOR_12);
                  LOG_IF_F(1, STDERR_DEBUG, "Fecha porta da direita");
                } else {
                  if (DoorCtrl_CalcPercentageForAngle(previousAngleDoor_09, DOOR_09) != 100) {
                    // LOG_F(ERROR, "Deve fechar portas mas não pode");
                    _doorClosingForce = true;
                    _forceOpenDoorLft = true;
                  }

                  // previousAngleDoor_08 = doorCtrl_calcAngleForPercentage(0, DOOR_08);
                  // previousAngleDoor_12 = doorCtrl_calcAngleForPercentage(0, DOOR_12);
                  // LOG_IF_F(1, STDERR_DEBUG,  "Abre porta da direita");
                }
              } else if (((levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) &&
                          (somethingToProtect_exception_right || someoneToProtect_right)) ||
                         ((levelOfUserProtection == PROTECTION_LEVEL_ANYONE) && (someoneToProtect_right)) ||
                         ((levelOfUserProtection == PROTECTION_LEVEL_VALID_USER) && (someoneValidToProtect_right))) {
                // LOG_F(WARNING, "Protection enable");
                if (levelOfUserProtection == PROTECTION_LEVEL_ANY_OBJECT) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer objeto");
                } else if (levelOfUserProtection == PROTECTION_LEVEL_ANYONE) {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para qualquer pessoa");
                } else {
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona protecao para pessoa valida");
                }

                if (actionModule_xmlGetDefaultDoorsModeInDviator() == DOOR_LFT) {
                  if (DoorCtrl_CalcPercentageForAngle(previousAngleDoor_08, DOOR_08) != 100) {
                    // LOG_F(ERROR, "Deve fechar portas mas não pode");
                    _doorClosingForce = true;
                    _forceClosedDoorRgt = true;
                  }

                  // previousAngleDoor_09 = doorCtrl_calcAngleForPercentage(0, DOOR_09);
                  // previousAngleDoor_13 = doorCtrl_calcAngleForPercentage(0, DOOR_13);
                  // LOG_IF_F(1, STDERR_DEBUG,  "Aciona porta da esquerda conforme pessoa invalida");
                } else {
                  if (DoorCtrl_CalcPercentageForAngle(previousAngleDoor_08, DOOR_08) != 0) {
                    // LOG_F(ERROR, "Deve fechar portas mas não pode");
                    _doorClosingForce = true;
                    _forceClosedDoorRgt = true;
                  }

                  previousAngleDoor_09 = DoorCtrl_CalcAngleForPercentage(100, DOOR_09);
                  previousAngleDoor_13 = DoorCtrl_CalcAngleForPercentage(100, DOOR_13);
                  LOG_IF_F(1, STDERR_DEBUG, "Aciona porta da direita conforme pessoa invalida");
                }
              } else {
                if (actionModule_xmlGetDefaultDoorsModeInDviator() == DOOR_LFT) {
                  previousAngleDoor_08 = DoorCtrl_CalcAngleForPercentage(100, DOOR_08);
                  previousAngleDoor_12 = DoorCtrl_CalcAngleForPercentage(100, DOOR_12);
                  previousAngleDoor_09 = DoorCtrl_CalcAngleForPercentage(0, DOOR_09);
                  previousAngleDoor_13 = DoorCtrl_CalcAngleForPercentage(0, DOOR_13);
                  LOG_IF_F(1, STDERR_DEBUG, "Abre as portas da esquerda");
                } else {
                  previousAngleDoor_08 = DoorCtrl_CalcAngleForPercentage(0, DOOR_08);
                  previousAngleDoor_12 = DoorCtrl_CalcAngleForPercentage(0, DOOR_12);
                  previousAngleDoor_09 = DoorCtrl_CalcAngleForPercentage(100, DOOR_09);
                  previousAngleDoor_13 = DoorCtrl_CalcAngleForPercentage(100, DOOR_13);
                  LOG_IF_F(1, STDERR_DEBUG, "Abre as portas da direita");
                }
              }
            }

            IndicLum_AddMemAngleDoor(2, DoorCtrl_GetDoorAngleIn(), DoorCtrl_GetDoorSpeedIn());
            IndicLum_AddMemAngleDoor(3, DoorCtrl_GetDoorAngleOut(), DoorCtrl_GetDoorSpeedOut());

            IndicLum_AddMemAngleDoor(DoorStatus_GetAddressDoor(DOOR_08), previousAngleDoor_08,
                                     DoorCtrl_GetDoorSpeedIn() / 3);
            IndicLum_AddMemAngleDoor(DoorStatus_GetAddressDoor(DOOR_12), previousAngleDoor_12,
                                     DoorCtrl_GetDoorSpeedIn());
            IndicLum_AddMemAngleDoor(DoorStatus_GetAddressDoor(DOOR_09), previousAngleDoor_09,
                                     DoorCtrl_GetDoorSpeedIn() / 3);
            IndicLum_AddMemAngleDoor(DoorStatus_GetAddressDoor(DOOR_13), previousAngleDoor_13,
                                     DoorCtrl_GetDoorSpeedIn());
          } else if (actionModule_getOpModeDoor() == DOOR_MODE_TRAP) {
            //*******************************************************************************************************/
            LOG_IF_F(1, STDERR_DEBUG, "DOOR_MODE_TRAP");
            if (actionModule_getSOAPStatus() == ns2__StatusEnumType__ACTIVE) {
              Dpass::GetInstance()->Update(protectionAreas);
            }
          } else if (actionModule_getOpModeDoor() == DOOR_MODE_ALW_OPEN ||
                     actionModule_getOpModeDoor() == DOOR_MODE_NONE) {
            //*******************************************************************************************************/
            LOG_IF_F(1, STDERR_DEBUG, "DOOR_MODE_ALW_OPEN or DOOR_MODE_NONE");
            CommandDoors doorsEntrance = DOOR_OPEN_ENTRANCE;
            CommandDoors doorsExit = DOOR_OPEN_ENTRANCE;
            ns2__StatusEnumType statusSoap = actionModule_getSOAPStatus();
            if (actionModule_xmlGetOpModeDoor() == DOOR_MODE_TRAP) {
              if (statusSoap == ns2__StatusEnumType__PERMANENT_USCOREOPEN_USCOREENTRY_USCOREINWARD ||
                  statusSoap == ns2__StatusEnumType__PERMANENT_USCOREOPEN_USCOREENTRY_USCOREOUTWARD) {
                if (statusSoap == ns2__StatusEnumType__PERMANENT_USCOREOPEN_USCOREENTRY_USCOREOUTWARD)
                  doorsEntrance = DOOR_OPEN_EXIT;
                doorsExit = DOOR_CLOSED_CENTRALIZED;
              } else if (statusSoap == ns2__StatusEnumType__PERMANENT_USCOREOPEN_USCOREEXIT_USCOREINWARD ||
                         statusSoap == ns2__StatusEnumType__PERMANENT_USCOREOPEN_USCOREEXIT_USCOREOUTWARD) {
                if (statusSoap == ns2__StatusEnumType__PERMANENT_USCOREOPEN_USCOREEXIT_USCOREOUTWARD)
                  doorsExit = DOOR_OPEN_EXIT;
                doorsEntrance = DOOR_CLOSED_CENTRALIZED;
              } else {
                if (actionModule_xmlGetOpenDirectionEntranceDoorsFireAlarmOrPermOpen() == OUTWARD)
                  doorsEntrance = DOOR_OPEN_EXIT;
                if (actionModule_xmlGetOpenDirectionExitDoorsFireAlarmOrPermOpen() == OUTWARD)
                  doorsExit = DOOR_OPEN_EXIT;
              }
            }
            DoorCtrl_CloseInDoorPercentage(doorsEntrance);
            DoorCtrl_CloseOutDoorPercentage(doorsExit);
            previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
            previousPercentageDoor_EXT = ((DoorCtrl_GetDoorAngleOut() * 100) / 90);
            uint8_t speed = actionModule_xmlGetSpeedDoorPermanentlyOpenMode();
            IndicLum_AddMemAngleDoor(2, DoorCtrl_GetDoorAngleIn(), speed);
            IndicLum_AddMemAngleDoor(3, DoorCtrl_GetDoorAngleOut(), speed);
          } else if (actionModule_getOpModeDoor() == DOOR_MODE_ALW_OPEN_EXIT) {
            //*******************************************************************************************************/
            LOG_IF_F(1, STDERR_DEBUG, "DOOR_MODE_ALW_OPEN_EXIT");
            DoorCtrl_CloseInDoorPercentage(DOOR_OPEN_EXIT);
            DoorCtrl_CloseOutDoorPercentage(DOOR_OPEN_ENTRANCE);
            previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
            previousPercentageDoor_EXT = ((DoorCtrl_GetDoorAngleOut() * 100) / 90);

            IndicLum_AddMemAngleDoor(2, DoorCtrl_GetDoorAngleIn(), DoorCtrl_GetDoorSpeedIn());
            IndicLum_AddMemAngleDoor(3, DoorCtrl_GetDoorAngleOut(), DoorCtrl_GetDoorSpeedOut());
          } else if (actionModule_getOpModeDoor() == DOOR_MODE_ALW_CLOSED) {
            //*******************************************************************************************************/
            LOG_IF_F(1, STDERR_DEBUG, "DOOR_MODE_ALW_CLOSED");
            CommandDoors doorsEntrance = DOOR_CLOSED_CENTRALIZED;
            CommandDoors doorsExit = DOOR_OPEN_ENTRANCE;
            if (actionModule_xmlGetOpModeDoor() == DOOR_MODE_TRAP) {
              doorsExit = DOOR_CLOSED_CENTRALIZED;
            }
            DoorCtrl_CloseInDoorPercentage(doorsEntrance);
            DoorCtrl_CloseOutDoorPercentage(doorsExit);
            previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
            previousPercentageDoor_EXT = ((DoorCtrl_GetDoorAngleOut() * 100) / 90);
            IndicLum_AddMemAngleDoor(2, DoorCtrl_GetDoorAngleIn(), DoorCtrl_GetDoorAngleIn());
            IndicLum_AddMemAngleDoor(3, DoorCtrl_GetDoorAngleOut(), DoorCtrl_GetDoorAngleOut());
          }

          uint16_t forcedClosingTimeOfDoors = SEC_TO_MS(actionModule_xmlGetTimeForceMoveDoorAfterProtecting());
          if (forcedClosingTimeOfDoors) {
            // Force closing doors
            static bool lastDoorClosingForceOn = false;
            static bool lastDoorClosingForceOff = true;

            if ((_doorClosingForce) && (!forceClosingDoorsOn)) {
              lastDoorClosingForceOff = true;
              if (!lastDoorClosingForceOn) {
                LOG_IF_F(1, STDERR_DEBUG, "Inicia timer");
                timeForceCloseDoor.Start(forcedClosingTimeOfDoors);
                lastDoorClosingForceOn = true;
              } else if (timeForceCloseDoor.Check()) {
                LOG_F(WARNING, "Starts the forced closing of doors");
                forceClosingDoorsOn = true;
                forceClosingDoorsOff = false;
                flagInitTimerForceClosingDoors = false;
              }
            } else if (!_doorClosingForce) {
              if (!forceClosingDoorsOff) {
                if (lastDoorClosingForceOff) {
                  LOG_IF_F(1, STDERR_DEBUG, "Inicia timer para desligar Door closing door");
                  timeForceCloseDoorOff.Start(1000);
                  lastDoorClosingForceOff = false;
                } else if (timeForceCloseDoorOff.Check())
                //&& (_forceClosingDoorsOn))
                {
                  LOG_F(WARNING, "Turns off the forced closing of the doors");
                  forceClosingDoorsOn = false;
                  forceClosingDoorsOff = true;
                  lastDoorClosingForceOff = true;
                  IndicLum_TurnOffBuzzer(MESSAGE_DELIVERY_GUARANTEE);
                  flag_sendIdle = false;
                }
              } else {
                lastDoorClosingForceOn = false;
              }
            }
          }
        } else if (tmpflagToggleStateOp != OP_STATE_COLLECT_CARD_URN) {
          DoorCtrl_CloseInDoorPercentage(DOOR_OPEN_ENTRANCE);
          DoorCtrl_CloseOutDoorPercentage(DOOR_OPEN_ENTRANCE);
          previousPercentageDoor_ENT = ((DoorCtrl_GetDoorAngleIn() * 100) / 90);
          previousPercentageDoor_EXT = ((DoorCtrl_GetDoorAngleOut() * 100) / 90);
        }

#define FREQ_INI_HZ 1   // 1
#define FREQ_END_HZ 21  // 21

        int intrusionAlarmValue = actionModule_xmlGetIntrusionAlarmValue();
        if (intrusionAlarmValue && intrusionAlarmValue < 100 && !forceClosingDoorsOn) {
          if ((currentPercentageBuzzer_ENT < intrusionAlarmValue) &&
              (currentPercentageBuzzer_EXT < intrusionAlarmValue) &&
              (currentPercentageBuzzer_LFT < intrusionAlarmValue)) {
            _flagFullClosedDoor = false;
          }

          if ((currentPercentageBuzzer_ENT > intrusionAlarmValue) ||
              (currentPercentageBuzzer_EXT > intrusionAlarmValue) ||
              (currentPercentageBuzzer_LFT > intrusionAlarmValue)) {
            if (!SoapAlarmController::GetInstance()->IsEnableAlarm()) IndicLum_SetAlarm(true);
            int tmpIntenseDoor = 0;
            if (currentPercentageBuzzer_ENT >= currentPercentageBuzzer_EXT) {
              tmpIntenseDoor = currentPercentageBuzzer_ENT;
            } else {
              tmpIntenseDoor = currentPercentageBuzzer_EXT;
            }
            if (currentPercentageBuzzer_LFT > tmpIntenseDoor) tmpIntenseDoor = currentPercentageBuzzer_LFT;
            IndicLum_SetAlarmFrequencyMHz(
                FREQ_INI_HZ + (((FREQ_END_HZ - FREQ_INI_HZ) * 10) * (tmpIntenseDoor - intrusionAlarmValue)));

            // if we have a hitchhiker and door close then send to orchestrator "door closed"
            if (!_flagFullClosedDoor) {
              actionModuleSoapDoorsClosed();
              LOG_IF_F(1, STDERR_DEBUG, "invasion detected");
              _flagFullClosedDoor = true;
            }
          }
        }
      }

      if (!actionModule_xmlGetBrManiaBypassMode()) {
        VideoAnalyzer_ShowLayersRegions(frame);
        VideoAnalyzer_DrawCad(frame);
        if (actionModule_haveUpdateReaders() && drawReaders) {
          _readers->GetLocation(&readersPosition);
          _readers->GetLocationServer(&readersServersPosition);
          _readers->GetLocationServerPersons(&readersServerPersonsPosition);
          _readers->GetLocationMCASP(&readersMCASPPosition);
          VideoAnalyzer_DrawReaders(frame, readersPosition, readersServersPosition, readersServerPersonsPosition,
                                    readersMCASPPosition);
        }
      }

      // Draw persons and their info
      // timeDrawPerson = tmpTimeMeasure; //getTickCount();
      if (actionModule_isPlayingDemoAnimation()) {
        if (!PeripheralDemonstration_IsEnable()) {
          PeripheralDemonstration_Enable();
        }

        if (!videoAnalyzer_exceeded) {
          IndicLum_ClearMemDoor();
          if (remoteConfig_get_EstadoAnimacao() == STATEANIMATION_DEMOWITHDOORS) {
            PeripheralDemonstration_Update();
            IndicLum_SendMessageDoorMem(MESSAGE_DELIVERY_GUARANTEE);
          } else {
            IndicLum_AddMemAngleDoor(2, DOOR_OPEN_ENTRANCE, 50);
            IndicLum_AddMemAngleDoor(3, DOOR_OPEN_ENTRANCE, 50);

            IndicLum_AddMemAngleDoor(8, DoorCtrl_CalcAngleForPercentage(100, DOOR_08), 50);
            IndicLum_AddMemAngleDoor(12, DoorCtrl_CalcAngleForPercentage(100, DOOR_12), 50);
            IndicLum_AddMemAngleDoor(9, DoorCtrl_CalcAngleForPercentage(0, DOOR_09), 50);
            IndicLum_AddMemAngleDoor(13, DoorCtrl_CalcAngleForPercentage(0, DOOR_13), 50);

            IndicLum_SendMessageDoorMem(MESSAGE_PRIORITY);
          }

          if (actionModule_getCheckStatusDoors()) {
            // set the door
            uint8_t angleDoorA = (DoorStatus_GetAngleDoor(DOOR_06) + DoorStatus_GetAngleDoor(DOOR_10)) / 2;
            uint8_t angleDoorB = (DoorStatus_GetAngleDoor(DOOR_07) + DoorStatus_GetAngleDoor(DOOR_11)) / 2;
            infoMonitor_setAnglePortaA(angleDoorA < DIFF_ANGLE ? 0 : angleDoorA);
            infoMonitor_setAnglePortaB(angleDoorB < DIFF_ANGLE ? 0 : angleDoorB);
          }
        }
      } else {
        if (PeripheralDemonstration_IsEnable()) {
          PeripheralDemonstration_Disable();
          _saveAnimatioState = STATEANIMATION_IDLE;
          remoteConfig_set_EstadoAnimacao(_saveAnimatioState);
        }

        uint8_t angleDoorA = (DoorStatus_GetAngleDoor(DOOR_06) + DoorStatus_GetAngleDoor(DOOR_10)) / 2;
        uint8_t angleDoorB = (DoorStatus_GetAngleDoor(DOOR_07) + DoorStatus_GetAngleDoor(DOOR_11)) / 2;
        infoMonitor_setAnglePortaA(angleDoorA < DIFF_ANGLE ? 0 : angleDoorA);
        infoMonitor_setAnglePortaB(angleDoorB < DIFF_ANGLE ? 0 : angleDoorB);
      }

#ifdef ENABLE_SELF_CHECKOUT
      VideoAnalyzer_UpdateSelfCheckout();
#endif

      if (!actionModule_xmlGetBrManiaBypassMode()) {
        VideoAnalyzer_DrawPersons(frame, protectionAreas);
        cv::Mat imgAI = imgFrame.clone();
        VideoAnalyzer_DrawPersonInfoAI(imgAI);
        VideoAnalyzer_DrawCad(imgAI);
        VideoAnalyzer_DrawPersonId(imgFrame);
#ifdef ENABLE_SELF_CHECKOUT
        imgFrame = VideoAnalyzer_DrawSelfCheckout_ExitArea(imgFrame);
#endif
        if (syncServer_GetSensorModel() == MODEL_V2 && actionModule_xmlGetAutoExposureEnabled()) {
          imgFrame = VideoAnalyzer_DrawRoiAutoExpossure(imgFrame);
        }
        VideoAnalyzer_SaveImageToPath(imgFrame,
                                      actionModule_GetPathTrackingImage(ns2__TrackingImageEnumType__AMPLITUDE));
        frame = VideoAnalyzer_AddFrameAtFrame(imgFrame, frame);
        if (VisualCortex::GetInstance()->GetBrainConnected() || VisualCortex::GetInstance()->GetReprocMode()) {
          frame = VideoAnalyzer_AddFrameAtFrame(imgAI, frame);
        }
        frame = VideoAnalyzer_AddFrameAtFrame(frameOrig, frame);
        frame = VideoAnalyzer_AddFrameAtFrame(frameAfterFilters, frame);
        if (false) {
          const cv::Mat frameMonitoring = VideoAnalyzer_DrawFrameToMonitoring();
          frame = VideoAnalyzer_AddFrameAtFrame(frameMonitoring, frame);
        }
        if (false) {
          const cv::Mat frameResulting = VideoAnalyzer_GetFrameResultingWithoutCalib();
          frame = VideoAnalyzer_AddFrameAtFrame(frameResulting, frame);
        }
      }

      static TestHardware::Test lastTestHardware = TestHardware::TEST_NONE;
      TestHardware::Test currentTestHardware = TestHardware::GetInstance()->GetTest();

      if (lastTestHardware != currentTestHardware) {
        lastTestHardware = currentTestHardware;
        if (TestHardware::TEST_DOORS != currentTestHardware) {
          flag_sendIdle = false;
          if (actionModule_getUseChangeModeOpCam()) {
            actionModule_changeModeOpCam(NORMAL_MODE, actionModule_xmlGetBloqID());
          }

          NightMode::GetInstance()->ForcedNightModeDisabled(true);
        }
      } else if (TestHardware::TEST_LIGHTS == currentTestHardware ||
                 TestHardware::TEST_TRACKING == currentTestHardware ||
                 TestHardware::TEST_NOTIFICATION_LIGHT == currentTestHardware) {
        VideoAnalyzer_ClearsInfoDoorIntensList();
        IndicLum_ClearMemDoor();
        IndicLum_ClearMemWindow();
        TestHardware::GetInstance()->Update(protectionAreas);
        if (TestHardware::TEST_TRACKING == currentTestHardware && IndicLum_IsNotThereLedWindowToSend()) {
          flag_sendIdle = false;
        }
      }

      timeWriteInfo = Util_GetMicroseconds();
      timeDrawPerson = timeWriteInfo - timeDrawPerson;

      if (!videoAnalyzer_exceeded) {
        // Atualiza barra de leds
        if (!actionModule_isPlayingDemoAnimation()) {
          if ((actionModule_getStateIn() == OP_STATE_CLOSED && actionModule_getStateOut() == OP_STATE_CLOSED) &&
              (tmpflagToggleStateOp != OP_STATE_FIRE_ALARM) && (tmpflagToggleStateOp != OP_STATE_ALL_FREE) &&
              (tmpflagToggleStateOp != OP_STATE_COLLECT_CARD_URN)) {
            IndicLum_ClearMemDoor();
            if (actionModule_xmlGetOpModeDoor() != DOOR_MODE_DVIATOR_Y) {
              DoorCtrl_CloseInDoorPercentage(100);
              if (actionModule_xmlGetOpModeDoor() != DOOR_MODE_TRAP) {
                DoorCtrl_CloseOutDoorPercentage(0);
              } else {
                DoorCtrl_CloseOutDoorPercentage(100);
              }
              IndicLum_AddMemAngleDoor(2, DoorCtrl_GetDoorAngleIn(), DoorCtrl_GetDoorSpeedIn());
              IndicLum_AddMemAngleDoor(3, DoorCtrl_GetDoorAngleOut(), DoorCtrl_GetDoorSpeedOut());
            } else {
              IndicLum_AddMemAngleDoor(8, DoorCtrl_CalcAngleForPercentage(100, DOOR_08), 30);
              IndicLum_AddMemAngleDoor(9, DoorCtrl_CalcAngleForPercentage(100, DOOR_09), 30);
              IndicLum_AddMemAngleDoor(12, DoorCtrl_CalcAngleForPercentage(100, DOOR_12), 100);
              IndicLum_AddMemAngleDoor(13, DoorCtrl_CalcAngleForPercentage(100, DOOR_13), 100);
            }
          }

          // Verifica se funcionalidade de fechamento de portas esta habilitada
          SendsDriveToDoors(forceClosingDoorsOn, flagInitTimerForceClosingDoors, flagSetTimeoutOpenDoor,
                            flagMovimentDoorsClose, flagMovimentDoorsOpen, tmpflagToggleStateOp, angleDoor,
                            previousPercentageDoor_ENT, previousPercentageDoor_EXT, previousAngleDoor_08,
                            previousAngleDoor_09, previousAngleDoor_12, previousAngleDoor_13, forceDoor,
                            _forceOpenDoorLft, _forceClosedDoorLft, _forceOpenDoorRgt, _forceClosedDoorRgt);
        }
      }

      if (!actionModule_xmlGetBrManiaBypassMode()) {
        // Draw doors
        VideoAnalyzer_DrawDoors(frame);
        frameToTrackingImage = VideoAnalyzer_CopyFrameToTrackingImage(frame);
        VideoAnalyzer_SaveImageToPath(
            frameToTrackingImage,
            actionModule_GetPathTrackingImage(ns2__TrackingImageEnumType__AMPLITUDE_USCOREWITH_USCOREREGIONS));
      }

      if (!_flagZeroCounter) {
        _personCounterIn = VideoAnalyzer_GetPersonCountersIn(nullptr, nullptr);
        _personCounterOut = VideoAnalyzer_GetPersonCountersOut(nullptr, nullptr);
      } else {
        _personCounterIn = VideoAnalyzer_GetPersonCountersIn(&_flagZeroCounter, nullptr);
        _personCounterOut = VideoAnalyzer_GetPersonCountersOut(&_flagZeroCounter, nullptr);
        // flagZeroCounter = false;
      }
      // get the person counters
      VideoAnalyzer_GetPersonCountersIn(&_validPersonCounterInTEMP, &_intrusionPersonCounterInTEMP);
      VideoAnalyzer_GetPersonCountersOut(&_validPersonCounterOutTEMP, &_intrusionPersonCounterOutTEMP);
      // increment
      infoCount_incrementValidEntranceTotal(_validPersonCounterInTEMP);
      infoCount_incrementValidExitTotal(_validPersonCounterOutTEMP);
      infoCount_incrementInvalidEntranceTotal(_intrusionPersonCounterInTEMP);
      infoCount_incrementInvalidExitTotal(_intrusionPersonCounterOutTEMP);

      // test if pass the hour
      int curHour = Util_GetStructTm_LocalTime_Milliseconds(Util_GetMilliseconds()).tm_hour;
      if (_currentHour != curHour) {
        _currentHour = curHour;
        if (actionModule_xmlGetSoapDFlowPort() && actionModule_xmlGetSoapOrchestratorPort()) {
          if (_sendFirstUpdateImages) {
            soapDFlow_sendUpdateImages();
          } else {
            _sendFirstUpdateImages = true;
          }
        }
      }

      // increment today
      infoCount_incrementValidEntranceToday(_validPersonCounterInTEMP);
      infoCount_incrementValidExitToday(_validPersonCounterOutTEMP);
      infoCount_incrementInvalidEntranceToday(_intrusionPersonCounterInTEMP);
      infoCount_incrementInvalidExitToday(_intrusionPersonCounterOutTEMP);
      // set infoMonitor
      infoMonitor_setAcessosHoje(infoCount_getValidEntranceToday(), infoCount_getValidExitToday());
      infoMonitor_setAcessosParcial(infoCount_getValidEntranceTotal(), infoCount_getValidExitTotal());
      infoMonitor_setRecusasHoje(infoCount_getInvalidEntranceToday(), infoCount_getInvalidExitToday());
      infoMonitor_setRecusasParcial(infoCount_getInvalidEntranceTotal(), infoCount_getInvalidExitTotal());

      _personCounterIn = infoCount_getValidEntranceTotal() + infoCount_getInvalidEntranceTotal();
      _personCounterOut = infoCount_getValidExitTotal() + infoCount_getInvalidExitTotal();

      if (!actionModule_xmlGetBrManiaBypassMode()) {
        VideoAnalyzer_DrawDateHeader(frame);
        VideoAnalyzer_DrawSensorInfo(frame);
        uint32_t percentAvailable = 0;
        if (_checkTotalSpaceHd > 0) percentAvailable = (_checkSpaceHd * 100) / _checkTotalSpaceHd;
        double systemTemperature = 0.0;
        double cpuTemperature = actionModule_readCpuTemperature(systemTemperature);
        VideoAnalyzer_DrawSystemInfo(frame, percentAvailable, cpuTemperature);
        VideoAnalyzer_DrawStatusInfo(frame, false);
      }

      timeShow = Util_GetMicroseconds();
      timeWriteInfo = timeShow - timeWriteInfo;

      if (actionModule_getTestMorphoWave()) {
        int contPpm = actionModule_getPersonPerMinute(intervalTimePersonPerMinute);
        char tmpBuff[20];
        memset(tmpBuff, 0, sizeof(tmpBuff));
        sprintf(tmpBuff, "%02d por minuto", contPpm);
        Lcd_Msg(LCD_FIELD_LIN1, (strlen(tmpBuff) > 20 ? FONT_SIZE_M : FONT_SIZE_G), FONT_COLOR_WHITE,
                (strlen(tmpBuff) > MAX_MSG_LEN) ? MAX_MSG_LEN : (strlen(tmpBuff)), (const uint8_t *)tmpBuff);
        static int tmpContPpm = -1;
        if (tmpContPpm != contPpm) {
          LOG_F(INFO, "Person per minute: %02d", contPpm);
          tmpContPpm = contPpm;
        }
      }

      // Write info line
      if (_textMode) {
        char strInfoLine[UINT8_MAX];
        uint32_t numberCurrentFrame = VideoAnalyzer_GetNumberFrame();
        if (flagEnoughForAverage) {
          sprintf(strInfoLine, "FPS: %2.3f - Count: %d %d | Frame: %u", _fpsAverage, _personCounterIn,
                  _personCounterOut, numberCurrentFrame);
        } else {
          sprintf(strInfoLine, "FPS: --.--- - Count: %d %d | Frame: %u", _personCounterIn, _personCounterOut,
                  numberCurrentFrame);
        }

        printf("%s\n", strInfoLine);
      }

      timeSave = Util_GetMicroseconds();
      timeShow = timeSave - timeShow;

      // Save to output
      if (!actionModule_xmlGetBrManiaBypassMode()) {
        Mat calibrationFrame = ImageCalibration::GetInstance()->GetCalibration().first;
        VideoAnalyzer_SaveImageToPath(calibrationFrame,
                                      actionModule_GetPathTrackingImage(ns2__TrackingImageEnumType__CALIBRATED));
        frame = VideoAnalyzer_AddFrameAtFrame(calibrationFrame, frame);
        VideoAnalyzer_ShowOpencvWindow(OpenCvWindow("Frame", frame));

        if (flagWriteVideoOutput) VideoOutput_AddFrameToSave(frame, flagWriteFrameFiles, flagDeleteLastFile);
        if (flagWriteBltstream && _bltstreamFileOpMode == BLTSTREAM_FILE_MODE_WRITE) {
          Bltstream::GetInstance()->NewBltstreamToSave(tmpBltstreamFrame, flagWriteFrameFiles, flagDeleteLastFile);
        }

        if (_saveFrameToBmp) {
          _saveFrameToBmp = false;
          LOG_IF_F(1, STDERR_DEBUG, "***** saveFrameToBmp *****");
          std::string pathImage = output_directory;
          char last_char = pathImage[pathImage.size() - 1];
          if (last_char != '/') pathImage.append("/");
          pathImage.append("imgFrameOrig_");
          pathImage.append(Util_GetDateLog("_"));
          pathImage.append("_");
          pathImage.append(Util_GetTimeLog("_"));
          pathImage.append(".bmp");
          LOG_F(INFO, "saveFrameToBmp: %s", pathImage.c_str());
          cv::Mat newFrame = imgFrameOrig.clone();
          if (!actionModule_xmlGetCudaPreprocessingEnabled() && actionModule_xmlGetCudaClaheFilterEnabled()) {
            newFrame = VideoAnalyzer_ApplyClaheImage(newFrame);
          } else
            newFrame = VideoAnalyzer_SaturateImage(imgFrameOrig, 7.0, 100);
          imwrite(pathImage, newFrame);
        }

        int curSec = Util_GetStructTm_LocalTime_Milliseconds(Util_GetMilliseconds()).tm_sec;
        static int lastSaveImg = 70;
        if (lastSaveImg != curSec) {
          pthread_mutex_lock(&_saveOpenCVFramesMutex);
          _frameStructFifo.push(frame);
          pthread_mutex_unlock(&_saveOpenCVFramesMutex);
          lastSaveImg = curSec;
        }
      }

      timeSave = Util_GetMicroseconds() - timeSave;
    }

    timeWaitKey = Util_GetMicroseconds();
    int c = -1;
    if (showWindows) {
      c = waitKey(1);
      if (c >= 255) {
        if (CV_MAJOR_VERSION == 2 && c > 255) {
          c -= 0x100000;
        } else if (CV_MAJOR_VERSION == 3 && c == 255) {
          c = -1;
        }
      }
    }

    if (c < 0) {
      if (Util_Kbhit()) {
        c = Util_Getch();
        fflush(nullptr);
      }
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (c >= 0) {
      LOG_F(INFO, "Key pressed: '%c' '%d' (0x%02X)", c, c, c);
      if ((char)c == '0') {
        LOG_IF_F(1, STDERR_DEBUG, "Idle: %d", _flagPause);
        if (_flagPause) IndicLum_StartIdle(velIdle1, velIdle2, MAIN_INDIC_LUM_TAM_IDLE, actionModule_getUsingArinc());
      } else if ((char)c == '1') {
        LOG_IF_F(1, STDERR_DEBUG, "Demo: %d", _flagPause);
        if (_flagPause) IndicLum_StartDemoStripLeds();
      } else if ((char)c == '2') {  // PDF417
        std::string barcodeDataFake =
            "]L2M1JULI/ALESSANDRO     ETWEXEQ GIGFCOAZ 0673 328Y030C0021 362>5321MO6328BAZ 4055366309001             "
            "             2A0551092853920 0   AZ 1113834             N";
        actionModule_SetBarcodeRead(barcodeDataFake);
      } else if ((char)c == '3') {
        LOG_F(INFO, "---adding new validation 1---");
        actionModule_validateEntrance(false, 1, 0, VALIDATION_INTERFACE_DSOAP, "teste morpho");
      } else if ((char)c == '4') {
        soapDFlow_sendUpdateImages();
        // soapDFlow_sendPrinterEvent(true);
      } else if ((char)c == '5') {  // AZTEC
        std::string barcodeDataFake =
            "]z2M1JULI/ALESSANDRO     ETWEXEQ GIGFCOAZ 0673 328Y030C0021 362>5321MO6328BAZ 4055366309001             "
            "             2A0551092853920 0   AZ 1113834             N";
        actionModule_SetBarcodeRead(barcodeDataFake);
      } else if ((char)c == '6') {  // QR
        std::string barcodeDataFake =
            "]Q2M1JULI/ALESSANDRO     ETWEXEQ GIGFCOAZ 0673 328Y030C0021 362>5321MO6328BAZ 4055366309001             "
            "             2A0551092853920 0   AZ 1113834             N";
        actionModule_SetBarcodeRead(barcodeDataFake);
      } else if ((char)c == '7') {  // CODE128
        std::string barcodeDataFake =
            "]C2M1JULI/ALESSANDRO     ETWEXEQ GIGFCOAZ 0673 328Y030C0021 362>5321MO6328BAZ 4055366309001             "
            "             2A0551092853920 0   AZ 1113834             N";
        actionModule_SetBarcodeRead(barcodeDataFake);
      } else if ((char)c == '8') {  // DATA MATRIX
        std::string barcodeDataFake =
            "]d2M1JULI/ALESSANDRO     ETWEXEQ GIGFCOAZ 0673 328Y030C0021 362>5321MO6328BAZ 4055366309001             "
            "             2A0551092853920 0   AZ 1113834             N";
        actionModule_SetBarcodeRead(barcodeDataFake);
      } else if ((char)c == '9') {
        Sbg_OnReceiptTaken();
      } else if ((char)c == '!') {
        // Sbg_OnPaxEntry();
      } else if ((char)c == '@') {
        Sbg_OnReceiptTaken();
      } else if ((char)c == '#') {
        // Sbg_OnPaxExit();
      } else if ((char)c == '$') {
        InfoSystem();
      } else if ((char)c == ' ') {
        accelerationFrame = false;
        if (_bltstreamFileOpMode == BLTSTREAM_FILE_MODE_READ) {
          if (_flagPause) {
            _flagStep = true;
          } else {
            _flagPause = true;
          }
        }
      } else if (((char)c == 'a') || ((char)c == 'A')) {
        accelerationFrame = !accelerationFrame;
        LOG_F(INFO, "Acceleration Mode: %s", (accelerationFrame) ? "TRUE" : "FALSE");
      } else if (((char)c == 'b') || ((char)c == 'B')) {
        _saveFrameToBmp = true;
        LOG_F(INFO, "saveFrameToBmp: %s", (_saveFrameToBmp) ? "TRUE" : "FALSE");
      } else if (((char)c == 'c') || ((char)c == 'C')) {
        ActionManager::GetInstance()->SetImageCalibrate();
      } else if (((char)c == 'd') || ((char)c == 'D')) {
      } else if ((char)c == 'e') {
        DoorStatus_InfoDoors(true);
      } else if ((char)c == 'f') {
        char filename[sizeof("image9999999.jpg")];
        sprintf(filename, "image%05d.jpg", _imageCount++);
        imwrite(filename, frame);
      } else if (((char)c == 'g') || ((char)c == 'G')) {  // Force Wrote Frames
        _forceSaveFrames = !_forceSaveFrames;
        LOG_F(INFO, "Force Save Frames: %s", _forceSaveFrames ? "true" : "false");
      } else if ((char)c == 'h') {
        PrintHelp();
      } else if ((char)c == 'i') {
        showInfo = !showInfo;
        LOG_F(INFO, "Show Info: %s", (showInfo) ? "TRUE" : "FALSE");
      } else if ((char)c == 'j') {
        IndicLum_ResetBoardStripLeds(MESSAGE_DELIVERY_GUARANTEE);
      } else if (((char)c == 'k') || ((char)c == 'K')) {
      } else if ((char)c == 'l') {
        bool show = !actionModule_GetSoftExecParam_ShowLayers();
        actionModule_SetSoftExecParam_ShowLayers(show);
        LOG_F(INFO, "Show Layers Regions: %s", (show) ? "TRUE" : "FALSE");
      } else if ((char)c == 'm' || (char)c == 'M') {
      } else if ((char)c == 'n' || (char)c == 'N') {
        _virtualButton = !_virtualButton;
        LOG_F(INFO, "virtualButton %s", _virtualButton ? "TRUE" : "FALSE");
      } else if ((char)c == 'o') {
      } else if ((char)c == 'p') {
        accelerationFrame = false;
        _flagPause = !_flagPause;
      } else if (((char)c == 'q') || ((char)c == 'Q')) {
        frameOrig.release();
        imgFrameOrig.release();
        videoAnalyzer_deallocateFrames();
        INThandler(SIGQUIT);
      } else if ((char)c == 'r') {
      } else if ((char)c == 's') {
      } else if ((char)c == 'S') {
        _snapShotAutoSave = !_snapShotAutoSave;
        LOG_F(INFO, "----------------- SNAPSHOT AUTO SAVE %s -----------------", _snapShotAutoSave ? "ON" : "OFF");
      } else if (((char)c == 't') || ((char)c == 'T')) {
      } else if (((char)c == 'u') || ((char)c == 'U')) {
        _virtualButtonUrn = true;
        _virtualUrnLoop = 5u;
      } else if (((char)c == 'v') || ((char)c == 'V')) {
        int numberId = 0;
        int numberGroup = 0;
        do {
          numberId = rand() % 1000;
          usleep(1);
        } while (!numberId);
        if ((char)c == 'v') {
          LOG_F(INFO, "Validation entrance virtual: ID=%d Group=%d", numberId, numberGroup);
          AddNewValidation(true, numberId, numberGroup, VALIDATION_INTERFACE_REMOTE_CONFIG, "RemoteConfig", false, 0, 0,
                           VALIDATION_INTERFACE_NULL, nullptr);
        } else {
          LOG_F(INFO, "Validation exit virtual: ID=%d Group=%d", numberId, numberGroup);
          AddNewValidation(false, 0, 0, VALIDATION_INTERFACE_NULL, nullptr, true, numberId, numberGroup,
                           VALIDATION_INTERFACE_REMOTE_CONFIG, "RemoteConfig");
        }
      } else if (((char)c == 'w') || ((char)c == 'W')) {
        CleaningMode::GetInstance()->RunCleaning(true);
      } else if (((char)c == 'x') || ((char)c == 'X')) {
        // get pixel per meter
        int multPixH = 1, multPixV = 1;
        VideoAnalyzer_GetPixPmeterFloor(multPixH, multPixV);
        VideoAnalyzer_SetTailgaterMinimunDistance(VideoAnalyzer_GetTailgaterMinimunDistance() + 1);
        actionModule_xmlSetTailgaterMinDistance(VideoAnalyzer_GetTailgaterMinimunDistance());

        // pixels convert to centimeters
        actionModule_xmlSetTailgaterMinDistanceCM(
            (((int)(((float)(actionModule_xmlGetTailgaterMinDistance()) * 1000.f / multPixH))) / 10));

        LOG_F(INFO, "TailgaterMinimunDistance %d TailgaterMinimunDistanceCM %d",
              actionModule_xmlGetTailgaterMinDistance(), actionModule_xmlGetTailgaterMinDistanceCM());
      } else if (((char)c == 'z') || ((char)c == 'Z')) {
        // get pixel per meter
        int multPixH = 1, multPixV = 1;

        VideoAnalyzer_GetPixPmeterFloor(multPixH, multPixV);
        VideoAnalyzer_SetTailgaterMinimunDistance(VideoAnalyzer_GetTailgaterMinimunDistance() - 1);
        actionModule_xmlSetTailgaterMinDistance(VideoAnalyzer_GetTailgaterMinimunDistance());

        // pixels convert to centimeters
        actionModule_xmlSetTailgaterMinDistanceCM(
            (((int)(((float)(actionModule_xmlGetTailgaterMinDistance()) * 1000.f / multPixH))) / 10));

        LOG_F(INFO, "TailgaterMinimunDistance %d TailgaterMinimunDistanceCM %d",
              actionModule_xmlGetTailgaterMinDistance(), actionModule_xmlGetTailgaterMinDistanceCM());
      } else if (((char)c == '<') || ((char)c == ',')) {
        accelerationFrame = false;
        if (_bltstreamFileOpMode == BLTSTREAM_FILE_MODE_READ) {
          if (_flagPause) {
            _flagBackward = true;
            _flagStep = true;
          } else {
            _flagPause = true;
          }
        }
      } else if (((char)c == '+') || ((char)c == '-')) {
        uint16_t step = HEIGHT_TO_GRAYSCALE_CONVERSION_VALUE / UINT8_MAX;
        uint16_t value = actionModule_xmlGetMaxHeightForUserProtection();
        if (value >= step && value < actionModule_xmlGetHeightMax()) {
          value = static_cast<uint16_t>(ROUND_VALUE(static_cast<float>(static_cast<float>(value) / step)));
          value *= step;
          if ((char)c == '+')
            value += step;
          else
            value -= step;
          actionModule_xmlSetMaxHeightForUserProtection(value);
          LOG_F(INFO, "Max height for user protection: %u", actionModule_xmlGetMaxHeightForUserProtection());
          actionModule_xmlWrite(config_file.c_str());
        }
      } else if (((char)c == '\'')) {
        VideoAnalyzer_AutoSaveSnapshots(imgFrameOrig, true);
      }
    }

    timeRemainingRoutines = Util_GetMicroseconds();
    timeWaitKey = timeRemainingRoutines - timeWaitKey;

    /*
     *
     COLETA DE CARTÕES - INICIO
     *
     */

    // carrega variáveis de coleta de cartões
    uint8_t masterCollectCard = 0;
    uint8_t slaveCollectCard = 0;
    static uint8_t lastSlaveCollectCard = 0;
    syncClient_statusCollectUrn(&masterCollectCard, &slaveCollectCard);

    if (tmpflagToggleStateOp != OP_STATE_FIRE_ALARM) {
      // testa se entrou no modo assistencial de coleta de cartões
      if ((slaveCollectCard && !lastSlaveCollectCard) || (!slaveCollectCard && lastSlaveCollectCard)) {
        lastSlaveCollectCard = slaveCollectCard;
        uint8_t minAngle = slaveCollectCard ? 5 : 0;
        DoorCtrl_SetDoorMinAngle(minAngle);
      }
    }

    uint16_t forcedDoorTime_collectCardsUrn = actionModule_xmlGetForcedDoorTime_collectCardsUrn();
    if (tmpflagToggleStateOp != OP_STATE_FIRE_ALARM && tmpflagToggleStateOp != OP_STATE_COLLECT_CARD_URN &&
        tmpflagToggleStateOp != OP_STATE_ALL_FREE && IndicLum_GetCanChangePositionDoors()) {
      if (!forcedDoorTime_collectCardsUrn) {
        DoorsFraudCheck::GetInstance()->Update();
      } else {
        if (!_virtualButtonUrn && !actionModule_getLoadCollectCard() && !actionModule_getRunCollectCard() &&
            _flagGetStatusButtonUrn) {
          static bool isForceCollectCard = false;
          uint16_t angleDoor_10 = DoorStatus_GetAngleDoor(DOOR_10);
          DoorOperationalState statusDoor_10 = DoorStatus_GetOpStatusDoor(DOOR_10);
          if (!isForceCollectCard) {
            if (angleDoor_10 < DIFF_ANGLE_COLLECT_CARD) {
              Timeout_Stop(timeoutForceCollectCard);
              isForceCollectCard = true;
            }
          } else if (!actionModule_IsDoorCollectCardNormalPosition()) {
            isForceCollectCard = false;
          } else if ((actionModule_IsDoorCollectCardNormalPosition()) && (angleDoor_10 >= DIFF_ANGLE_COLLECT_CARD) &&
                     (DoorStatus_GetExecutiveVersion(DOOR_10) > 0.00) &&
                     DoorStatus_DoorWithCorrectStatus((DoorId)0, &statusDoor_10)) {
            actionModule_DoorCollectCardNormalPosition(false);
            if (Timeout_Check(timeoutForceCollectCard)) {
              LOG_F(INFO, "Start collect card urn. Mode: Door forced");
              isForceCollectCard = false;
              _virtualButtonUrn = true;
              _virtualUrnLoop = 5u;
              CollectCardsUrn();
              Timeout_Stop(timeoutForceCollectCard);
            } else if (!Timeout_IsStarted(timeoutForceCollectCard)) {
              LOG_IF_F(9, STDERR_DEBUG, "Start timeout ForceCollectCard");
              Timeout_Start(timeoutForceCollectCard, forcedDoorTime_collectCardsUrn);
            }
          } else if (Timeout_IsStarted(timeoutForceCollectCard)) {
            LOG_IF_F(9, STDERR_DEBUG, "Stop timeout ForceCollectCard");
            Timeout_Stop(timeoutForceCollectCard);
          }
        }
      }
    } else if (!forcedDoorTime_collectCardsUrn) {
      DoorsFraudCheck::GetInstance()->CleansDoorFraudInfo();
    } else if (forcedDoorTime_collectCardsUrn && Timeout_IsStarted(timeoutForceCollectCard)) {
      LOG_IF_F(9, STDERR_DEBUG, "Stop timeout ForceCollectCard");
      Timeout_Stop(timeoutForceCollectCard);
    }

    if (tmpflagToggleStateOp == OP_STATE_COLLECT_CARD_URN && !actionModule_isAnimationButton() &&
        actionModule_getFinishCollectCard()) {
      CollectCardsUrn();
    }

    /*
     *
     COLETA DE CARTÕES - FIM
     *
     */

    // Carrega valor dos IO's
    uint8_t valueIo = IndicLum_GetValueIO();
    static uint8_t lastValueIo = valueIo;
    static uint8_t tmpMask = 0;
    // teste de existencia de sensor de porta de coleta de cartões na urna
    if (!_flagGetStatusButtonUrn) {
      if (valueIo >= 0x80) {
        _flagGetStatusButtonUrn = true;
        tmpMask = 0x80;
        LOG_F(INFO, "Sensor Collect Urn OK");
      }
    } else {
      if (((lastValueIo < tmpMask) && (valueIo >= tmpMask) && (tmpflagToggleStateOp == OP_STATE_COLLECT_CARD_URN)) ||
          ((lastValueIo >= tmpMask) && (valueIo < tmpMask) && (tmpflagToggleStateOp != OP_STATE_COLLECT_CARD_URN))) {
        _virtualButtonUrn = true;
        _virtualUrnLoop = 5u;
        if (tmpflagToggleStateOp != OP_STATE_COLLECT_CARD_URN) {
          CollectCardsUrn();
        }
      }
    }

    if (lastValueIo != valueIo) {
      lastValueIo = valueIo;
    }

    // testa valor dos IO's
    uint8_t tmpIdButton = 0;
    // LOG_F(WARNING, "valueIo: %u", valueIo);
    if (valueIo == (BUTTON_M0 | tmpMask)) {
      tmpIdButton = BUTTON_M0;
    } else if ((_virtualButton) || (valueIo == (BUTTON_M1 | tmpMask))) {
      tmpIdButton = BUTTON_M1;
    } else if (_virtualButtonUrn) {
      if ((tmpflagToggleStateOp != OP_STATE_FIRE_ALARM) && (tmpflagToggleStateOp != OP_STATE_ALL_FREE)) {
        if (!VideoAnalyzer_IsValidationInToOutRegionBarrier() && !VideoAnalyzer_IsValidationOutToInRegionBarrier()) {
          tmpIdButton = BUTTON_COLLECT_CARD;
        }
      }
    } else if (valueIo == (BUTTON_M2 | tmpMask)) {
      tmpIdButton = BUTTON_M2;
    } else if (valueIo == (BUTTON_M3 | tmpMask)) {
      tmpIdButton = BUTTON_M3;
    } else if (valueIo == (BUTTON_M4 | tmpMask)) {
      tmpIdButton = BUTTON_M4;
    } else if (valueIo == (BUTTON_M5 | tmpMask)) {
      tmpIdButton = BUTTON_M5;
    } else if (valueIo == (BUTTON_M6 | tmpMask)) {
      tmpIdButton = BUTTON_M6;
    }

    // Se IO != 0, envia valor para actionModule
    if (tmpIdButton) actionModule_holdButton(tmpIdButton);

    if (tempoAtualizacaoInfo.Check()) {
      if (_bltstreamFileOpMode != BLTSTREAM_FILE_MODE_READ) {
        InfoSystem();
        if (Indiclum_IsConnected()) DoorStatus_InfoDoors();
      }
      tempoAtualizacaoInfo.Start(timeIntervalInfo);
    }

    DoorStatusManager::GetInstance()->Update();

    if (_flagUpdating) {
      actionModule_eventUpdating();
      actionModule_eventLostLedConnectionCancel();
    } else {
      actionModule_eventUpdatingCancel();

      // test if is connected with LEDS
      if (!Indiclum_IsConnected() && !_needStartIndiclum) {
        actionModule_eventLostLedConnection();
      }
    }

    // test if need activate the fireAlarmEvent
    if (ActionManager::GetInstance()->IsFireAlarmEnabled()) {
      actionModule_eventFireAlarm();
    } else {
      actionModule_eventFireAlarmCancel();
    }

    // return true if is forcing the entrace doors
    if (DoorStatus_ForceEntranceStart() || DoorStatus_ForceExitStart()) {
      soapDFlow_addEventToSend(ns2__EventEnumType__DOORS_USCOREFORCED_USCOREDETECTED);
    }
    // return true if is forcing the exit doors
    if (DoorStatus_ForceEntranceEnd() || DoorStatus_ForceExitEnd()) {
      soapDFlow_addEventToSend(ns2__EventEnumType__DOORS_USCOREFORCED_USCORESTOPPED);
    }

    if (actionModule_KillApp()) {
      InfoSystem();
      INThandler(SIGQUIT);
      continue;
    }

    // process the actions in the end of this loop
    actionModule_processActions();
    actionModule_cleanPersonsCross();

    // get the change on the bloq state
    if (actionModule_parameters_haveChanged()) {
      DoorsOperatingMode tmpOpModeDoors = actionModule_xmlGetOpModeDoor();
      if (tmpOpModeDoors != DOOR_MODE_TRAP && tmpOpModeDoors != DOOR_MODE_DVIATOR_Y) {
        // test if need door open or closed
        if (actionModule_parameters_getAbrirPortas()) {
          // DOOR OPEN
          if (tmpOpModeDoors == DOOR_MODE_BIDIRECTIONAL_OPEN || tmpOpModeDoors == DOOR_MODE_CENTRALIZED_CLOSED) {
            actionModule_setOpModeDoor(DOOR_MODE_BIDIRECTIONAL_OPEN);
            actionModule_xmlSetOpModeDoor(DOOR_MODE_BIDIRECTIONAL_OPEN);
          } else {
            actionModule_setOpModeDoor(DOOR_MODE_DECENTRALIZED_OPEN);
            actionModule_xmlSetOpModeDoor(DOOR_MODE_DECENTRALIZED_OPEN);
          }
        } else {
          // DOOR CLOSED
          if (tmpOpModeDoors == DOOR_MODE_BIDIRECTIONAL_OPEN || tmpOpModeDoors == DOOR_MODE_CENTRALIZED_CLOSED) {
            actionModule_setOpModeDoor(DOOR_MODE_CENTRALIZED_CLOSED);
            actionModule_xmlSetOpModeDoor(DOOR_MODE_CENTRALIZED_CLOSED);
          } else {
            actionModule_setOpModeDoor(DOOR_MODE_DECENTRALIZED_CLOSED);
            actionModule_xmlSetOpModeDoor(DOOR_MODE_DECENTRALIZED_CLOSED);
          }
        }

        if (tmpOpModeDoors != actionModule_xmlGetOpModeDoor()) {
          // clean the MCA users from the list
          _readers->SendChangeStatusForAllUsersMCASP();
          // remove the validations from the ReaderPerson's
          _readers->RemoveAllPersons();
        }
      }

      // test if it's the old version
      if (actionModule_parameters_getMonitorversion() == MONITOR_174) {
        OperationalState tempEntrada = actionModule_getStateIn();
        OperationalState tempSaida = actionModule_getStateOut();

        // get the values
        switch (actionModule_parameters_getEstadoOper()) {
          case 1:
            // ENTRADA
            tempEntrada = OP_STATE_CONTROLED;
            tempSaida = OP_STATE_FREE;
            break;
          case 2:
            // BIDIRECIONAL
            tempEntrada = OP_STATE_FREE;
            tempSaida = OP_STATE_FREE;
            break;
          case 3:
            // FORA OPERACAO
            tempEntrada = OP_STATE_CLOSED;
            tempSaida = OP_STATE_CLOSED;

            // ENTRADA FECHADA
            actionModule_setStateIn(OP_STATE_CLOSED);
            // SAIDA FECHADA
            actionModule_setStateOut(OP_STATE_CLOSED);
            break;
        }
        if (tempEntrada != actionModule_getStateIn() || tempSaida != actionModule_getStateOut()) {
          actionModule_setState(tempEntrada, tempSaida);
          // clean the MCA users from the list
          _readers->SendChangeStatusForAllUsersMCASP();
          // remove the validations from the ReaderPerson's
          _readers->Readers::RemoveAllPersons();
        }
      } else {
        OperationalState tempEntrada = actionModule_getStateIn();
        OperationalState tempSaida = actionModule_getStateOut();
        // ENTRANCE
        switch (actionModule_parameters_getEstadoOper()) {
          case 1:
            // FREE
            tempEntrada = OP_STATE_FREE;
            break;
          case 2:
            // CONTROLED
            tempEntrada = OP_STATE_CONTROLED;
            break;
          case 3:
            // OUT OF OPERATION
            tempEntrada = OP_STATE_CLOSED;
            break;
        }
        // EXIT
        switch (actionModule_parameters_getEstadoOper2()) {
          case 1:
            // FREE
            tempSaida = OP_STATE_FREE;
            break;
          case 2:
            // CONTROLED
            tempSaida = OP_STATE_CONTROLED;
            break;
          case 3:
            // OUT OF OPERATION
            tempSaida = OP_STATE_CLOSED;
            break;
        }
        if (tempEntrada != actionModule_getStateIn() || tempSaida != actionModule_getStateOut()) {
          actionModule_setState(tempEntrada, tempSaida);
          // clean the MCA users from the list
          _readers->SendChangeStatusForAllUsersMCASP();
          // remove the validations from the ReaderPerson's
          _readers->RemoveAllPersons();
        }
      }
      // update the state
      actionModule_xmlSetStateEntrance(actionModule_getStateIn());
      actionModule_xmlSetStateExit(actionModule_getStateOut());
      // set the validation timeout
      if (1 <= actionModule_parameters_getTimeoutCorredor()) {
        // set timeout
        actionModule_xmlSetTimeOutValidation(actionModule_parameters_getTimeoutCorredor());
      }
      // test gerar log
      if (actionModule_parameters_getGerarLogAuditoria()) {
        // GERAR LOG AUDITORIA TRUE
      } else {
        // GERAR LOG AUDITORIA FALSE
      }
      // test gerar transacoes
      if (actionModule_parameters_getGerarTransacoes()) {
        // GERAR TRANSACOES TRUE
      } else {
        // GERAR TRANSACOES FALSE
      }
      // salvar o XML
      actionModule_xmlWrite(config_file.c_str());
    }
    // update the eventSender
    infoMonitor_updateEvents();

    if (VisualCortex::GetInstance()->GetBrainConnected()) {
      VideoAnalyzer_SaveRegisteredInvalidInvasion();
    }

    snmpArgs.avgPictureQuality = _avgPictureQuality;
    snmpArgs.checkSpaceHd = _checkSpaceHd;
    snmpArgs.checkSpaceRam = _checkSpaceRam;
    snmpArgs.checkTotalRam = _checkTotalRam;
    snmpArgs.checkTotalSpaceHd = _checkTotalSpaceHd;
    snmpArgs.fpsAverage = _fpsAverage;
    snmpArgs.numberCurrentFrame = VideoAnalyzer_GetNumberFrame();
    snmpArgs.tempLed = _tempLed;
    snmpArgs.tempMain = _tempMain;
    if (SnmpModule::GetInstance()) {
      SnmpModule::GetInstance()->UpdateArgs(snmpArgs);
    }

    uint32_t tmpTimeMicro = Util_GetMicroseconds();
    timeRemainingRoutines = tmpTimeMicro - timeRemainingRoutines;
    totalTimeLoop = tmpTimeMicro - totalTimeLoop;
    float fpsFactor = static_cast<float>(FPS_AVERAGE) / _fpsAverage;
    mainLoopTime = Util_GetMicroseconds() - mainLoopTime;
    static bool logShowInfo = false;
    if ((logShowInfo = ((mainLoopTime > (MAIN_LOOP_LIMIT_TIME_US * fpsFactor)) && (mainLoopTime < INT32_MAX)))) {
      if (_flagPause) logShowInfo = false;
      LOG_IF_F(WARNING, logShowInfo, "main loop took %u us to complete.", mainLoopTime);
    }
    mainLoopTime = Util_GetMicroseconds();

    if ((((!_flagPause) || (_flagStep)) && (showInfo)) || logShowInfo) {
      if (((modelCam == TIMETH) || (modelCam == M100) || (modelCam == P323) || (modelCam == P23X)) &&
          (_bltstreamFileOpMode == BLTSTREAM_FILE_MODE_WRITE)) {
        _tempLed = VideoAnalyzer_GetTemperatureCamLeds();
        _tempMain = VideoAnalyzer_GetMainTemperatureCam();
        LOG_F(INFO, "Current temperature - Leds: %dºC | Main: %dºC", _tempLed, _tempMain);
      }
      LOG_F(INFO,
            "%d s - TotalLoop: %05u us, "
            "Init: %05u us, "
            "Validation: %05u us, "
            "GetFrame: %05u us, "
            "Extract: %05u us, "
            "GetPerson: %05u us, "
            "Draw: %05u us, "
            "WriteInfo: %05u us, "
            "Window: %05u us, "
            "Save: %05u us, "
            "WaitKey: %05u us, "
            "Remaining routines: %05u us",
            timeRunning, totalTimeLoop, timeInit, timeValidation, timeFrame, timeContoursAndObjects, timeGetPerson,
            timeDrawPerson, timeWriteInfo, timeShow, timeSave, timeWaitKey, timeRemainingRoutines);
    }

#ifdef MUTEX_MODULE_ENABLED
    MutexModule::getInstance()->setKeepAliveMain();
#endif
    usleep(100);
  }

  Timeout_Destroy(timeoutScatterbrain);
  Timeout_Destroy(timeoutLedScatterbrain);
  Timeout_Destroy(timeoutSomethingProtectInToOut);
  Timeout_Destroy(timeoutSomethingProtectOutToIn);
  Timeout_Destroy(timeoutForceCollectCard);
  KillApp();
  LOG_F(INFO, "All right then. Take it easy and bye for now!");
  return EXIT_SUCCESS;
}
